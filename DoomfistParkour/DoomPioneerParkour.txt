settings
{
	main
	{
		Description: "Doomfist Pioneering Parkour - Code WARMR. Press Interact for controls. Change game parameters: Lobby -> Settings -> Workshop Settings. Made by WelkinTern, based on original Pioneer Parkour by kaeku (X8080), using ideas & code from Hax, khandescension, nebula. Last Updated: July 3, 2021. Request a feature, report issue on discord.gg/doomfistparkour or https://github.com/WelkinU/OverwatchWorkshopScripts/"
	}

	lobby
	{
		Max Team 1 Players: 12
		Max Team 2 Players: 0
	}

	modes
	{
		Skirmish
		{
			enabled maps
			{
				Dorado
			}
		}

		Team Deathmatch
		{
			enabled maps
			{
			}
		}

		General
		{
			Hero Limit: Off
			Kill Feed: Off
		}
	}

	heroes
	{
		General
		{
			Ultimate Generation - Passive: 0%

			Ana
			{
				Ammunition Clip Size Scalar: 25%
				Biotic Grenade Cooldown Time: 60%
				Sleep Dart Cooldown Time: 75%
			}

			Baptiste
			{
				Immortality Field Cooldown Time: 70%
				Regenerative Burst Cooldown Time: 70%
			}

			Bastion
			{
				Damage Dealt: 10%
				Damage Received: 10%
				Infinite Ultimate Duration: On
				Self-Repair Maximum Time: 500%
				Self-Repair Recharge Rate: 500%
			}

			D.Va
			{
				Spawn With Ultimate Ready: On
			}

			Doomfist
			{
				Seismic Slam Cooldown Time: 66%
			}

			Genji
			{
				Ammunition Clip Size Scalar: 25%
				Swift Strike Cooldown Time: 75%
				Ultimate Duration: 34%
			}

			Roadhog
			{
				Ammunition Clip Size Scalar: 40%
				Chain Hook Cooldown Time: 75%
				Take a Breather Cooldown Time: 75%
			}

			Sigma
			{
				Accretion Cooldown Time: 60%
				Kinetic Grasp Cooldown Time: 20%
			}

			Widowmaker
			{
				Grappling Hook Cooldown Time: 0%
			}

			Winston
			{
				No Ammunition Requirement: On
				Ultimate Duration: 60%
			}

			enabled heroes
			{
				Doomfist
			}
		}
	}
}

variables
{
	global:
		0: CPLocations
		1: PioneerList
		2: CPAbilityCounts
		3: CPUltimateTeleportPrimary
		4: CPFacingDirections
		5: CPHeroList
		6: GameStarted
		7: PioneerTimer
		8: CurrentPioneer
		9: MultiHeroEnabled
		10: SkipTimeLimit
		11: InfiniteModeEnabledConstant
		12: AbilityCountsEnabledConstant
		13: DownwardsDiagEnabledConstant
		14: PioneerTimeLimitConstant
		15: PlayerMoveSpeedConstant
		16: NonInfiniteModeWinTime
		17: PioneerMinDistanceConstant
		18: PunchGraceEnabled
		19: PrimaryFireUsefulForTheseHeros
		20: CPRadius
		21: CPSpecialRequirementsArray
		22: HeroRoster
		23: CPGreenSphereArray
		24: GreenSphereRadiusConstant
		25: CPEffectLockSphereArray
		26: EffectLockSphereRadiusConstant
		27: DevModeEngaged
		28: CPKillSphereArray
		29: UltimateAbilitiesEnabledConstant
		30: ReplaysEnabledConstant
		31: ReplayPioneerPositionArray
		32: ReplayPioneerFacingArray
		33: UsingMemoryRecall
		34: CPPlayerScaleArray
		35: AllowedPlayerScalesArray
		36: EffectLockAbilitiesArray
		37: DisableHUDConstant
		38: EffectLocksOrderMatters
		39: EffectLocksResetCooldownConstant
		40: MrDestructoVector
		41: MsDestructo

	player:
		0: CurrentCP
		2: MaxUnlockedCP
		3: Invisible
		4: CPAbilityCounts
		5: CountUltimateTeleportPrimary
		6: FacingDirectionLeavingCP
		7: TeleportEnabled
		8: TimeSpentOnCP
		9: SpectateMode
		10: ForceRespawn
		11: BlockArriveNextPoint
		12: BlockPioneerNewPoint
		13: EffectLockObtained
		14: SlamTimer
		15: PunchFixStore
		16: GreenSphereLocation
		17: EffectLockSphereLocation
		18: KillSphereLocation
		19: ReplayPosition
		20: ReplayFacing
		21: PlayerScale
		22: TempVariable
		23: TempVariable2
		24: CancelPointTimer
		25: TempMenuIDStore
		26: sigma_barrier_ready_to_destroy
		27: sigma_barrier_ON
		28: sigma_barrier_direction
		29: sigma_barrier_init_position
		30: sigma_barrier_chase
		31: sigma_barrier_position
		32: Grace
		33: WinstonLeapGrace
		34: Count360Slam125
		35: BlockPioneerPass
		36: WinstonWallClimbEnabled
		37: WinstonWallClimbTimer
		38: WinstonBubbleLocation
		39: WinstonBouncyBubbleCooldown
		40: WinstonBubbleEffect
		41: HeroSelectMenuOpen
		42: MenuInWorldLocationTempStore
		43: MenuTextIDTempStore
		44: TempIterator
		45: AnaSleepDartTeleLocation
		46: RoadhogHookPosition
		47: AbilitiesForEffectLock
		48: TextIDTempStore
		49: AbilityLimitsDisplayVar
		50: EffectLockTimerChase
		51: ThreeSecondBounceTimer
		52: BounceTimerEnabled
		53: CPSpecialRequirements
		54: FreeRoamEnabled
}

subroutines
{
	0: RespawnPlayer
	2: CancelMomentum
	3: HandleSkipTimer
	4: MemoryRecall
	5: UpdatePlayerScale
	6: CheckAbilityCounts
	7: CreateEffectLocks
}

rule("--------MEMORY: PASTE VARIABLES HERE -------------------")
{
	event
	{
		Subroutine;
		MemoryRecall;
	}
}

disabled rule("Initialization")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Initialize Globals")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Disable Inspector Recording;
		Pause Match Time;
		" ADD HEROS HERE AND THEY WILL AUTOMATICALLY SHOW UP IN THE HERO SELECT MENU FOR MULTI-HERO MODE"
		Global.HeroRoster = Array(Hero(Doomfist), Hero(Sigma), Hero(Genji), Hero(Winston), Hero(Wrecking Ball), Hero(LÃºcio), Hero(Roadhog),
			Hero(Junkrat), Hero(Ana), Hero(Bastion));
		"PLAYER SCALES WILL CYCLE THROUGH THIS ARRAY OF SIZES WHEN PRESSING INTERACT + W "
		Global.AllowedPlayerScalesArray = Array(0.100, 1, 2, 4);
		Global.AbilityCountsEnabledConstant = Workshop Setting Toggle(Custom String("Important Settings"), Custom String(
			"Ability Count Limits Enabled"), True, 0);
		Global.PioneerTimeLimitConstant = Workshop Setting Integer(Custom String("Important Settings"), Custom String(
			"Pioneer Time Limit in Seconds"), 180, 30, 420, 0);
		Global.SkipTimeLimit = Workshop Setting Integer(Custom String("Important Settings"), Custom String(
			"Seconds Before Player Can Skip Level"), 240, 60, 9999, 0);
		Global.ReplaysEnabledConstant = Workshop Setting Toggle(Custom String("Experimental"), Custom String(
			"Enable Pioneer Replays (Can cause large server load at 40+ CP's)"), True, 0);
		Global.UltimateAbilitiesEnabledConstant = Workshop Setting Toggle(Custom String("Gameplay"), Custom String(
			"Ultimate Abilites Enabled"), False, 0);
		Global.PunchGraceEnabled = Workshop Setting Toggle(Custom String("Gameplay"), Custom String("Punch Grace Enabled"), True, 0);
		Global.NonInfiniteModeWinTime = Workshop Setting Integer(Custom String("Infinite Mode"), Custom String(
			"Time Limit Before Victory in Non-Infinite Mode"), 300, 90, 1200, 0);
		"Set up workshop toggle/int/real variables"
		Global.InfiniteModeEnabledConstant = Workshop Setting Toggle(Custom String("Infinite Mode"), Custom String(
			"Infinite Mode Enabled"), True, 0);
		Global.MultiHeroEnabled = Workshop Setting Toggle(Custom String("Gameplay"), Custom String(
			"Multi-Hero Mode Enabled (Wrecking Ball, Genji, Ana, Sigma, etc)"), True, 0);
		Global.DisableHUDConstant = Workshop Setting Toggle(Custom String("Important Settings"), Custom String(
			"Disable HUD (Mostly For Recording Gameplay)"), False, 9);
		Global.EffectLocksOrderMatters = Workshop Setting Toggle(Custom String("Important Settings"), Custom String(
			"Effect Locks Must Be Obtained In Pioneer Order"), True, 9);
		Global.EffectLocksResetCooldownConstant = Workshop Setting Toggle(Custom String("Experimental"), Custom String(
			"Effect Locks Reset Ability Cooldowns (For Speedrunning)"), False, 0);
		Global.DownwardsDiagEnabledConstant = Workshop Setting Toggle(Custom String("Gameplay"), Custom String(
			"Downwards Diagonal Punch Enabled"), True, 0);
		Global.PioneerMinDistanceConstant = 6;
		Global.PrimaryFireUsefulForTheseHeros = Array(Hero(Ana));
		Global.GameStarted = False;
		Global.DevModeEngaged = False;
		Global.ReplayPioneerPositionArray = Empty Array;
		Global.ReplayPioneerFacingArray = Empty Array;
		"Green Sphere Create Pioneer Only"
		Create Effect(Filtered Array(Global.CurrentPioneer, Current Array Element.GreenSphereLocation != Null), Sphere, Color(Green),
			Global.CurrentPioneer.GreenSphereLocation, Global.GreenSphereRadiusConstant, Visible To Position and Radius);
		"Kill Sphere Create Pioneer Only"
		Create Effect(Filtered Array(Global.CurrentPioneer, Current Array Element.KillSphereLocation != Null), Sphere, Color(Red),
			Global.CurrentPioneer.KillSphereLocation, Global.GreenSphereRadiusConstant, Visible To Position and Radius);
		Global.MrDestructoVector = Empty Array;
		Global.CPRadius = 2;
		Global.GreenSphereRadiusConstant = 3.500;
		Global.EffectLockSphereRadiusConstant = 1.700;
		Global.PlayerMoveSpeedConstant = 100;
	}
}

rule("Global HUD + Controls HUD + General Effects / Icons")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.DisableHUDConstant == False;
	}

	actions
	{
		"Only show pioneer info to players within 1-2 CP's of final CP"
		Create HUD Text(Filtered Array(All Players(All Teams),
			Global.GameStarted && Global.CurrentPioneer != Null && Current Array Element.CurrentCP + 2 >= Count Of(Global.CPLocations)),
			Custom String("Pioneer: {0}\r\nTime: {1}", Global.CurrentPioneer != Null ? Global.CurrentPioneer : Custom String("None"),
			Global.PioneerTimer), Null, Null, Left, -1, Color(White), Color(White), Color(White), Visible To and String,
			Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Global.GameStarted == False), Custom String(
			"{0} Press R to Create Origin Point!", Host Player), Null, Null, Top, 0, Color(Green), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Create HUD Text(Host Player, Null, Null, Custom String("Server Load {0} | Avg {1} | Peak {2}", Server Load, Server Load Average,
			Server Load Peak), Right, -1, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Living Players(All Teams), !Is Button Held(Current Array Element, Button(Interact))), Null,
			Null, Custom String("Hold {0} For Controls / Game Settings\r\nNeed Healing | Checkpoint Route", Input Binding String(Button(
			Interact))), Left, -1, Color(White), Color(White), Color(Red), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("Workshop Code: WARMR"), Right, -2, Color(White), Color(White),
			Color(White), Visible To, Default Visibility);
		"Create HUD showing abilities the pioneer has used"
		disabled Create HUD Text(Global.CurrentPioneer, Custom String("Abilty Counts\r\n{0} {1} {2}", Custom String("{0} {1}", Ability Icon String(
			Hero Of(Global.CurrentPioneer), Button(Secondary Fire)), X Component Of(Global.CurrentPioneer.CPAbilityCounts)), Custom String(
			"{0} {1}", Ability Icon String(Hero Of(Global.CurrentPioneer), Button(Ability 1)), Y Component Of(
			Global.CurrentPioneer.CPAbilityCounts)), Custom String("{0} {1}", Ability Icon String(Hero Of(Global.CurrentPioneer), Button(
			Ability 2)), Z Component Of(Global.CurrentPioneer.CPAbilityCounts))), Null, Null, Top, -1.400, Color(Blue), Color(White),
			Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Is Button Held(Current Array Element, Button(Interact))), Null, Null,
			Custom String("{0} | Quick Reset\r\n{1} +\r\n{2}", Input Binding String(Button(Reload)), Input Binding String(Button(
			Interact)), Custom String("{0}\r\n{1}\r\n{2}", Custom String(
			"    +  {0}  | Preview Next Checkpoint ( {0} again to view effect locks )\r\n    +  {1}  | Spectate", Input Binding String(
			Button(Primary Fire)), Input Binding String(Button(Melee))), Custom String(
			"    +  {0}  | Skip CP (After {1}sec)\r\n    +  {2}  | Previous CP", Input Binding String(Button(Jump)), Global.SkipTimeLimit,
			Input Binding String(Button(Crouch))), Custom String("{1}\r\n{0}", Custom String(
			"{0}  +  {1}  | Toggle Invisiblity\r\nNeed Healing/Help | Replay Pioneer Route", Input Binding String(Button(Jump)),
			Input Binding String(Button(Crouch))), Custom String("    +  {0}  | Toggle Bounce Timer & Bhop Reset Detector",
			Input Binding String(Button(Ultimate)))))), Left, 0, Color(White), Color(White), Color(White), Visible To and String,
			Visible Never);
		Create HUD Text(Filtered Array(All Players(All Teams), Is Button Held(Current Array Element, Button(Interact))), Null, Null,
			Custom String(" \r\n- - - - - - - - - - - Pioneer Controls - - - - - - - - - - -\r\n{0}\r\n{1}\r\n", Custom String(
			"{0} | Create Effect Lock\r\n{1} | Create Env. Collision Sphere\r\nGroup Up | Create Kill Sphere", Input Binding String(Button(
			Melee)), Input Binding String(Button(Crouch))), Custom String(
			"{0}  +  {1}  | Reset Sphere Effects\r\n     +  Up/Down  | Change Size\r\n     +  Ult Status  | Hero Switch Menu\r\n{2}",
			Input Binding String(Button(Interact)), Input Binding String(Button(Reload)), Custom String("{0}  +  {1}  | Teleport",
			Input Binding String(Button(Primary Fire)), Input Binding String(Button(Melee))))), Left, 1, Color(White), Color(White), Color(
			White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Is Button Held(Current Array Element, Button(Interact))), Null, Null,
			Custom String(
			"- - - - - - - - - - - - - - - - - - - - - -Host Controls- - - - - - - - - - - - - - - - - - - - - -\r\n{0}\r\n{1}\r\n{2}",
			Custom String("{0} + Hello | Dev Mode (Players Can Skip Levels)\r\n{1} + Emote + Dev Mode On | Delete Last CP",
			Input Binding String(Button(Interact)), Input Binding String(Button(Melee))), Custom String(
			" \r\nLobby-> Settings-> Workshop Settings: Update Game Constants"), Custom String(" \r\n{0}\r\n{1}", Custom String(
			"Save Map:\r\n1. Open Workshop Inspector, set \"variable target\" to Global\r\n2. Press button [X] on bottom to copy all variables"),
			Custom String(
			"3. Open Workshop Editor, open first rule & paste. \r\nDelete the two \"ReplayPioneer\" variables (giant arrays)"))), Right, 2,
			Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(All Living Players(All Teams), Null, Null, Custom String("Checkpoint {0}/{1} - Time Spent On CP {2}",
			Local Player.CurrentCP, Count Of(Global.CPLocations) - 1, Local Player.TimeSpentOnCP), Top, 0, Color(White), Color(White),
			Color(White), Visible To and String, Default Visibility);
		disabled Create HUD Text(Filtered Array(All Living Players(All Teams),
			Global.AbilityCountsEnabledConstant && Current Array Element.CurrentCP + 1 < Count Of(Global.CPLocations)), Custom String(
			"Checkpoint Abilty Limits\r\n{0} {1} {2}", Custom String("{0} {1}", Ability Icon String(Hero Of(Local Player), Button(
			Secondary Fire)), X Component Of(Local Player.AbilityLimitsDisplayVar)), Custom String("{0} {1}", Ability Icon String(Hero Of(
			Local Player), Button(Ability 1)), Y Component Of(Local Player.AbilityLimitsDisplayVar)), Custom String("{0} {1}",
			Ability Icon String(Hero Of(Local Player), Button(Ability 2)), Z Component Of(Local Player.AbilityLimitsDisplayVar))), Null,
			Null, Top, -1.400, Color(Blue), Color(White), Color(White), Visible To and String, Default Visibility);
		disabled Create Icon(Filtered Array(All Players(All Teams), Count Of(Global.CPLocations) > Current Array Element.CurrentCP + 1),
			Global.CPLocations[Local Player.CurrentCP + 1] + Up, Flag, Visible To and Position, Color(Yellow), True);
		disabled Create In-World Text(Filtered Array(All Players(All Teams), Count Of(Global.CPLocations) > Current Array Element.CurrentCP + 1),
			Custom String("Come Here\r\nPioneer: {0}", Global.PioneerList[Local Player.CurrentCP + 1]),
			Global.CPLocations[Local Player.CurrentCP + 1] + Up, 1.300, Do Not Clip, Visible To Position and String, Color(Yellow),
			Default Visibility);
		"Effect lock icon over CP (before getting all locks) - similar to hax framework"
		disabled Create In-World Text(Filtered Array(All Living Players(All Teams), Count Of(
			Global.CPEffectLockSphereArray[Current Array Element.CurrentCP]) > 0 && Count Of(Current Array Element.EffectLockObtained)
			< Count Of(Global.CPEffectLockSphereArray[Current Array Element.CurrentCP])), Custom String("{0}", Ability Icon String(Hero(
			Winston), Button(Ability 2))), Global.CPLocations[Local Player.CurrentCP + 1], 1.300, Clip Against Surfaces,
			Visible To and Position, Color(White), Default Visibility);
		"Push the progress bar for stall 3 sec bounce timer down the screen"
		Create HUD Text(Filtered Array(All Living Players(All Teams), Current Array Element.ThreeSecondBounceTimer > 0.300), Null, Null,
			Custom String("{0}", String Slice(Custom String(
			" \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"), 0,
			Global.CurrentPioneer == Local Player ? 40 : 34)), Top, 9.900, Color(White), Color(White), Color(White), Visible To and String,
			Default Visibility);
		Create Progress Bar HUD Text(Filtered Array(All Living Players(All Teams), Current Array Element.ThreeSecondBounceTimer > 0.300),
			Local Player.ThreeSecondBounceTimer / 0.030, Custom String("Bounce Timer"), Top, 10, Color(White), Color(White),
			Visible To and Values, Default Visibility);
		Create HUD Text(Filtered Array(All Living Players(All Teams), X Component Of(
			Global.CPSpecialRequirementsArray[Current Array Element.CurrentCP]) > 0), Custom String("{0}", Ability Icon String(Hero(
			Tracer), Button(Ability 2))), Custom String("CP Special Requirement"), Custom String("Downwards Diagonal Punch Required"),
			Left, 3, Color(Green), Color(Orange), Color(White), Visible To, Default Visibility);
		Create HUD Text(Filtered Array(All Living Players(All Teams), Current Array Element.TimeSpentOnCP > Global.SkipTimeLimit), Null,
			Custom String("Skip Checkpoint Available"), Custom String("{0} + {1}", Input Binding String(Button(Interact)),
			Input Binding String(Button(Jump))), Left, 2, Color(White), Color(Orange), Color(White), Visible To and String,
			Default Visibility);
		Create HUD Text(Filtered Array(Host Player, Global.DevModeEngaged), Null, Null, Custom String("Position: {0}", Position Of(
			Local Player)), Left, 40, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
	}
}

rule("Initialize player + Ring Effects")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Event Player.PlayerScale = 1;
		"Punch grace from Hax framework"
		Chase Player Variable At Rate(Event Player, Grace, Is Firing Secondary(Event Player) ? 0.500 : False, Is Firing Secondary(
			Event Player) ? 0.260 : True, Destination and Rate);
		Event Player.CurrentCP = 0;
		Event Player.BlockArriveNextPoint = False;
		Set Status(Event Player, Null, Phased Out, 9999);
		Event Player.BlockPioneerNewPoint = False;
		Event Player.CancelPointTimer = 0;
		Event Player.TeleportEnabled = True;
		Enable Death Spectate All Players(Event Player);
		Enable Death Spectate Target HUD(Event Player);
		Disable Game Mode In-World UI(Event Player);
		Disable Game Mode HUD(Event Player);
		Event Player.TimeSpentOnCP = 0;
		Event Player.Invisible = True;
		Set Invisible(Event Player, All);
		Event Player.BlockPioneerPass = False;
		Chase Player Variable At Rate(Event Player, EffectLockTimerChase, 0, 1, None);
		"Create Ring Effects"
		Create Effect(Event Player, Ring, Color(White), Global.CPLocations[Event Player.CurrentCP], Global.CPRadius,
			Visible To Position and Radius);
		Create Effect(Filtered Array(Event Player, Count Of(Global.CPLocations) > Current Array Element.CurrentCP + 1), Ring, Color(
			Purple), Global.CPLocations[Event Player.CurrentCP + 1], Global.CPRadius, Visible To Position and Radius);
		Chase Player Variable At Rate(Event Player, ThreeSecondBounceTimer, Speed Of(Event Player) > 0.070 || Is Using Ultimate(
			Event Player) || Event Player.CancelPointTimer > 0 || Is On Ground(Event Player) ? 0 : 4, Speed Of(Event Player)
			> 0.070 || Is Using Ultimate(Event Player) || Event Player.CancelPointTimer > 0 || Is On Ground(Event Player) ? 9999 : 1,
			Destination and Rate);
		Event Player.BounceTimerEnabled = True;
		Event Player.FreeRoamEnabled = False;
	}
}

rule("Player-Specific HUD")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.DisableHUDConstant == False;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} {1}", Evaluate Once(Event Player),
			Event Player.MaxUnlockedCP), Right, 100 - Event Player.MaxUnlockedCP, Color(White), Color(White), Color(Green),
			Visible To Sort Order and String, Default Visibility);
		Create HUD Text(Filtered Array(Event Player, Global.AbilityCountsEnabledConstant && Current Array Element.CurrentCP + 1 < Count Of(
			Global.CPLocations)), Custom String("Checkpoint Abilty Limits\r\n{0} {1} {2}", Custom String("{0} {1}", Ability Icon String(
			Hero Of(Event Player), Button(Secondary Fire)), X Component Of(Event Player.AbilityLimitsDisplayVar)), Custom String("{0} {1}",
			Ability Icon String(Hero Of(Event Player), Button(Ability 1)), Y Component Of(Event Player.AbilityLimitsDisplayVar)),
			Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Ability 2)), Z Component Of(
			Event Player.AbilityLimitsDisplayVar))), Null, Null, Top, -1.400, Color(Blue), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Create Icon(Filtered Array(Event Player, Count Of(Global.CPLocations) > Current Array Element.CurrentCP + 1),
			Global.CPLocations[Event Player.CurrentCP + 1] + Up, Flag, Visible To and Position, Color(Yellow), True);
		Create In-World Text(Filtered Array(Event Player, Count Of(Global.CPLocations) > Current Array Element.CurrentCP + 1),
			Custom String("Come Here\r\nPioneer: {0}", Global.PioneerList[Event Player.CurrentCP + 1]),
			Global.CPLocations[Event Player.CurrentCP + 1] + Up, 1.300, Do Not Clip, Visible To Position and String, Color(Yellow),
			Default Visibility);
		"Effect lock icon over CP (before getting all locks) - similar to hax framework"
		Create In-World Text(Filtered Array(Event Player, Count Of(Global.CPEffectLockSphereArray[Current Array Element.CurrentCP])
			> 0 && Count Of(Current Array Element.EffectLockObtained) < Count Of(
			Global.CPEffectLockSphereArray[Current Array Element.CurrentCP])), Custom String("{0}", Ability Icon String(Hero(Winston),
			Button(Ability 2))), Global.CPLocations[Event Player.CurrentCP + 1], 1.300, Clip Against Surfaces, Visible To and Position,
			Color(White), Default Visibility);
	}
}

disabled rule("Game Framework")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Create Origin Point (Checkpoint 0)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player == Host Player;
		Global.GameStarted == False;
		Is On Ground(Event Player) == True;
		Has Spawned(Event Player) == True;
		Is Button Held(Event Player, Button(Reload)) == True;
	}

	actions
	{
		Small Message(All Players(All Teams), Custom String("Creating origin point"));
		Global.CPLocations = Array(Position Of(Event Player));
		Global.CPAbilityCounts = Empty Array;
		Global.CPUltimateTeleportPrimary = Empty Array;
		Global.CPFacingDirections = Empty Array;
		Global.PioneerList = Array(Custom String("{0}", Event Player));
		Global.CurrentPioneer = Event Player;
		Global.GameStarted = True;
		Global.CPHeroList = Array();
		Global.CPGreenSphereArray = Empty Array;
		Global.CPEffectLockSphereArray = Empty Array;
		Global.CPKillSphereArray = Empty Array;
		Global.ReplayPioneerPositionArray = Empty Array;
		Global.ReplayPioneerFacingArray = Empty Array;
		Global.CPPlayerScaleArray = Empty Array;
		Global.EffectLockAbilitiesArray = Empty Array;
		Global.CPSpecialRequirementsArray = Empty Array;
	}
}

rule("Game Started (origin point just created by host) - Create World Effects")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.GameStarted == True;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		"Restart player at origin point after it's created and start timer"
		Call Subroutine(RespawnPlayer);
		Call Subroutine(HandleSkipTimer);
	}
}

rule("Pioneer Create Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Is On Ground(Event Player) == True;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
		Event Player.BlockPioneerNewPoint == False;
		"Can't pioneer in spectate mode"
		Event Player.SpectateMode == False;
		"Punch grace from Hax framework"
		(!Global.PunchGraceEnabled || Is Firing Secondary(Event Player) || Event Player.Grace < 0.120) == True;
		"Winston Leap Bhop Fix"
		(Hero Of(Event Player) != Hero(Winston) || Event Player.WinstonLeapGrace <= 0) == True;
		Event Player.FreeRoamEnabled == False;
	}

	actions
	{
		"Make sure they pioneered far enough"
		If(Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentCP]) < Global.PioneerMinDistanceConstant);
			Small Message(Event Player, Custom String("Pioneer more than {0}m!", Global.PioneerMinDistanceConstant));
			Call Subroutine(RespawnPlayer);
			Abort;
		End;
		Event Player.BlockPioneerPass = True;
		Play Effect(Event Player, Ring Explosion Sound, Color(White), Event Player, 60);
		Event Player.TempVariable2 = Position Of(Event Player);
		Start Forcing Player Position(Event Player, Evaluate Once(Event Player.TempVariable2), True);
		"Allow player 3 sec to cancel the CP"
		Event Player.CancelPointTimer = 3;
		Chase Player Variable At Rate(Event Player, CancelPointTimer, 0, 1, Destination and Rate);
		If(!Global.DisableHUDConstant);
			Create Progress Bar HUD Text(Event Player, Event Player.CancelPointTimer / 0.030, Custom String(
				"Press R within {0} sec to cancel checkpoint", Event Player.CancelPointTimer), Top, 0, Color(White), Color(Red),
				Visible To and Values, Visible Never);
			Event Player.MenuTextIDTempStore = Last Text ID;
		End;
		"Wait for player to cancel point with R, or let the CP complete"
		Wait Until(Is Button Held(Event Player, Button(Reload)), 3);
		If(Event Player.CancelPointTimer > 0);
			Stop Forcing Player Position(Event Player);
			Call Subroutine(RespawnPlayer);
			Destroy Progress Bar HUD Text(Event Player.MenuTextIDTempStore);
			Event Player.BlockPioneerPass = False;
			Abort;
		End;
		Stop Forcing Player Position(Event Player);
		Destroy Progress Bar HUD Text(Event Player.MenuTextIDTempStore);
		"Hopefully tempvariable doesn't conflict with \"Pioneer runs out of time\" rule"
		For Player Variable(Event Player, TempVariable, 0, Count Of(All Living Players(All Teams)), 1);
			If(All Living Players(All Teams)[Event Player.TempVariable].CurrentCP == Count Of(Global.CPLocations) - 1);
				All Living Players(All Teams)[Event Player.TempVariable].ForceRespawn = True;
			End;
		End;
		"Create the next point"
		Event Player.BlockArriveNextPoint = True;
		Modify Global Variable(CPLocations, Append To Array, Event Player.TempVariable2);
		Modify Global Variable(PioneerList, Append To Array, Custom String("{0}", Event Player));
		Modify Global Variable(CPAbilityCounts, Append To Array, Event Player.CPAbilityCounts);
		Modify Global Variable(CPUltimateTeleportPrimary, Append To Array, Event Player.CountUltimateTeleportPrimary);
		Modify Global Variable(CPHeroList, Append To Array, Hero Of(Event Player));
		Modify Global Variable(CPGreenSphereArray, Append To Array, Event Player.GreenSphereLocation);
		Modify Global Variable(CPKillSphereArray, Append To Array, Event Player.KillSphereLocation);
		"Don't allow effect locks on teleport points"
		If(Y Component Of(Event Player.CountUltimateTeleportPrimary) > 0);
			"combine the abilities from the effect locks into the abilites for the CP"
			While(Count Of(Event Player.AbilitiesForEffectLock) > 0);
				Global.CPAbilityCounts[Count Of(Global.CPAbilityCounts) - 1] += First Of(Event Player.AbilitiesForEffectLock);
				Modify Player Variable(Event Player, AbilitiesForEffectLock, Remove From Array By Index, 0);
			End;
			Event Player.EffectLockSphereLocation = Empty Array;
		End;
		Global.CPEffectLockSphereArray[Count Of(Global.CPEffectLockSphereArray)] = Event Player.EffectLockSphereLocation;
		Global.ReplayPioneerPositionArray[Event Player.CurrentCP] = Event Player.ReplayPosition;
		Global.EffectLockAbilitiesArray[Count Of(Global.EffectLockAbilitiesArray)] = Event Player.AbilitiesForEffectLock;
		Global.ReplayPioneerFacingArray[Event Player.CurrentCP] = Event Player.ReplayFacing;
		Event Player.FacingDirectionLeavingCP = Global.CPFacingDirections[Event Player.CurrentCP];
		Modify Global Variable(CPPlayerScaleArray, Append To Array, Event Player.PlayerScale);
		Modify Global Variable(CPSpecialRequirementsArray, Append To Array, Event Player.CPSpecialRequirements);
		Call Subroutine(RespawnPlayer);
		Event Player.BlockArriveNextPoint = False;
		Event Player.TimeSpentOnCP = 0;
		Chase Player Variable At Rate(Event Player, TimeSpentOnCP, 9999, 1, Destination and Rate);
		Global.CurrentPioneer = Null;
		Enable Inspector Recording;
		Log To Inspector(Custom String("Created Checkpoint {0}", Count Of(Global.CPLocations)));
		Disable Inspector Recording;
		Call Subroutine(CreateEffectLocks);
		Event Player.BlockPioneerPass = False;
	}
}

rule("Non-Pioneer Respawn If Touch Ground Outside of current or next CP")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Is On Ground(Event Player) == True;
		Event Player.BlockArriveNextPoint == False;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius;
		Distance Between(Global.CPLocations[Event Player.CurrentCP + 1], Position Of(Event Player)) > Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
		"Punch grace from Hax framework"
		(!Global.PunchGraceEnabled || Is Firing Secondary(Event Player) || Event Player.Grace < 0.120) == True;
		"Winston Leap Bhop Fix"
		(Hero Of(Event Player) != Hero(Winston) || Event Player.WinstonLeapGrace <= 0) == True;
		Is Dummy Bot(Event Player) == False;
		Event Player.FreeRoamEnabled == False;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Non-Pioneer Arrive At CP")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Is On Ground(Event Player) == True;
		Event Player.BlockArriveNextPoint == False;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius;
		Distance Between(Global.CPLocations[Event Player.CurrentCP + 1], Position Of(Event Player)) <= Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
		Count Of(Global.CPLocations) > Event Player.CurrentCP + 1;
		Is Dummy Bot(Event Player) == False;
		Event Player.FreeRoamEnabled == False;
	}

	actions
	{
		"Check if player got effect lock obtained, if they haven't respawn them"
		If(Count Of(Event Player.EffectLockObtained) < Count Of(Global.CPEffectLockSphereArray[Event Player.CurrentCP]));
			Play Effect(Event Player, Debuff Impact Sound, Color(White), Event Player, 60);
			Small Message(Event Player, Custom String("Checkpoint requires you to get the effect lock!"));
			Call Subroutine(RespawnPlayer);
			Abort;
		End;
		"Check if pioneer and player both did Downwards Diagonal Punch"
		If((X Component Of(Global.CPSpecialRequirementsArray[Event Player.CurrentCP]) > 0) != (X Component Of(
			Event Player.CPSpecialRequirements) > 0));
			Play Effect(Event Player, Debuff Impact Sound, Color(White), Event Player, 60);
			Small Message(Event Player, Custom String("Checkpoint requires you to do a Downwards Diagonal Punch!"));
			Call Subroutine(RespawnPlayer);
			Abort;
		End;
		Play Effect(Event Player, Buff Impact Sound, Color(White), Event Player, 60);
		Event Player.CurrentCP += 1;
		Event Player.MaxUnlockedCP = Max(Event Player.MaxUnlockedCP, Event Player.CurrentCP);
		If(Count Of(Global.CPLocations) == Event Player.CurrentCP + 1);
			If(Global.CurrentPioneer == Null);
				"So you can't pioneer your own point unless you are the only player alive (aka not spectating)"
				If(Count Of(Filtered Array(All Players(All Teams), !Is Dummy Bot(Current Array Element))) == 1 || Last Of(Global.PioneerList)
					!= Custom String("{0}", Event Player));
					If(!Global.DisableHUDConstant);
						Big Message(Event Player, Custom String("You are pioneer! Use your skills to make the next checkpoint!"));
					End;
					Global.CurrentPioneer = Event Player;
				End;
			End;
		End;
		Event Player.FacingDirectionLeavingCP = Global.CPFacingDirections[Event Player.CurrentCP];
		Call Subroutine(RespawnPlayer);
		Call Subroutine(HandleSkipTimer);
		Call Subroutine(CreateEffectLocks);
	}
}

rule("If player joins after origin point created, start them at origin point")
{
	event
	{
		Player Joined Match;
		All;
		All;
	}

	conditions
	{
		Global.GameStarted == True;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Wait(0.100, Ignore Condition);
		Loop If(!Has Spawned(Event Player));
		Wait(0.100, Ignore Condition);
		Call Subroutine(HandleSkipTimer);
		Event Player.FacingDirectionLeavingCP = Global.CPFacingDirections[Event Player.CurrentCP];
		Call Subroutine(RespawnPlayer);
		Call Subroutine(CreateEffectLocks);
		Big Message(Event Player, Custom String("Press Interact ({0}) to see game controls", Input Binding String(Button(Interact))));
	}
}

rule("Handle ForceRespawn")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.ForceRespawn == True;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Event Player.BlockPioneerNewPoint = True;
		"Hopefully to avoid the pioneer rule from still being executed while player \"HandleSkipTimer\" subroutine is running"
		Wait(0.200, Ignore Condition);
		Call Subroutine(RespawnPlayer);
		Event Player.FreeRoamEnabled = False;
		Event Player.ForceRespawn = False;
		Event Player.BlockPioneerNewPoint = False;
		Event Player.FacingDirectionLeavingCP = Global.CPFacingDirections[Event Player.CurrentCP];
		Call Subroutine(HandleSkipTimer);
		Call Subroutine(CreateEffectLocks);
	}
}

rule("Start Pioneer Timer and set Invisible when player becomes pioneer")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Global.PioneerTimer = Global.PioneerTimeLimitConstant;
		Chase Global Variable At Rate(PioneerTimer, 0, 1, Destination and Rate);
		Disallow Button(Event Player, Button(Melee));
		If(Hero Of(Event Player) != Hero(Wrecking Ball));
			Set Invisible(Event Player, All);
		End;
	}
}

rule("Set Non-Pioneer Visible")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Allow Button(Event Player, Button(Melee));
		If(Event Player.Invisible);
			Set Invisible(Event Player, All);
		Else;
			Set Invisible(Event Player, None);
		End;
	}
}

rule("Set Pioneer Timer to Zero if there isn't a pioneer")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.CurrentPioneer == Null;
	}

	actions
	{
		Global.PioneerTimer = 0;
	}
}

disabled rule("Other Features / Key Bindings")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Reload - Quick Reset")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Reload)) == True;
		disabled Is On Ground(Event Player) != True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
		"So player can't R and get teleported outside map before origin point is selected"
		Global.GameStarted == True;
		"Quick Reset Disabled for Ana, so you can reload - modify the array here for additional disable"
		disabled Index Of Array Value(Global.PrimaryFireUsefulForTheseHeros, Hero Of(Event Player)) < 0;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Crouch + Interact - Move Back A Checkpoint")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.BlockArriveNextPoint = True;
		If(Global.CurrentPioneer == Event Player);
			Small Message(Event Player, Custom String("Can't move back a level while pioneer! Make a checkpoint!"));
			Abort;
		End;
		If(Event Player.CurrentCP > 0);
			Event Player.CurrentCP += -1;
		Else;
			"If on Checkpoint 0, go to greatest unlocked checkpoint on level"
			Event Player.CurrentCP = Event Player.MaxUnlockedCP;
		End;
		Call Subroutine(HandleSkipTimer);
		Call Subroutine(RespawnPlayer);
		Event Player.BlockArriveNextPoint = False;
		Call Subroutine(CreateEffectLocks);
	}
}

rule("Interact + Left Click: Camera To See Next Point (Left Clicking multiple times cycles through effect lock spheres)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		"Make sure next point exists"
		Count Of(Global.CPLocations) > Event Player.CurrentCP + 1;
		"To not interfere with the temp variable used in Pioneer Create Point rule"
		Event Player.CancelPointTimer <= 0;
		"To not interfere with hero select menu creation"
		Event Player.HeroSelectMenuOpen != True;
	}

	actions
	{
		Create HUD Text(Event Player, Null, Null, Custom String(" \r\n\r\n\r\n\r\n\r\n{0} to view effect locks (hold interact)",
			Input Binding String(Button(Primary Fire))), Top, 9, Color(White), Color(White), Color(White), String, Default Visibility);
		Event Player.MenuTextIDTempStore = Last Text ID;
		Event Player.TempIterator = -1;
		Set Primary Fire Enabled(Event Player, False);
		Set Facing(Event Player, Vector(-10, -10, 0), To World);
		Start Camera(Event Player, Ray Cast Hit Position(
			Event Player.TempIterator == 0 ? Global.CPLocations[Event Player.CurrentCP + 1] : Global.CPEffectLockSphereArray[Event Player.CurrentCP][Event Player.TempIterator - 1],
			(
			Event Player.TempIterator == 0 ? Global.CPLocations[Event Player.CurrentCP + 1] : Global.CPEffectLockSphereArray[Event Player.CurrentCP][Event Player.TempIterator - 1])
			+ Facing Direction Of(Event Player) * -15, All Players(All Teams), Event Player, True),
			Event Player.TempIterator == 0 ? Global.CPLocations[Event Player.CurrentCP + 1] : Global.CPEffectLockSphereArray[Event Player.CurrentCP][Event Player.TempIterator - 1],
			30);
		While(Is Button Held(Event Player, Button(Interact)));
			Wait Until(!Is Button Held(Event Player, Button(Interact)) || Is Button Held(Event Player, Button(Primary Fire)), 20);
			If(Is Button Held(Event Player, Button(Interact)));
				Event Player.TempIterator = (Event Player.TempIterator + 1) % (Count Of(Global.CPEffectLockSphereArray[Event Player.CurrentCP])
					+ 1);
				Wait Until(!Is Button Held(Event Player, Button(Primary Fire)), 20);
			End;
			Wait(0.050, Ignore Condition);
		End;
		Destroy HUD Text(Event Player.MenuTextIDTempStore);
		Stop Camera(Event Player);
		Set Primary Fire Enabled(Event Player, True);
		Set Facing(Event Player, Global.CPFacingDirections[Event Player.CurrentCP], To World);
	}
}

rule("Interact + Jump -> Skip Checkpoint")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		If(Global.CurrentPioneer == Event Player);
			Small Message(Event Player, Custom String("Can't change level while pioneer! Make a checkpoint!"));
			Abort;
		End;
		"If player is not on last unlocked CP"
		If(Event Player.CurrentCP < Event Player.MaxUnlockedCP);
			Event Player.CurrentCP += 1;
		Else;
			If((Global.DevModeEngaged || Event Player.TimeSpentOnCP > Global.SkipTimeLimit) && Event Player.CurrentCP + 1 < Count Of(
				Global.CPLocations));
				Event Player.CurrentCP += 1;
				Event Player.MaxUnlockedCP = Event Player.CurrentCP;
				Event Player.BlockArriveNextPoint = True;
				Call Subroutine(RespawnPlayer);
				"Allow player to pioneer using CP skip"
				If(Count Of(Global.CPLocations) == Event Player.CurrentCP + 1);
					If(Global.CurrentPioneer == Null);
						Big Message(Event Player, Custom String("You are pioneer! Use your skills to make the next checkpoint!"));
						Global.CurrentPioneer = Event Player;
					End;
				End;
				Event Player.BlockArriveNextPoint = False;
				Call Subroutine(HandleSkipTimer);
				Call Subroutine(CreateEffectLocks);
				Abort;
			Else;
				"If haven't unlocked next CP yet, go back to CP 0"
				Event Player.CurrentCP = 0;
			End;
		End;
		Call Subroutine(HandleSkipTimer);
		Call Subroutine(RespawnPlayer);
		Call Subroutine(CreateEffectLocks);
	}
}

rule("Interact + Melee : Spectate Other Players (Also Ult + Ability1 + Ability 2 like Hax Framework)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		((Is Button Held(Event Player, Button(Melee)) && Is Button Held(Event Player, Button(Interact))) || (Is Button Held(Event Player,
			Button(Ultimate)) && Is Button Held(Event Player, Button(Ability 1)) && Is Button Held(Event Player, Button(Ability 2))))
			== True;
	}

	actions
	{
		Enable Death Spectate All Players(All Players(All Teams));
		If(Is Dead(Event Player));
			Enable Built-In Game Mode Respawning(Event Player);
			Resurrect(Event Player);
			Wait(0.100, Ignore Condition);
			If(Global.GameStarted);
				Call Subroutine(RespawnPlayer);
				Call Subroutine(CreateEffectLocks);
			Else;
				Teleport(Event Player, First Of(Spawn Points(Team Of(Event Player))));
			End;
			Event Player.SpectateMode = False;
		Else;
			Big Message(Event Player, Custom String("Use \"Interact + Melee\" to exit Spectate Mode!"));
			Event Player.SpectateMode = True;
			Disable Built-In Game Mode Respawning(Event Player);
			Kill(Event Player, Null);
		End;
		Set Status(Event Player, Null, Phased Out, 9999);
	}
}

rule("Melee + Left Click = Teleport")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Is Button Held(Event Player, Button(Melee)) == True;
		(Event Player.TeleportEnabled || Global.DevModeEngaged || Event Player.FreeRoamEnabled) == True;
	}

	actions
	{
		Teleport(Event Player, Ray Cast Hit Position(Position Of(Event Player), Position Of(Event Player) + Facing Direction Of(
			Event Player) * 60, All Players(All Teams), Event Player, True));
		Event Player.CountUltimateTeleportPrimary += Up;
	}
}

rule("Interact + Hello Voiceline = Dev Mode Engaged")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player == Host Player;
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Communicating(Event Player, Hello) == True;
	}

	actions
	{
		"Right now Dev Mode lets all players teleport and skip any points with zero time using jump + interact"
		disabled Wait(0.250, Ignore Condition);
		If(Global.DevModeEngaged);
			Small Message(All Players(All Teams), Custom String("Dev Mode Disengaged"));
			Global.DevModeEngaged = False;
		Else;
			Small Message(All Players(All Teams), Custom String("Dev Mode Engaged"));
			Global.DevModeEngaged = True;
		End;
	}
}

rule("Crouch + Jump: Toggle Invisiblity")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) == True;
		Is Button Held(Event Player, Button(Crouch)) == True;
		Global.CurrentPioneer != Event Player;
	}

	actions
	{
		If(Event Player.Invisible);
			Set Invisible(Event Player, None);
			Small Message(Event Player, Custom String("Visible"));
		Else;
			Small Message(Event Player, Custom String("Invisible"));
			Set Invisible(Event Player, All);
		End;
		Event Player.Invisible = !Event Player.Invisible;
	}
}

rule("Interact + Ultimate Status Voiceline = Pioneer can switch hero")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		disabled Is Button Held(Event Player, Button(Jump)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
		"Is pioneer or is waiting for pioneer"
		(Global.CurrentPioneer == Event Player || Count Of(Global.CPLocations) == Event Player.CurrentCP + 1) == True;
		Global.MultiHeroEnabled == True;
		Is Communicating(Event Player, Ultimate Status) == True;
	}

	actions
	{
		"If a menu is already open, delete the in world text and recreate the menu in the proper location"
		If(Event Player.HeroSelectMenuOpen);
			For Player Variable(Event Player, TempIterator, 0, Count Of(Event Player.MenuTextIDTempStore), 1);
				Destroy In-World Text(Event Player.MenuTextIDTempStore[Event Player.TempIterator]);
				Abort;
			End;
		End;
		Event Player.MenuInWorldLocationTempStore = Empty Array;
		Event Player.MenuTextIDTempStore = Empty Array;
		For Player Variable(Event Player, TempIterator, 0, Count Of(Global.HeroRoster), 1);
			Modify Player Variable(Event Player, MenuInWorldLocationTempStore, Append To Array, Eye Position(Event Player)
				+ Facing Direction Of(Event Player) * 1 + 0.400 * World Vector Of(Vector(Sine From Degrees(360 * (
				Event Player.TempIterator / Count Of(Global.HeroRoster))), Cosine From Degrees(360 * (Event Player.TempIterator / Count Of(
				Global.HeroRoster))), 0), Event Player, Rotation));
			Create In-World Text(Event Player, Custom String("{0}", Hero Icon String(Global.HeroRoster[Event Player.TempIterator])),
				Event Player.MenuInWorldLocationTempStore[Event Player.TempIterator] + Vector(0, -0.100, 0), 3, Do Not Clip, None, Color(
				White), Default Visibility);
			Modify Player Variable(Event Player, MenuTextIDTempStore, Append To Array, Last Text ID);
			Wait(0.016, Ignore Condition);
		End;
		Event Player.HeroSelectMenuOpen = True;
		Big Message(Event Player, Custom String("Release Interact Over The Hero You Want To Select"));
	}
}

rule("Close Hero Select Menu When Player Stops Holding Interact")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == False;
		Has Spawned(Event Player) == True;
		Event Player.HeroSelectMenuOpen == True;
	}

	actions
	{
		Start Forcing Player To Be Hero(Event Player, Global.HeroRoster[Index Of Array Value(Event Player.MenuInWorldLocationTempStore,
			First Of(Sorted Array(Event Player.MenuInWorldLocationTempStore, Angle Between Vectors(Facing Direction Of(Event Player),
			Direction Towards(Eye Position(Event Player), Current Array Element)))))]);
		For Player Variable(Event Player, TempIterator, 0, Count Of(Event Player.MenuTextIDTempStore), 1);
			Destroy In-World Text(Event Player.MenuTextIDTempStore[Event Player.TempIterator]);
		End;
		If(Hero Of(Event Player) == Hero(Wrecking Ball));
			Set Invisible(Event Player, None);
		End;
		Event Player.HeroSelectMenuOpen = False;
	}
}

rule("Interact + Up/Down to increase/decrease pioneer player size")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Player is pioneer or waiting for pioneer"
		Event Player.CurrentCP + 1 == Count Of(Global.CPLocations);
		Is Button Held(Event Player, Button(Interact)) == True;
		Absolute Value(Z Component Of(Throttle Of(Event Player))) == 1;
		Global.GameStarted == True;
		"Technically abusable, making large radius to avoid issues with 5x scale not allowing players to get smaller because they can't stay close enough to the CP start"
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) < 8;
		disabled Is On Ground(Event Player) == True;
	}

	actions
	{
		"Cycle through allowed player scales"
		Event Player.PlayerScale = Global.AllowedPlayerScalesArray[(Index Of Array Value(Global.AllowedPlayerScalesArray,
			Event Player.PlayerScale) + Z Component Of(Throttle Of(Event Player))) % Count Of(Global.AllowedPlayerScalesArray)];
		Call Subroutine(UpdatePlayerScale);
		Wait(0.100, Ignore Condition);
		Small Message(Event Player, Custom String("Setting player scale to {0}", Event Player.PlayerScale));
	}
}

rule("Melee + Emote + Dev Mode Engaged: Delete Last Checkpoint")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player == Host Player;
		Global.DevModeEngaged == True;
		Is Button Held(Event Player, Button(Melee)) == True;
		Is Communicating Any Emote(Event Player) == True;
		"Cant delete the origin point"
		Count Of(Global.CPLocations) > 1;
	}

	actions
	{
		Small Message(All Players(All Teams), Custom String("Deleting last checkpoint"));
		"Hopefully tempvariable doesn't conflict with \"Pioneer runs out of time\" rule"
		For Player Variable(Event Player, TempVariable, 0, Count Of(All Living Players(All Teams)), 1);
			If(All Living Players(All Teams)[Event Player.TempVariable].CurrentCP == Count Of(Global.CPLocations) - 1);
				All Living Players(All Teams)[Event Player.TempVariable].CurrentCP = Count Of(Global.CPLocations) - 2;
				All Living Players(All Teams)[Event Player.TempVariable].ForceRespawn = True;
			End;
		End;
		Wait(0.250, Ignore Condition);
		Global.PioneerTimer = Global.PioneerTimeLimitConstant;
		Global.CurrentPioneer = First Of(Filtered Array(All Players(All Teams), Custom String("{0}", Current Array Element) == Last Of(
			Global.PioneerList)));
		Modify Global Variable(CPLocations, Remove From Array By Index, Count Of(Global.CPLocations) - 1);
		Modify Global Variable(PioneerList, Remove From Array By Index, Count Of(Global.PioneerList) - 1);
		Modify Global Variable(CPAbilityCounts, Remove From Array By Index, Count Of(Global.CPAbilityCounts) - 1);
		Modify Global Variable(CPUltimateTeleportPrimary, Remove From Array By Index, Count Of(Global.CPUltimateTeleportPrimary) - 1);
		Modify Global Variable(CPHeroList, Remove From Array By Index, Count Of(Global.CPHeroList) - 1);
		Modify Global Variable(CPGreenSphereArray, Remove From Array By Index, Count Of(Global.CPGreenSphereArray) - 1);
		Modify Global Variable(CPKillSphereArray, Remove From Array By Index, Count Of(Global.CPKillSphereArray) - 1);
		Modify Global Variable(CPEffectLockSphereArray, Remove From Array By Index, Count Of(Global.CPEffectLockSphereArray) - 1);
		Modify Global Variable(ReplayPioneerPositionArray, Remove From Array By Index, Count Of(Global.ReplayPioneerPositionArray) - 1);
		Modify Global Variable(EffectLockAbilitiesArray, Remove From Array By Index, Count Of(Global.EffectLockAbilitiesArray) - 1);
		Modify Global Variable(ReplayPioneerFacingArray, Remove From Array By Index, Count Of(Global.ReplayPioneerFacingArray) - 1);
		Modify Global Variable(CPFacingDirections, Remove From Array By Index, Count Of(Global.CPFacingDirections) - 1);
		Modify Global Variable(CPPlayerScaleArray, Remove From Array By Index, Count Of(Global.CPPlayerScaleArray) - 1);
		Modify Global Variable(CPSpecialRequirementsArray, Remove From Array By Index, Count Of(Global.CPSpecialRequirementsArray) - 1);
		"Hopefully tempvariable doesn't conflict with \"Pioneer runs out of time\" rule"
		For Player Variable(Event Player, TempVariable, 0, Count Of(All Living Players(All Teams)), 1);
			If(All Living Players(All Teams)[Event Player.TempVariable].CurrentCP == Count Of(Global.CPLocations) - 1);
				All Living Players(All Teams)[Event Player.TempVariable].ForceRespawn = True;
			End;
		End;
		"Hopefully tempvariable doesn't conflict with \"Pioneer runs out of time\" rule"
		For Player Variable(Event Player, TempVariable, 0, Count Of(All Players(All Teams)), 1);
			If(All Players(All Teams)[Event Player.TempVariable].CurrentCP == Count Of(Global.CPLocations) - 1);
				All Players(All Teams)[Event Player.TempVariable].MaxUnlockedCP = Count Of(Global.CPLocations) - 1;
			End;
		End;
		Event Player.TimeSpentOnCP = 0;
		Call Subroutine(CreateEffectLocks);
		Call Subroutine(HandleSkipTimer);
		Call Subroutine(CheckAbilityCounts);
		Enable Inspector Recording;
		Log To Inspector(Custom String("Removed Checkpoint {0}", Count Of(Global.CPLocations) + 1));
		Disable Inspector Recording;
	}
}

rule("Ult + Crouch + Ult Status = Free Roam")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ultimate)) == True;
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Communicating(Event Player, Ultimate Status) == True;
	}

	actions
	{
		"Respawn player when exiting free roam, otherwise player could free roam to the next CP and then turn off free roam!"
		If(Event Player.FreeRoamEnabled == True);
			Call Subroutine(RespawnPlayer);
		Else;
			Set Ability 1 Enabled(Event Player, True);
			Set Ability 2 Enabled(Event Player, True);
			Set Secondary Fire Enabled(Event Player, True);
		End;
		Event Player.FreeRoamEnabled = !Event Player.FreeRoamEnabled;
		Wait(0.100, Ignore Condition);
		Small Message(Event Player, Event Player.FreeRoamEnabled ? Custom String("Free Roam Enabled") : Custom String(
			"Free Roam Disabled"));
	}
}

rule("Interact + Ultimate: Bounce Timer Toggle")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		((Is Button Held(Event Player, Button(Interact)) && Is Button Held(Event Player, Button(Ultimate))) || Global.DisableHUDConstant)
			== True;
	}

	actions
	{
		Event Player.BounceTimerEnabled = !Event Player.BounceTimerEnabled;
		If(Event Player.BounceTimerEnabled);
			Chase Player Variable At Rate(Event Player, ThreeSecondBounceTimer, (Speed Of(Event Player) > 0.070 && !Is Using Ultimate(
				Event Player)) || Is On Ground(Event Player) ? 0 : 4, (Speed Of(Event Player) > 0.070 && !Is Using Ultimate(Event Player))
				|| Is On Ground(Event Player) ? 9999 : 1, Destination and Rate);
		Else;
			Stop Chasing Player Variable(Event Player, ThreeSecondBounceTimer);
			Event Player.ThreeSecondBounceTimer = 0;
		End;
		Wait(0.100, Ignore Condition);
		Small Message(Event Player, Custom String("Bounce timer and bhop reset detector {0}",
			Event Player.BounceTimerEnabled ? Custom String("Enabled") : Custom String("Disabled")));
	}
}

disabled rule("Replay Saving / Watching Code")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Pioneer Save Replay")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		"Has left starting CP or is using an ability"
		(Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius || Is Firing Secondary(
			Event Player) || Is Using Ability 1(Event Player) || Is Using Ability 2(Event Player) || Is Using Ultimate(Event Player)
			|| Event Player.ThreeSecondBounceTimer > 1) == True;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
		Event Player.CancelPointTimer == 0;
		Global.ReplaysEnabledConstant == True;
		Event Player.FreeRoamEnabled == False;
	}

	actions
	{
		Modify Player Variable(Event Player, ReplayPosition, Append To Array, Eye Position(Event Player));
		Modify Player Variable(Event Player, ReplayFacing, Append To Array, Facing Direction Of(Event Player));
		Wait(Speed Of(Event Player) <= 2.750 ? 0.480 : 0.160, Ignore Condition);
		Loop If Condition Is True;
		Modify Player Variable(Event Player, ReplayPosition, Append To Array, Eye Position(Event Player));
		Modify Player Variable(Event Player, ReplayFacing, Append To Array, Facing Direction Of(Event Player));
	}
}

rule("Need Healing/Help: View Replay")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Is Communicating(Event Player, Need Healing) || Is Communicating(Event Player, Need Help)) == True;
		Global.CurrentPioneer != Event Player;
		"Prevent conflict with Host deleting last CP"
		!(Global.DevModeEngaged && Event Player == Host Player && Is Communicating Any Emote(Event Player)) == True;
	}

	actions
	{
		If(!Global.ReplaysEnabledConstant);
			Small Message(Event Player, Custom String("Replays Disabled (Host Can Turn It On In Workshop Settings)"));
			Abort;
		End;
		If(Global.ReplayPioneerPositionArray[Event Player.CurrentCP] == Null);
			Small Message(Event Player, Custom String(
				"Pioneer replay not saved for this CP (saving CP's in workshop rules can exceed workshop size limit)"));
			Abort;
		End;
		Start Camera(Event Player, Global.ReplayPioneerPositionArray[Event Player.CurrentCP][Event Player.TempIterator],
			Global.ReplayPioneerPositionArray[Event Player.CurrentCP][Event Player.TempIterator] + Global.ReplayPioneerFacingArray[Event Player.CurrentCP][Event Player.TempIterator],
			30);
		Create Progress Bar HUD Text(Event Player, 100 * ((Event Player.TempIterator + 1) / Count Of(
			Global.ReplayPioneerPositionArray[Event Player.CurrentCP])), Custom String(
			"{0} to cancel replay, {1} to pause\r\nRight / Left to Fast Forward / Back", Input Binding String(Button(Reload)),
			Input Binding String(Button(Jump))), Top, 5, Color(White), Color(White), Values, Default Visibility);
		"This can POTENTIALLY conflict with the pioneering of a point location variable"
		Event Player.TempVariable2 = Last Text ID;
		Start Forcing Player Position(Event Player, Position Of(Event Player), False);
		"Using this variable to store whether replay is paused or not"
		Event Player.TempVariable = False;
		Event Player.TempIterator = 0;
		While(Event Player.TempIterator < Count Of(Global.ReplayPioneerPositionArray[Event Player.CurrentCP]));
			Wait(0.100, Ignore Condition);
			If(Is Button Held(Event Player, Button(Reload)));
				Break;
			End;
			If(Is Button Held(Event Player, Button(Jump)));
				"Switch variable from paused to unpaused or vice versa"
				Event Player.TempVariable = !Event Player.TempVariable;
			End;
			"Update replay frame index based on player pressing left or right. Clip the index to make sure player can't go to negative index, or past end of replay."
			Event Player.TempIterator = Min(Count Of(Global.ReplayPioneerPositionArray[Event Player.CurrentCP]) - 1, Max(0,
				Event Player.TempIterator - 3 * X Component Of(Throttle Of(Event Player))));
			If(!Event Player.TempVariable && Absolute Value(X Component Of(Throttle Of(Event Player))) == 0);
				Event Player.TempIterator += 1;
			End;
		End;
		"Pause a little at end of replay to show final destination"
		If(Event Player.TempIterator >= Count Of(Global.ReplayPioneerPositionArray[Event Player.CurrentCP]));
			Wait(0.500, Ignore Condition);
		End;
		Stop Camera(Event Player);
		Destroy Progress Bar HUD Text(Event Player.TempVariable2);
		Stop Forcing Player Position(Event Player);
	}
}

disabled rule("Handle Ability Counts")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Handle Ability Count Limits (if enabled)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.AbilityCountsEnabledConstant == True;
		(Is Using Ability 1(Event Player) || Is Using Ability 2(Event Player) || Is Firing Secondary(Event Player)) == True;
		"Doesn't trigger if player is pioneer or waiting for pioneer"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations);
		Global.GameStarted == True;
		Event Player.FreeRoamEnabled == False;
	}

	actions
	{
		Wait(0.032, Ignore Condition);
		Loop If Condition Is True;
		Call Subroutine(CheckAbilityCounts);
	}
}

rule("Used Primary Fire (If Ana)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ana;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
		"Don't trigger if player has complete point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.CountUltimateTeleportPrimary += Forward;
	}
}

rule("Used Ultimate")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		"Don't trigger if player has complete point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.CountUltimateTeleportPrimary += Left;
	}
}

rule("Used Secondary (Rocket Punch)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
		"Don't trigger if player has complete point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.Grace = 0.119;
		If(Event Player.EffectLockSphereLocation == Empty Array);
			Event Player.CPAbilityCounts += Left;
		Else;
			Event Player.AbilitiesForEffectLock[Count Of(Event Player.AbilitiesForEffectLock) - 1] += Left;
		End;
	}
}

rule("Used Ability 1 (Uppercut)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
		"Don't trigger if player has complete point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		If(Event Player.EffectLockSphereLocation == Empty Array);
			Event Player.CPAbilityCounts += Up;
		Else;
			Event Player.AbilitiesForEffectLock[Count Of(Event Player.AbilitiesForEffectLock) - 1] += Up;
		End;
	}
}

rule("Used Ability 2 - NON DOOMFIST")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		Event Player.CancelPointTimer == 0;
		Hero Of(Event Player) != Hero(Doomfist);
	}

	actions
	{
		If(Event Player.EffectLockSphereLocation == Empty Array);
			Event Player.CPAbilityCounts += Forward;
		Else;
			Event Player.AbilitiesForEffectLock[Count Of(Event Player.AbilitiesForEffectLock) - 1] += Forward;
		End;
	}
}

rule("Used Ability 2 - Start Slam Timer")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		"Don't trigger if player has complete point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.SlamTimer = 0;
		Chase Player Variable At Rate(Event Player, SlamTimer, 99, 1, Destination and Rate);
	}
}

rule("Used Ability 2 + 125 Slam Detector")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == False;
		Has Spawned(Event Player) == True;
		"To stop this rule from double triggering"
		Event Player.SlamTimer > 0;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, SlamTimer);
		Event Player.SlamTimer = 0;
	}
}

rule("Increment Slam Counter")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		"Prevents invalid slam (where player presses slam button but can't slam) from being counted"
		((Is On Ground(Event Player) && Event Player.SlamTimer > 0.040 && Event Player.SlamTimer < 0.250) || (
			Event Player.SlamTimer > 0.250) || (Global.CurrentPioneer == Event Player && True)) == True;
		Has Spawned(Event Player) == True;
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		If(Event Player.EffectLockSphereLocation == Empty Array);
			Event Player.CPAbilityCounts += Forward;
		Else;
			Event Player.AbilitiesForEffectLock[Count Of(Event Player.AbilitiesForEffectLock) - 1] += Forward;
		End;
		If(Is On Ground(Event Player));
			Stop Chasing Player Variable(Event Player, SlamTimer);
			Event Player.SlamTimer = 0;
		End;
	}
}

disabled rule("125 Slam Detection")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		"Actual time is 1.53 for 125 slam + cancel, but removing cancel ~.3 sec"
		Event Player.SlamTimer >= 1.220;
		Is Using Ability 2(Event Player) == True;
		"To prevent player from just holding down slam at invalid slam angle to get a 125 slam"
		Is Button Held(Event Player, Button(Ability 2)) == False;
	}

	actions
	{
		Event Player.Count360Slam125 += Up;
		disabled Small Message(Event Player, Custom String("125 Slam"));
		disabled Play Effect(Event Player, Buff Impact Sound, Color(White), Event Player, 60);
	}
}

rule("Downward Diag Detector")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Global.DownwardsDiagEnabledConstant == True;
		Vertical Speed Of(Event Player) < -10;
		"Can only get this speed by punching."
		Horizontal Speed Of(Event Player) > 40;
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		"Stops this rule from triggering on downward diag from doorframe - adjusting to be slightly larger for higher doorways on blizzard world..."
		Wait(0.100, Abort When False);
		Event Player.CPSpecialRequirements += Vector(1, 0, 0);
		Small Message(Event Player, Custom String("Downward Diagonal Punch"));
	}
}

rule("BHop Reset Detector - Tons of fixes from the original, only fail case should be on roofs that are off the map")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
		"From sh3lol (DWBWK) bhop reset altitude"
		Altitude Of(Event Player) <= 0.042;
		!(Is Button Held(Event Player, Button(Secondary Fire)) && Is Button Held(Event Player, Button(Jump))) == True;
		Event Player.BounceTimerEnabled == True;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius + 0.300;
		"To stop this rule from triggering when sliding on a roof. This nearest walkable position might not work if the player is off map."
		(Distance Between(Position Of(Event Player), Nearest Walkable Position(Position Of(Event Player))) < 1 || Distance Between(
			Global.CPLocations[Event Player.CurrentCP], Nearest Walkable Position(Global.CPLocations[Event Player.CurrentCP])) > 10)
			== True;
		Is On Ground(Event Player) != True;
		"Is pioneer or is not waiting for pioneer"
		(Event Player == Global.CurrentPioneer || Event Player.CurrentCP < Count Of(Global.CPLocations) - 1) == True;
	}

	actions
	{
		"To prevent conflict with create point rule - shouldn't be needed if you're copying this rule"
		Wait(0.050, Ignore Condition);
		"Don't show bhop reset message if you made the next CP while uppercut'ing"
		Abort If(Event Player.CancelPointTimer > 0);
		Small Message(Event Player, Custom String("Bhop Reset"));
	}
}

disabled rule("Other Stuff")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Reset Cooldowns If In Starting CP Ring")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) < Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
		(Ability Cooldown(Event Player, Button(Secondary Fire)) > 0 || Ability Cooldown(Event Player, Button(Ability 1))
			> 0 || Ability Cooldown(Event Player, Button(Ability 2)) > 0) == True;
		(Is Using Ability 1(Event Player) || Is Using Ability 2(Event Player) || Is Firing Secondary(Event Player)) == False;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		"For wrecking ball"
		Set Ability Cooldown(Event Player, Button(Jump), 0);
	}
}

rule("Declare Winner If Not Infinite Mode")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.InfiniteModeEnabledConstant == False;
		Count Of(Global.CPLocations) > 30;
	}

	actions
	{
		Wait(1, Ignore Condition);
		Declare Player Victory(Global.CurrentPioneer);
		Declare Team Victory(Team 1);
	}
}

rule("Handle Player Death")
{
	event
	{
		Player Died;
		All;
		All;
	}

	conditions
	{
		Event Player.SpectateMode != True;
	}

	actions
	{
		Event Player.BlockPioneerNewPoint = True;
		"In case you die during 3 seconds after pioneering"
		If(Event Player.CancelPointTimer > 0);
			Wait(3, Ignore Condition);
		End;
		Respawn(Event Player);
		Wait(0.100, Ignore Condition);
		If(Global.GameStarted);
			Call Subroutine(RespawnPlayer);
			Wait(0.100, Ignore Condition);
		End;
		Clear Status(Event Player, Phased Out);
		Set Status(Event Player, Null, Phased Out, 9999);
		Event Player.BlockPioneerNewPoint = False;
	}
}

rule("Save CP Facing Direction when leaving the CP (for both pioneer and non-pioneer)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		disabled Global.CurrentPioneer == Event Player;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		If(Global.CurrentPioneer == Event Player);
			Global.CPFacingDirections[Event Player.CurrentCP] = Facing Direction Of(Event Player);
		End;
		Event Player.FacingDirectionLeavingCP = Facing Direction Of(Event Player);
	}
}

rule("Pioneer runs out of time")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.PioneerTimer == 0;
		Has Spawned(Event Player) == True;
		Global.CurrentPioneer == Event Player;
		Event Player.BlockPioneerPass == False;
	}

	actions
	{
		Wait(0.100, Abort When False);
		Event Player.BlockPioneerNewPoint = True;
		Wait(0.100, Ignore Condition);
		"Is there a player on final checkpoint waiting for pioneer"
		If(Count Of(Filtered Array(All Players(All Teams), Global.CurrentPioneer != Current Array Element && Count Of(Global.CPLocations)
			== Current Array Element.CurrentCP + 1)) > 0);
			Event Player.TempVariable = Random Value In Array(Filtered Array(All Players(All Teams),
				Global.CurrentPioneer != Current Array Element && Count Of(Global.CPLocations) == Current Array Element.CurrentCP + 1));
			Global.PioneerTimer = Global.PioneerTimeLimitConstant;
			Event Player.TempVariable.BlockPioneerNewPoint = True;
			Event Player.TempVariable.ForceRespawn = True;
			"Hopefully to avoid the pioneer rule from still being executed while player \"HandleSkipTimer\" subroutine is running"
			Wait(0.200, Ignore Condition);
			Global.CurrentPioneer = Event Player.TempVariable;
			Wait(0.100, Ignore Condition);
			Event Player.TempVariable.BlockPioneerNewPoint = False;
			Big Message(All Players(All Teams), Custom String("Pioneer ran out of time. Pioneer passed to {0}", Global.CurrentPioneer));
		Else;
			Global.PioneerTimer = Global.PioneerTimeLimitConstant;
			Big Message(All Players(All Teams), Custom String("No one to pass pioneer to"));
		End;
		Event Player.BlockPioneerNewPoint = False;
	}
}

rule("Pioneer Left Match")
{
	event
	{
		Player Left Match;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Null;
	}

	actions
	{
		Event Player.BlockPioneerNewPoint = True;
		"Pioneer is not in game"
		If(Count Of(Filtered Array(All Players(All Teams), Current Array Element == Global.CurrentPioneer)) == 0);
			"Is there a player on final checkpoint waiting for pioneer"
			If(Count Of(Filtered Array(All Players(All Teams), True && Count Of(Global.CPLocations) == Current Array Element.CurrentCP + 1))
				> 0);
				Event Player.TempVariable = Random Value In Array(Filtered Array(All Players(All Teams), Count Of(Global.CPLocations)
					== Current Array Element.CurrentCP + 1));
				Global.PioneerTimer = Global.PioneerTimeLimitConstant;
				Event Player.TempVariable.ForceRespawn = True;
				Global.CurrentPioneer = Event Player.TempVariable;
				Wait(0.100, Ignore Condition);
				Big Message(All Players(All Teams), Custom String("Pioneer ran out of time. Pioneer passed to {0}", Global.CurrentPioneer));
			End;
		End;
		Event Player.BlockPioneerNewPoint = False;
	}
}

rule("Handle Memory Recall")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"To make sure this rule executes after global initialize"
		Wait(0.500, Ignore Condition);
		Call Subroutine(MemoryRecall);
		"If something in memory"
		If(Count Of(Global.CPLocations) > 0);
			Global.GameStarted = True;
			Global.UsingMemoryRecall = True;
			"In case dev mode was on when vars were saved"
			Global.DevModeEngaged = False;
			"If pioneer replays were deleted (most likely to be true), initialize replays to be arrays of NULL"
			If(Count Of(Global.CPLocations) != Count Of(Global.ReplayPioneerPositionArray) || Count Of(Global.CPLocations) != Count Of(
				Global.ReplayPioneerFacingArray));
				"I think this should initialize whole array to NULL"
				Global.ReplayPioneerPositionArray[Count Of(Global.CPLocations) - 1] = Null;
				"I think this should initialize whole array to NULL"
				Global.ReplayPioneerFacingArray[Count Of(Global.CPLocations) - 1] = Null;
			End;
			Enable Inspector Recording;
			Log To Inspector(Custom String("Memory Recall Initialize Snapshot"));
			Disable Inspector Recording;
		Else;
			Global.UsingMemoryRecall = False;
		End;
	}
}

disabled rule("Subroutines")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Sub0: RespawnPlayer")
{
	event
	{
		Subroutine;
		RespawnPlayer;
	}

	actions
	{
		Stop Holding Button(Event Player, Button(Secondary Fire));
		Event Player.CPAbilityCounts = Vector(0, 0, 0);
		Event Player.CountUltimateTeleportPrimary = Vector(0, 0, 0);
		Event Player.CPSpecialRequirements = Vector(0, 0, 0);
		Event Player.EffectLockSphereLocation = Empty Array;
		Teleport(Event Player, Global.CPLocations[Event Player.CurrentCP]);
		If(Is Button Held(Event Player, Button(Interact)));
			Event Player.FacingDirectionLeavingCP = Global.CPFacingDirections[Event Player.CurrentCP];
		End;
		Set Facing(Event Player, Event Player.FacingDirectionLeavingCP, To World);
		"If player is not pioneer and is not waiting for pioneer"
		If(Count Of(Global.CPLocations) > Event Player.CurrentCP + 1);
			Start Forcing Player To Be Hero(Event Player, Global.CPHeroList[Event Player.CurrentCP]);
		End;
		"Sigma Barrier Reset"
		If(Hero Of(Event Player) == Hero(Sigma));
			If(Event Player.sigma_barrier_ready_to_destroy);
				Press Button(Event Player, Button(Secondary Fire));
			End;
			Event Player.sigma_barrier_ON = False;
			Event Player.sigma_barrier_ready_to_destroy = False;
		End;
		Event Player.PunchFixStore = Hero Of(Event Player) == Hero(Doomfist) && Is Button Held(Event Player, Button(Secondary Fire));
		Cancel Primary Action(Event Player);
		Call Subroutine(CancelMomentum);
		"Added this to fix issue where if you pressed R while using slam, the slam cooldown wasn't reset"
		Wait(0.100, Ignore Condition);
		Stop Chasing Player Variable(Event Player, SlamTimer);
		Event Player.SlamTimer = 0;
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Set Ultimate Charge(Event Player, 100);
		Event Player.CancelPointTimer = 0;
		"If player is not pioneer, player is not waiting for pioneer"
		If(Count Of(Global.CPLocations) > Event Player.CurrentCP + 1);
			If(X Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]) == 0);
				Set Secondary Fire Enabled(Event Player, False);
			Else;
				Set Secondary Fire Enabled(Event Player, True);
			End;
			If(Hero Of(Event Player) == Hero(Ana));
				Set Secondary Fire Enabled(Event Player, True);
			End;
			If(Y Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]) == 0);
				Set Ability 1 Enabled(Event Player, False);
			Else;
				Set Ability 1 Enabled(Event Player, True);
			End;
			If(Z Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]) == 0);
				Set Ability 2 Enabled(Event Player, False);
			Else;
				Set Ability 2 Enabled(Event Player, True);
			End;
			If(X Component Of(Global.CPUltimateTeleportPrimary[Event Player.CurrentCP]) == 0);
				Set Ultimate Ability Enabled(Event Player, False);
			Else;
				Set Ultimate Ability Enabled(Event Player, True);
			End;
			If(Y Component Of(Global.CPUltimateTeleportPrimary[Event Player.CurrentCP]) == 0);
				Event Player.TeleportEnabled = False;
			Else;
				Event Player.TeleportEnabled = True;
				If(Event Player.CurrentCP > 0);
					Big Message(Event Player, Custom String("Teleport enabled for this point! Use Left Click + Melee to teleport!"));
				End;
			End;
			If(Index Of Array Value(Global.PrimaryFireUsefulForTheseHeros, Hero Of(Event Player)) >= 0);
				If(Z Component Of(Global.CPUltimateTeleportPrimary[Event Player.CurrentCP]) == 0);
					Set Primary Fire Enabled(Event Player, False);
				Else;
					Set Primary Fire Enabled(Event Player, True);
				End;
			End;
			Event Player.PlayerScale = Global.CPPlayerScaleArray[Event Player.CurrentCP];
			Call Subroutine(UpdatePlayerScale);
		"Is beginning of match, or player is pioneer, or player is waiting for pioneer"
		Else;
			Set Secondary Fire Enabled(Event Player, True);
			Set Ability 1 Enabled(Event Player, True);
			Set Ability 2 Enabled(Event Player, True);
			Event Player.TeleportEnabled = True;
			Set Primary Fire Enabled(Event Player, True);
			Set Ultimate Ability Enabled(Event Player, Global.UltimateAbilitiesEnabledConstant);
		End;
		Event Player.WinstonBouncyBubbleCooldown = 0;
		Destroy Effect(Event Player.WinstonBubbleEffect);
		Event Player.WinstonBubbleLocation = Null;
		"Should Fix Phased Out Status issue"
		Clear Status(Event Player, Phased Out);
		"Don't phase out bastion, so you can Bastion Ult parkour"
		If(!Array Contains(Array(Hero(Bastion)), Hero Of(Event Player)));
			Set Status(Event Player, Null, Phased Out, 9999);
		Else;
			Set Ultimate Ability Enabled(Event Player, True);
		End;
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Set Ability Cooldown(Event Player, Button(Crouch), 0);
		Set Move Speed(Event Player, Global.PlayerMoveSpeedConstant);
		If(Event Player.PunchFixStore && Hero Of(Event Player) == Hero(Doomfist) && Is Button Held(Event Player, Button(Secondary Fire)));
			Start Holding Button(Event Player, Button(Secondary Fire));
		End;
		If(Hero Of(Event Player) == Hero(Junkrat));
			Set Ability Charge(Event Player, Button(Ability 1), 2);
		End;
		Enable Movement Collision With Environment(Event Player);
		"Don't reset env collision / kill sphere locations if you're the pioneer"
		If(Global.CurrentPioneer != Event Player || (Is Button Held(Event Player, Button(Interact)) && Is Button Held(Event Player, Button(
			Reload))));
			Event Player.GreenSphereLocation = Null;
			Event Player.KillSphereLocation = Null;
		End;
		Event Player.WinstonWallClimbEnabled = True;
		Event Player.ReplayPosition = Empty Array;
		Event Player.ReplayFacing = Empty Array;
		Set Gravity(Event Player, 100);
		Event Player.EffectLockObtained = Empty Array;
		Event Player.AbilitiesForEffectLock = Empty Array;
		Event Player.AbilityLimitsDisplayVar = Global.CPAbilityCounts[Event Player.CurrentCP];
	}
}

rule("Sub2: CancelMomentum")
{
	event
	{
		Subroutine;
		CancelMomentum;
	}

	actions
	{
		Apply Impulse(Event Player, Up, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Down, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Left, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Right, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Forward, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Backward, 0.001, To World, Cancel Contrary Motion);
	}
}

rule("Sub3: HandleSkipTimer")
{
	event
	{
		Subroutine;
		HandleSkipTimer;
	}

	actions
	{
		Wait(0.200, Ignore Condition);
		"If Player is pioneer or waiting for pioneer"
		If(Count Of(Global.CPLocations) == Event Player.CurrentCP + 1 || False);
			Stop Chasing Player Variable(Event Player, TimeSpentOnCP);
			Event Player.TimeSpentOnCP = 0;
		Else;
			Event Player.TimeSpentOnCP = 0;
			Chase Player Variable At Rate(Event Player, TimeSpentOnCP, 9999, 1, Destination and Rate);
		End;
	}
}

rule("Sub5: Update Player Scale")
{
	event
	{
		Subroutine;
		UpdatePlayerScale;
	}

	actions
	{
		Start Scaling Player(Event Player, Event Player.PlayerScale, False);
		If(Event Player.PlayerScale < 0.700);
			Start Modifying Hero Voice Lines(Event Player, 4, False);
		Else If(Event Player.PlayerScale > 1.500);
			Start Modifying Hero Voice Lines(Event Player, 0.650, False);
		Else;
			Start Modifying Hero Voice Lines(Event Player, 1, False);
		End;
	}
}

rule("Sub6: CheckAbilityCounts")
{
	event
	{
		Subroutine;
		CheckAbilityCounts;
	}

	actions
	{
		If(Count Of(Event Player.EffectLockObtained) > 0);
			Event Player.AbilityLimitsDisplayVar = Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Last Of(
				Event Player.EffectLockObtained)] - Event Player.CPAbilityCounts;
			"Round the Z component (it gets set to a non-integer to tell game to cancel slam when you hit that orb, but don't display the 0.9, just round it)"
			Event Player.AbilityLimitsDisplayVar = Vector(X Component Of(Event Player.AbilityLimitsDisplayVar), Y Component Of(
				Event Player.AbilityLimitsDisplayVar), Round To Integer(Z Component Of(Event Player.AbilityLimitsDisplayVar), Up));
			If(Y Component Of(Event Player.CPAbilityCounts) >= Y Component Of(Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Last Of(
				Event Player.EffectLockObtained)]));
				Wait Until(!Is Using Ability 1(Event Player), 1);
				Set Ability 1 Enabled(Event Player, False);
			Else;
				Set Ability 1 Enabled(Event Player, True);
			End;
			If(Z Component Of(Event Player.CPAbilityCounts) >= Z Component Of(Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Last Of(
				Event Player.EffectLockObtained)]));
				Wait Until(!Is Using Ability 2(Event Player), 5);
				Skip If(Z Component Of(Event Player.CPAbilityCounts) < Z Component Of(
					Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Last Of(Event Player.EffectLockObtained)]), 1);
				Set Ability 2 Enabled(Event Player, False);
			Else;
				Set Ability 2 Enabled(Event Player, True);
			End;
			If(X Component Of(Event Player.CPAbilityCounts) >= X Component Of(Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Last Of(
				Event Player.EffectLockObtained)]));
				"Have to wait to disable punch because otherwise it would disable immediately after using, stopping the punch from continuing."
				Wait(Event Player.Grace, Ignore Condition);
				"This is to fix interaction with the Quick Reset (R) right after using punch, so this doesn't disable punch after you respawn"
				Abort If(True && Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentCP]) < Global.CPRadius);
				"So that you can punch through an effect lock without losing momentum"
				Abort If(Event Player.EffectLockTimerChase > 0 && X Component Of(Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Last Of(
					Event Player.EffectLockObtained)]) > 0);
				Set Secondary Fire Enabled(Event Player, False);
			Else;
				Set Secondary Fire Enabled(Event Player, True);
			End;
		Else;
			If(Y Component Of(Event Player.CPAbilityCounts) >= Y Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]));
				Set Ability 1 Enabled(Event Player, False);
			End;
			If(Z Component Of(Event Player.CPAbilityCounts) >= Z Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]));
				Set Ability 2 Enabled(Event Player, False);
			End;
			If(X Component Of(Event Player.CPAbilityCounts) >= X Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]));
				"Have to wait to disable punch because otherwise it would disable immediately after using preventing punch from working properly."
				Wait(0.800, Ignore Condition);
				"This is to fix interaction with the Quick Reset (R) right after using punch, so this doesn't disable punch after you respawn. Can have slight bug where player is punching through the start location, and doesn't set cooldown properly."
				Abort If(True && Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentCP]) < Global.CPRadius);
				"Adding this to fix issue of starting punch going through an effect lock that also allows punch. Otherwise, the effect lock would enable punch, then this rule would disable it!"
				Abort If(Event Player.EffectLockTimerChase > 0);
				Set Secondary Fire Enabled(Event Player, False);
			End;
			Event Player.AbilityLimitsDisplayVar = Global.CPAbilityCounts[Event Player.CurrentCP] - Event Player.CPAbilityCounts;
		End;
	}
}

rule("Sub7: Create Effect Locks and Env / Kill spheres")
{
	event
	{
		Subroutine;
		CreateEffectLocks;
	}

	actions
	{
		For Player Variable(Event Player, TempIterator, 0, Count Of(Event Player.TempMenuIDStore), 1);
			Destroy Effect(Event Player.TempMenuIDStore[Event Player.TempIterator]);
			Destroy In-World Text(Event Player.TextIDTempStore[Event Player.TempIterator]);
		End;
		Event Player.TempMenuIDStore = Empty Array;
		Event Player.TextIDTempStore = Empty Array;
		If(Global.CurrentPioneer == Event Player);
			Abort;
		End;
		For Player Variable(Event Player, TempIterator, 0, Count Of(Global.CPEffectLockSphereArray[Event Player.CurrentCP]), 1);
			"Effect Lock Sphere Create Non-Pioneer"
			Create Effect(Filtered Array(Event Player, Index Of Array Value(Current Array Element.EffectLockObtained, Evaluate Once(
				Event Player.TempIterator)) == -1), Sphere, Custom Color(192, 192, 192, 192), Evaluate Once(
				Global.CPEffectLockSphereArray[Event Player.CurrentCP][Event Player.TempIterator]), Evaluate Once(
				Global.EffectLockSphereRadiusConstant + -1), Visible To);
			Modify Player Variable(Event Player, TempMenuIDStore, Append To Array, Last Created Entity);
			Create In-World Text(Filtered Array(Event Player, Index Of Array Value(Current Array Element.EffectLockObtained, Evaluate Once(
				Event Player.TempIterator)) == -1), Custom String("{0} {1}", Custom String("{0}{1}{2}", X Component Of(
				Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Evaluate Once(Event Player.TempIterator)]) > 0 ? Ability Icon String(
				Hero Of(Event Player), Button(Secondary Fire)) : String(""), Y Component Of(
				Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Evaluate Once(Event Player.TempIterator)]) > 0 ? Ability Icon String(
				Hero Of(Event Player), Button(Ability 1)) : String(""), Z Component Of(
				Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Evaluate Once(Event Player.TempIterator)]) > 0 ? Ability Icon String(
				Hero Of(Event Player), Button(Ability 2)) : String("")), Global.EffectLocksOrderMatters ? Custom String("#{0}",
				Event Player.TempIterator + 1) : String("")), Evaluate Once(
				Global.CPEffectLockSphereArray[Event Player.CurrentCP][Event Player.TempIterator]), 1.300, Do Not Clip, Visible To, Color(
				Yellow), Default Visibility);
			Modify Player Variable(Event Player, TextIDTempStore, Append To Array, Last Text ID);
			Wait(0.016, Ignore Condition);
		End;
		If(Global.CPGreenSphereArray[Event Player.CurrentCP] != Null);
			"Green Sphere Create"
			Create Effect(Event Player, Sphere, Color(Green), Global.CPGreenSphereArray[Event Player.CurrentCP],
				Global.GreenSphereRadiusConstant, None);
			Modify Player Variable(Event Player, TempMenuIDStore, Append To Array, Last Created Entity);
		End;
		If(Global.CPKillSphereArray[Event Player.CurrentCP] != Null);
			"Kill Sphere Create"
			Create Effect(Event Player, Sphere, Color(Red), Global.CPKillSphereArray[Event Player.CurrentCP], Global.GreenSphereRadiusConstant,
				None);
			Modify Player Variable(Event Player, TempMenuIDStore, Append To Array, Last Created Entity);
		End;
	}
}

disabled rule("Pioneer Effect Lock And Environment Collision Spheres + Player Scaling")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Pioneer Create Effect Lock Sphere with Melee")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Is Button Held(Event Player, Button(Melee)) == True;
		Event Player.CancelPointTimer == 0;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player))
			> Global.EffectLockSphereRadiusConstant * 2;
		"No effect lock created yet or distance to last effect lock > effect lock sphere radius"
		(Event Player.EffectLockSphereLocation == Empty Array || Is True For All(Event Player.EffectLockSphereLocation, Distance Between(
			Eye Position(Event Player), Current Array Element) > Global.EffectLockSphereRadiusConstant * 2)) == True;
	}

	actions
	{
		Modify Player Variable(Event Player, AbilitiesForEffectLock, Append To Array, Vector(0, 0, 0));
		If(!Global.DisableHUDConstant);
			Small Message(Event Player, Custom String("Effect Lock Sphere Created!"));
		End;
		Play Effect(Event Player, Ring Explosion Sound, Color(White), Event Player, 60);
		"If player starts holding punch before creating effect lock, add punch to effect lock abilities"
		If(Hero Of(Event Player) == Hero(Doomfist) && Is Firing Secondary(Event Player));
			Event Player.AbilitiesForEffectLock[Count Of(Event Player.AbilitiesForEffectLock) - 1] += Left;
		End;
		If(Hero Of(Event Player) == Hero(Doomfist) && Is Using Ability 2(Event Player));
			If(Speed Of(Event Player) > 8);
				Cancel Primary Action(Event Player);
				Event Player.AbilitiesForEffectLock[Count Of(Event Player.AbilitiesForEffectLock) - 1] += Vector(0, 0, -0.100);
			End;
		End;
		If(Global.EffectLocksResetCooldownConstant);
			Wait Until(!(Is Using Ability 1(Event Player) || Is Firing Secondary(Event Player)), 2);
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
			Set Ability Cooldown(Event Player, Button(Ability 2), 0);
			"for wrecking ball"
			Set Ability Cooldown(Event Player, Button(Jump), 0);
			Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		End;
		Modify Player Variable(Event Player, EffectLockSphereLocation, Append To Array, Eye Position(Event Player));
		"to stop pioneer from creating spheres too many in a row"
		Wait(0.250, Ignore Condition);
	}
}

rule("Obtain Effect Lock Sphere (Non-Pioneer)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Global.CPEffectLockSphereArray[Event Player.CurrentCP] != Empty Array;
		Is True For Any(Global.CPEffectLockSphereArray[Event Player.CurrentCP], Distance Between(Eye Position(Event Player),
			Current Array Element) <= Global.EffectLockSphereRadiusConstant && Index Of Array Value(Event Player.EffectLockObtained,
			Current Array Index) == -1) == True;
		Global.GameStarted == True;
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations);
	}

	actions
	{
		"Get index of this effect lock sphere"
		Event Player.TempVariable2 = Index Of Array Value(Global.CPEffectLockSphereArray[Event Player.CurrentCP], First Of(Filtered Array(
			Global.CPEffectLockSphereArray[Event Player.CurrentCP], Distance Between(Eye Position(Event Player), Current Array Element)
			< Global.EffectLockSphereRadiusConstant)));
		If(Global.EffectLocksOrderMatters && Count Of(Event Player.EffectLockObtained) != Event Player.TempVariable2);
			Small Message(Event Player, Custom String("Effect Locks Must Be Obtained In Order!"));
			Abort;
		End;
		Modify Player Variable(Event Player, EffectLockObtained, Append To Array, Event Player.TempVariable2);
		Play Effect(Event Player, Ring Explosion Sound, Color(White), Event Player, 60);
		If(!Global.DisableHUDConstant);
			Small Message(Event Player, Custom String("Effect Lock Obtained: {0} of {1}", Count Of(Event Player.EffectLockObtained), Count Of(
				Global.CPEffectLockSphereArray[Event Player.CurrentCP]), Event Player.TempVariable2));
		End;
		If(Hero Of(Event Player) == Hero(Doomfist) && Is Using Ability 2(Event Player));
			If(Round To Integer(Z Component Of(Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Event Player.TempVariable2]),
				To Nearest) != Z Component Of(Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Event Player.TempVariable2]));
				Cancel Primary Action(Event Player);
			End;
		End;
		Event Player.CPAbilityCounts = Vector(0, 0, 0);
		Wait Until(!Is Using Ability 2(Event Player), 5);
		Event Player.EffectLockTimerChase = 0.800;
		Start Rule(CheckAbilityCounts, Restart Rule);
		If(Global.EffectLocksResetCooldownConstant);
			Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
			Set Ability Cooldown(Event Player, Button(Ability 2), 0);
			"for wrecking ball"
			Set Ability Cooldown(Event Player, Button(Jump), 0);
		End;
	}
}

rule("Pioneer Create Green Sphere with Crouch")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Is Button Held(Event Player, Button(Crouch)) == True;
		Hero Of(Event Player) != Hero(Wrecking Ball);
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		disabled Event Player.GreenSphereLocation = Eye Position(Event Player);
		Event Player.GreenSphereLocation = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 12, Null, Event Player, True);
	}
}

rule("Green Sphere Rule (Pioneer Only) - In Sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Event Player.GreenSphereLocation != Null;
		Distance Between(Eye Position(Event Player), Event Player.GreenSphereLocation) < Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Disable Movement Collision With Environment(Event Player, False);
	}
}

rule("Green Sphere Rule (Pioneer Only) - Outside Sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Event Player.GreenSphereLocation != Null;
		Distance Between(Eye Position(Event Player), Event Player.GreenSphereLocation) > Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Wait(0.250, Ignore Condition);
		Enable Movement Collision With Environment(Event Player);
	}
}

rule("Green Sphere Rule (Non-Pioneer) - In Sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Global.CPGreenSphereArray[Event Player.CurrentCP] != Null;
		Distance Between(Eye Position(Event Player), Global.CPGreenSphereArray[Event Player.CurrentCP]) < Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Disable Movement Collision With Environment(Event Player, False);
	}
}

rule("Green Sphere Rule (Non-Pioneer) - Outside Sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Global.CPGreenSphereArray[Event Player.CurrentCP] != Null;
		Distance Between(Eye Position(Event Player), Global.CPGreenSphereArray[Event Player.CurrentCP]) > Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Wait(0.250, Ignore Condition);
		Enable Movement Collision With Environment(Event Player);
	}
}

rule("Pioneer Create Kill Sphere With Group Up")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Is Communicating(Event Player, Group Up) == True;
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.KillSphereLocation = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 20, Null, Event Player, True);
		Small Message(Event Player, Custom String("Kill Sphere Created!"));
		Play Effect(Event Player, Buff Explosion Sound, Color(White), Event Player, 60);
	}
}

rule("Pioneer Respawns if in kill sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Event Player.KillSphereLocation != Null;
		Distance Between(Eye Position(Event Player), Event Player.KillSphereLocation) < Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
		Small Message(Event Player, Custom String("Avoid the red spheres!"));
	}
}

rule("Non-Pioneer Respawns if in Kill Sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Global.CPKillSphereArray[Event Player.CurrentCP] != Null;
		Distance Between(Eye Position(Event Player), Global.CPKillSphereArray[Event Player.CurrentCP]) < Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
		Small Message(Event Player, Custom String("Avoid the red spheres!"));
	}
}

disabled rule("Sigma Abilities")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Barrier {1}")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.sigma_barrier_ON = True;
		Event Player.sigma_barrier_init_position = Eye Position(Event Player) + Facing Direction Of(Event Player) * 3;
		Event Player.sigma_barrier_direction = Facing Direction Of(Event Player);
		Event Player.sigma_barrier_chase = 0;
		Chase Player Variable At Rate(Event Player, sigma_barrier_chase, Distance Between(Event Player.sigma_barrier_init_position,
			Ray Cast Hit Position(Event Player.sigma_barrier_init_position,
			Event Player.sigma_barrier_init_position + Event Player.sigma_barrier_direction * 200, Null, Event Player, False)), 16.500,
			Destination and Rate);
		"Updates barrier position"
		While(True);
			Event Player.sigma_barrier_position = Event Player.sigma_barrier_init_position + Event Player.sigma_barrier_direction * Event Player.sigma_barrier_chase;
			Wait(0.016, Ignore Condition);
			Abort If Condition Is False;
		End;
	}
}

rule("Barrier {2}")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == False;
		Event Player.sigma_barrier_ON == True;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, sigma_barrier_chase);
		Wait(0.192, Ignore Condition);
		Event Player.sigma_barrier_ready_to_destroy = True;
	}
}

rule("Barrier Launch")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Event Player.sigma_barrier_ON == True;
		Distance Between(Eye Position(Event Player), Event Player.sigma_barrier_position) < 3;
	}

	actions
	{
		"{Turns shield into a bouncepad instead when turned on}"
		disabled Event Player.sigma_barrier_direction = Vector(X Component Of(Event Player.sigma_barrier_direction), Absolute Value(Y Component Of(
			Event Player.sigma_barrier_direction)), Z Component Of(Event Player.sigma_barrier_direction));
		Apply Impulse(Event Player, Event Player.sigma_barrier_direction, 30, To World, Cancel Contrary Motion);
	}
}

rule("Remove Barrier")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Event Player.sigma_barrier_ready_to_destroy == True;
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
	}

	actions
	{
		Event Player.sigma_barrier_ON = False;
		Wait(0.016, Ignore Condition);
		Event Player.sigma_barrier_ready_to_destroy = False;
	}
}

rule("Destroy Pulse On Death")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Dead(Event Player) == True;
	}

	actions
	{
		Event Player.sigma_barrier_ON = False;
		Event Player.sigma_barrier_ready_to_destroy = False;
	}
}

rule("Vortex Drag {By default, using vortex makes you glide across the ground without resetting during the animation}")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Set Gravity(Event Player, 0);
		Set Move Speed(Event Player, Global.PlayerMoveSpeedConstant * 1.200);
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Wait Until(Is Button Held(Event Player, Button(Reload)), 2);
		Set Gravity(Event Player, 100);
		Set Move Speed(Event Player, Global.PlayerMoveSpeedConstant);
		Stop Forcing Throttle(Event Player);
	}
}

rule("Vortex Refresh")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Dead(Event Player) == True;
	}

	actions
	{
		Set Move Speed(Event Player, 100);
		Set Gravity(Event Player, 100);
	}
}

rule("Rock Booster")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		"Rock can be used during the vortex animation"
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Wait(0.650, Ignore Condition);
		Apply Impulse(Event Player, Facing Direction Of(Event Player), -14, To World, Cancel Contrary Motion);
	}
}

disabled rule("WINSTON STUFF")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Initialize Winston")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	actions
	{
		Event Player.WinstonBubbleLocation = Null;
	}
}

rule("Winston Leap Grace - Toggle On When Using Leap")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, WinstonLeapGrace);
		Event Player.WinstonLeapGrace = 0.250;
	}
}

rule("Winston Leap Grace - Set Grace Variable Chase When Touching Ground")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == False;
		Is On Ground(Event Player) == True;
	}

	actions
	{
		Chase Player Variable At Rate(Event Player, WinstonLeapGrace, 0, 1, Destination and Rate);
	}
}

rule("Create Bubble")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		"Place Bubble on ground below player. Easier for new players to figure out what's going on (compared to Ray Cast bubble position)."
		Event Player.WinstonBubbleLocation = Position Of(Event Player) + World Vector Of(Forward, Event Player, Rotation)
			* Horizontal Speed Of(Event Player) * 0.300 + Down * Altitude Of(Event Player);
		If(Distance Between(Event Player.WinstonBubbleLocation, Position Of(Event Player)) > 100);
			Small Message(Event Player, Custom String("Barrier Cast Out Of Range (100m)"));
			Set Ability Cooldown(Event Player, Button(Ability 2), 0);
			Abort;
		End;
		Create Effect(Event Player, Sphere, Color(Blue), Event Player.WinstonBubbleLocation, 5, Visible To Position and Radius);
		Event Player.WinstonBubbleEffect = Last Created Entity;
		Event Player.WinstonBouncyBubbleCooldown = 9;
		Chase Player Variable At Rate(Event Player, WinstonBouncyBubbleCooldown, 0, 1, Destination and Rate);
		While(Event Player.WinstonBouncyBubbleCooldown > 0 && !Is Dead(Event Player));
			Wait(0.100, Ignore Condition);
		End;
		Destroy Effect(Event Player.WinstonBubbleEffect);
		Event Player.WinstonBubbleLocation = Null;
	}
}

rule("Winston Bubble Physics Rule")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Event Player.WinstonBubbleLocation != Null;
		Distance Between(Position Of(Event Player), Event Player.WinstonBubbleLocation) <= 5;
	}

	actions
	{
		"Direct Impulse - Cancel's Player Motion, so physically inaccurate bounce"
		Apply Impulse(Event Player, Direction Towards(Event Player.WinstonBubbleLocation, Position Of(Event Player)), Speed Of(
			Event Player) * 1.300, To World, Cancel Contrary Motion);
	}
}

rule("Winston Wall Climb")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) == True;
		"Make this so a player can't use wall climb multiple times in a row."
		Event Player.WinstonWallClimbEnabled == True;
	}

	actions
	{
		Event Player.WinstonWallClimbTimer = 4;
		"Set Wall Climb to have a max of 4 sec duration. This prevents you from wall climing against a roof/skybox for indefinite stall."
		Chase Player Variable Over Time(Event Player, WinstonWallClimbTimer, 0, 4, Destination and Duration);
		"Wall Climb while Jump is held, have been wall climbing less than 4 sec, are within 0.5m of wall"
		While(Is Button Held(Event Player, Button(Jump)) && Event Player.WinstonWallClimbTimer > 0 && Distance Between(
			Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + Direction From Angles(
			Horizontal Angle From Direction(Facing Direction Of(Event Player)), 0) * 10, All Players(All Teams), Event Player, True),
			Eye Position(Event Player)) < 3);
			Wait(0.033, Ignore Condition);
			Set Move Speed(Event Player, 0);
			Apply Impulse(Event Player, Up, 7, To World, Cancel Contrary Motion);
			Apply Impulse(Event Player, Forward, 1, To Player, Cancel Contrary Motion);
			Event Player.WinstonWallClimbEnabled = False;
		End;
		Set Move Speed(Event Player, 100);
		Wait(0.033, Ignore Condition);
		Loop If Condition Is True;
	}
}

disabled rule("ANA MODIFIERS")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Ana Primary Impulse")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ana;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
		Has Status(Event Player, Rooted) == False;
		disabled Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Set Gravity(Event Player, 0);
		Apply Impulse(Event Player, Facing Direction Of(Event Player), 15, To World, Cancel Contrary Motion);
		Wait(0.060, Ignore Condition);
		Set Gravity(Event Player, 100);
	}
}

rule("Ana Sleep Dart Teleport")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ana;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Stop Camera(Event Player);
		"The duration before Ana fires sleep dart"
		Wait(0.300, Ignore Condition);
		Event Player.AnaSleepDartTeleLocation = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 180, All Players(All Teams), Event Player, True);
		If(Distance Between(Eye Position(Event Player), Event Player.AnaSleepDartTeleLocation) > 175);
			Wait(0.100, Ignore Condition);
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
			Abort;
		End;
		"Shorten ray cast to avoid unintended tele through surfaces"
		Event Player.AnaSleepDartTeleLocation -= Direction Towards(Eye Position(Event Player), Event Player.AnaSleepDartTeleLocation)
			* 0.500;
		"Sleep dart travel time"
		Wait(Distance Between(Eye Position(Event Player), Event Player.AnaSleepDartTeleLocation) / 60, Ignore Condition);
		Teleport(Event Player, Event Player.AnaSleepDartTeleLocation);
		Call Subroutine(CancelMomentum);
	}
}

rule("Skybox Detector - Don't let people tele then surf the skybox / let people fall through the skybox")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ana;
	}

	conditions
	{
		Vertical Speed Of(Event Player) == 0;
		"Player and many positons around the player are on invisible walls"
		Is True For All(Array(Vector(-1, 0, -1), Vector(-1, 0, 1), Vector(1, 0, -1), Vector(1, 0, 1), Vector(0, 0, 0)), Distance Between(
			Eye Position(Event Player) + Current Array Element, Ray Cast Hit Position(Eye Position(Event Player) + Current Array Element,
			Eye Position(Event Player) + Current Array Element + Vector(0, -10, 0), Null, Event Player, False)) == 10) == True;
	}

	actions
	{
		Wait(0.100, Abort When False);
		Small Message(Event Player, Custom String("On the skybox!"));
		Disable Movement Collision With Environment(Event Player, True);
		Wait(0.500, Ignore Condition);
		Enable Movement Collision With Environment(Event Player);
	}
}

rule("Heal = Impulse {must be damaged when spawning}")
{
	event
	{
		Player Dealt Healing;
		All;
		Ana;
	}

	conditions
	{
		Healee == Healer;
		Has Status(Event Player, Rooted) == False;
	}

	actions
	{
		Apply Impulse(Event Player, Facing Direction Of(Event Player), -15, To World, Cancel Contrary Motion);
		Wait(1, Ignore Condition);
	}
}

rule("Ana Health Managment")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ana;
	}

	conditions
	{
		Normalized Health(Event Player) >= 1;
		Is In Spawn Room(Event Player) != True;
	}

	actions
	{
		Clear Status(Event Player, Phased Out);
		Damage(Event Player, Event Player, 50);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
		Set Status(Event Player, Null, Phased Out, 9999);
	}
}

disabled rule("ROADHOG STUFF")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Change Hook to Grappling Hook")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		"Initial impulse to let you hook in midair without falling too far while hook is out"
		Apply Impulse(Event Player, Up, 3, To World, Cancel Contrary Motion);
		"Issue here is that we are using ray cast to determine hook impact, which isn't visually accurate, so the hook may impact a wall but not be deteted."
		Event Player.RoadhogHookPosition = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ 120 * Facing Direction Of(Event Player), All Players(All Teams), Event Player, True);
		"Abort if hook didn't connect with a wall within 25m. For reference, 20m is hook range for normal roadhog."
		If(Distance Between(Position Of(Event Player), Event Player.RoadhogHookPosition) > 25);
			Small Message(Event Player, Custom String("Out of hook range!"));
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
			Abort;
		End;
		"Wait for hook to \"hit\" something. Hook moves at 40m/s"
		Wait(Distance Between(Position Of(Event Player), Event Player.RoadhogHookPosition) / 40, Ignore Condition);
		"Impulse that increases with hook range. Hook impulse = Base Impulse + Hook Range x Range Multiplier."
		Apply Impulse(Event Player, Direction Towards(Position Of(Event Player), Event Player.RoadhogHookPosition), 20 + Distance Between(
			Event Player.RoadhogHookPosition, Position Of(Event Player)) * 0.800, To World, Cancel Contrary Motion);
		"Large Linear Impulse. Disabled while testing impulse that increases with range."
		disabled Apply Impulse(Event Player, Direction Towards(Position Of(Event Player), Event Player.RoadhogHookPosition), 40, To World,
			Cancel Contrary Motion);
	}
}

rule("Change Take A Breather to Bouncy Ball Hog")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		disabled Is On Ground(Event Player) == True;
		Altitude Of(Event Player) <= 1.500;
	}

	actions
	{
		Apply Impulse(Event Player, Up, Speed Of(Event Player) * 1.200, To World, Cancel Contrary Motion);
	}
}

rule("Add Knockback When Secondary Fire Used")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Apply Impulse(Event Player, Facing Direction Of(Event Player), -12, To World, Cancel Contrary Motion);
	}
}

disabled rule("Other Stuff")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Ms. Destructo | Created by nebula - slightly modified from original YENEP")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Has Spawned(Host Player) == True;
	}

	actions
	{
		Wait(2, Ignore Condition);
		Create Dummy Bot(Hero(D.Va), Team Of(Host Player), -1, Vector(0, 200, 0), Vector(0, 0, 0));
		Global.MsDestructo = Last Created Entity;
		disabled Set Invisible(First Of(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element) && Hero Of(Current Array Element)
			== Hero(D.Va))), All);
		Start Forcing Dummy Bot Name(Global.MsDestructo, Custom String("Ms. Destructo"));
		Wait(3, Ignore Condition);
		If(Current Map == Map(Hanamura) || Current Map == Map(Hanamura Winter));
			Teleport(Global.MsDestructo, Vector(15.759, 30.576, -27.201));
		Else If(Current Map == Map(Horizon Lunar Colony));
			Teleport(Global.MsDestructo, Vector(31.759, 40.003, -59.476));
		Else If(Current Map == Map(Paris));
			Teleport(Global.MsDestructo, Vector(-54.508, 40.179, -10.866));
		Else If(Current Map == Map(Temple of Anubis));
			Teleport(Global.MsDestructo, Vector(-26.780, 23.366, 40.284));
		Else If(Current Map == Map(Dorado));
			Teleport(Global.MsDestructo, Vector(69.418, 42.103, -17.712));
		Else If(Current Map == Map(Havana));
			Teleport(Global.MsDestructo, Vector(9.382, 38.635, -81.276));
		Else If(Current Map == Map(Junkertown));
			Teleport(Global.MsDestructo, Vector(9.382, 38.635, -81.276));
		Else If(Current Map == Map(Rialto));
			Teleport(Global.MsDestructo, Vector(9.756, 30.753, -41.395));
		Else If(Current Map == Map(Route 66));
			Teleport(Global.MsDestructo, Vector(30.313, 28.237, -16.925));
		Else If(Current Map == Map(Watchpoint: Gibraltar));
			Teleport(Global.MsDestructo, Vector(73.985, 26.198, -109.338));
		Else If(Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter));
			Teleport(Global.MsDestructo, Vector(-21.030, 35.127, 88.381));
		Else If(Current Map == Map(Eichenwalde) || Current Map == Map(Eichenwalde Halloween));
			Teleport(Global.MsDestructo, Vector(-21.030, 35.127, 88.381));
		Else If(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween));
			Teleport(Global.MsDestructo, Vector(-0.355, 28.167, -22.396));
		Else If(Current Map == Map(King's Row) || Current Map == Map(King's Row Winter));
			Teleport(Global.MsDestructo, Vector(-56.869, 24.061, -32.132));
		Else If(Current Map == Map(Numbani));
			Teleport(Global.MsDestructo, Vector(-56.869, 24.061, -32.132));
		Else If(Current Map == Map(Ayutthaya));
			Teleport(Global.MsDestructo, Vector(16.965, 26.541, -7.130));
		Else If(Current Map == Map(Busan Downtown Lunar New Year));
			Teleport(Global.MsDestructo, Vector(51.885, 37.172, -113.654));
		Else If(Current Map == Map(Busan Sanctuary Lunar New Year));
			Teleport(Global.MsDestructo, Vector(-329.934, 56.136, 149.839));
		Else If(Current Map == Map(Ilios Lighthouse));
			Teleport(Global.MsDestructo, Vector(322.988, 15.716, -37.732));
		Else If(Current Map == Map(Ilios Ruins));
			Teleport(Global.MsDestructo, Vector(27.711, 87.241, -161.298));
		Else If(Current Map == Map(Ilios Well));
			Teleport(Global.MsDestructo, Vector(-223.895, 34.756, 0.890));
		Else If(Current Map == Map(Lijiang Control Center) || Current Map == Map(Lijiang Control Center Lunar New Year));
			Teleport(Global.MsDestructo, Vector(-5.808, 324.398, 282.523));
		Else If(Current Map == Map(Lijiang Garden) || Current Map == Map(Lijiang Garden Lunar New Year));
			Teleport(Global.MsDestructo, Vector(-0.414, 156.197, 148.681));
		Else If(Current Map == Map(Lijiang Night Market) || Current Map == Map(Lijiang Night Market Lunar New Year));
			Teleport(Global.MsDestructo, Vector(-0.381, 53.736, -33.335));
		Else If(Current Map == Map(Nepal Sanctum));
			Teleport(Global.MsDestructo, Vector(83.100, 178.926, 0.593));
		Else If(Current Map == Map(Nepal Shrine));
			Teleport(Global.MsDestructo, Vector(-49.803, 63.290, -0.413));
		Else If(Current Map == Map(Nepal Village) || Current Map == Map(Nepal Village Winter));
			Teleport(Global.MsDestructo, Vector(-184.659, -38.730, -0.783));
		Else If(Current Map == Map(Oasis City Center));
			Teleport(Global.MsDestructo, Vector(150.125, 30.619, 251.966));
		Else If(Current Map == Map(Oasis Gardens));
			Teleport(Global.MsDestructo, Vector(134.888, 36.760, -240.736));
		Else If(Current Map == Map(Oasis University));
			Teleport(Global.MsDestructo, Vector(-195.549, 60.350, -0.098));
		Else If(Current Map == Map(Black Forest) || Current Map == Map(Black Forest Winter));
			Teleport(Global.MsDestructo, Vector(-9.622, 44.751, 5.635));
		Else If(Current Map == Map(Castillo));
			Teleport(Global.MsDestructo, Vector(-100.828, 76.566, 60.021));
		Else If(Current Map == Map(Ecopoint: Antarctica) || Current Map == Map(Ecopoint: Antarctica Winter));
			Teleport(Global.MsDestructo, Vector(-6.186, 35.564, 1.378));
		Else If(Current Map == Map(ChÃ¢teau Guillard) || Current Map == Map(ChÃ¢teau Guillard Halloween));
			Teleport(Global.MsDestructo, Vector(200.414, 82.412, 78.813));
		Else If(Current Map == Map(Kanezaka));
			Teleport(Global.MsDestructo, Vector(-36.319, 32.305, 0.472));
		Else If(Current Map == Map(Necropolis));
			Teleport(Global.MsDestructo, Vector(-1.144, 47.168, -2.946));
		Else If(Current Map == Map(Petra));
			Teleport(Global.MsDestructo, Vector(9.678, 28.313, 13.400));
		Else If(Current Map == Map(Volskaya Industries));
			Teleport(Global.MsDestructo, Vector(-49.147, 22.344, 76.844));
		Else If(Current Map == Map(Practice Range));
			Teleport(Global.MsDestructo, Vector(54.948, 50.769, 3.930));
		Else If(Current Map == Map(Ilios));
			Teleport(Global.MsDestructo, Vector(322.988, 40, -37.732));
			Start Scaling Player(Global.MsDestructo, 20, True);
			Set Ultimate Ability Enabled(Global.MsDestructo, True);
			Wait(3, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Wait(8, Ignore Condition);
			Stop Scaling Player(Global.MsDestructo);
			Teleport(Global.MsDestructo, Vector(27.711, 200, -161.298));
			Start Scaling Player(Global.MsDestructo, 20, True);
			Wait(3, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Wait(8, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Stop Scaling Player(Global.MsDestructo);
			Teleport(Global.MsDestructo, Vector(-223.895, 120, 0.890));
			Start Scaling Player(Global.MsDestructo, 20, True);
			Wait(3, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Wait(8, Ignore Condition);
			Stop Scaling Player(Global.MsDestructo);
			Destroy Dummy Bot(Team Of(Global.MsDestructo), Slot Of(Global.MsDestructo));
		Else If(Current Map == Map(Busan));
			Teleport(Global.MsDestructo, Vector(51.885, 37.172, -113.654));
			Start Scaling Player(Global.MsDestructo, 20, True);
			Set Ultimate Ability Enabled(Global.MsDestructo, True);
			Wait(3, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Wait(8, Ignore Condition);
			Stop Scaling Player(Global.MsDestructo);
			Teleport(Global.MsDestructo, Vector(-329.934, 56.136, 149.839));
			Start Scaling Player(Global.MsDestructo, 20, True);
			Wait(3, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Wait(8, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Stop Scaling Player(Global.MsDestructo);
			Teleport(Global.MsDestructo, Vector(227.210, 43.353, 252.640));
			Start Scaling Player(Global.MsDestructo, 20, True);
			Wait(3, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Wait(8, Ignore Condition);
			Stop Scaling Player(Global.MsDestructo);
			Destroy Dummy Bot(Team Of(Global.MsDestructo), Slot Of(Global.MsDestructo));
		Else If(Current Map == Map(Lijiang Tower) || Current Map == Map(Lijiang Tower Lunar New Year));
			Teleport(Global.MsDestructo, Vector(-5.808, 324.398, 282.523));
			Start Scaling Player(Global.MsDestructo, 20, True);
			Set Ultimate Ability Enabled(Global.MsDestructo, True);
			Wait(3, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Wait(8, Ignore Condition);
			Stop Scaling Player(Global.MsDestructo);
			Teleport(Global.MsDestructo, Vector(-0.414, 156.197, 148.681));
			Start Scaling Player(Global.MsDestructo, 20, True);
			Wait(3, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Wait(8, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Stop Scaling Player(Global.MsDestructo);
			Teleport(Global.MsDestructo, Vector(-0.381, 53.736, -33.335));
			Start Scaling Player(Global.MsDestructo, 20, True);
			Wait(3, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Wait(8, Ignore Condition);
			Stop Scaling Player(Global.MsDestructo);
			Destroy Dummy Bot(Team Of(Global.MsDestructo), Slot Of(Global.MsDestructo));
		Else If(Current Map == Map(Nepal));
			Teleport(Global.MsDestructo, Vector(83.100, 178.926, 0.593));
			Start Scaling Player(Global.MsDestructo, 20, True);
			Set Ultimate Ability Enabled(Global.MsDestructo, True);
			Wait(3, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Wait(8, Ignore Condition);
			Stop Scaling Player(Global.MsDestructo);
			Teleport(Global.MsDestructo, Vector(-49.803, 63.290, -0.413));
			Start Scaling Player(Global.MsDestructo, 20, True);
			Wait(3, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Wait(8, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Stop Scaling Player(Global.MsDestructo);
			Teleport(Global.MsDestructo, Vector(-184.659, -38.730, -0.783));
			Start Scaling Player(Global.MsDestructo, 20, True);
			Wait(3, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Wait(8, Ignore Condition);
			Stop Scaling Player(Global.MsDestructo);
			Destroy Dummy Bot(Team Of(Global.MsDestructo), Slot Of(Global.MsDestructo));
		Else If(Current Map == Map(Oasis));
			Teleport(Global.MsDestructo, Vector(150.125, 30.619, 251.966));
			Start Scaling Player(Global.MsDestructo, 20, True);
			Set Ultimate Ability Enabled(Global.MsDestructo, True);
			Wait(3, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Wait(8, Ignore Condition);
			Stop Scaling Player(Global.MsDestructo);
			Teleport(Global.MsDestructo, Vector(134.888, 36.760, -240.736));
			Start Scaling Player(Global.MsDestructo, 20, True);
			Wait(3, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Wait(8, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Stop Scaling Player(Global.MsDestructo);
			Teleport(Global.MsDestructo, Vector(-195.549, 60.350, -0.098));
			Start Scaling Player(Global.MsDestructo, 20, True);
			Wait(3, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Wait(8, Ignore Condition);
			Stop Scaling Player(Global.MsDestructo);
			Destroy Dummy Bot(Team Of(Global.MsDestructo), Slot Of(Global.MsDestructo));
		End;
		If(Is Dummy Bot(Global.MsDestructo) == True);
			Start Scaling Player(Global.MsDestructo, 20, True);
			Set Ultimate Ability Enabled(Global.MsDestructo, True);
			Wait(3, Ignore Condition);
			Set Ultimate Charge(Global.MsDestructo, 100);
			Start Holding Button(Global.MsDestructo, Button(Ultimate));
			Wait(8, Ignore Condition);
			Destroy Dummy Bot(Team Of(Global.MsDestructo), Slot Of(Global.MsDestructo));
	}
}

rule("Make Ms Destructo Bot Invisible - Doesn't work on the mech lol")
{
	event
	{
		Ongoing - Each Player;
		All;
		D.Va;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		Set Invisible(Event Player, All);
	}
}