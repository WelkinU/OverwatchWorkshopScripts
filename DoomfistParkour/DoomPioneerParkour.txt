settings
{
	main
	{
		Description: "Doomfist Pioneering Parkour - Workshop Code YMVCR. Press Interact to view controls. Press Need Healing to view replay CP route. Host can go to Lobby -> Settings -> Workshop Settings to change many game parameters. ---------------------- Made by WelkinTern, pioneer replay improvments by khandescension.  ---------------------- Last Updated: Apr 13, 2021  Code Update History: https://github.com/WelkinU/OverwatchWorkshopScripts/commits/"
	}

	lobby
	{
		Max Team 1 Players: 12
		Max Team 2 Players: 0
	}

	modes
	{
		Skirmish
		{
			enabled maps
			{
				Eichenwalde Halloween
			}
		}

		General
		{
			Hero Limit: Off
			Kill Feed: Off
		}
	}

	heroes
	{
		General
		{
			Ultimate Generation - Passive: 0%

			Ana
			{
				Ammunition Clip Size Scalar: 25%
				Biotic Grenade Cooldown Time: 60%
				Sleep Dart Cooldown Time: 75%
			}

			Baptiste
			{
				Immortality Field Cooldown Time: 70%
				Regenerative Burst Cooldown Time: 70%
			}

			D.Va
			{
				Spawn With Ultimate Ready: On
			}

			Doomfist
			{
				No Ammunition Requirement: On
				Seismic Slam Cooldown Time: 50%
			}

			Genji
			{
				Ammunition Clip Size Scalar: 25%
				Swift Strike Cooldown Time: 75%
				Ultimate Duration: 34%
			}

			Roadhog
			{
				Ammunition Clip Size Scalar: 40%
				Chain Hook Cooldown Time: 75%
				Take a Breather Cooldown Time: 75%
			}

			Sigma
			{
				Accretion Cooldown Time: 60%
				Kinetic Grasp Cooldown Time: 20%
			}

			Widowmaker
			{
				Grappling Hook Cooldown Time: 0%
			}

			Winston
			{
				No Ammunition Requirement: On
				Ultimate Duration: 60%
			}

			enabled heroes
			{
				Doomfist
			}
		}
	}

	workshop
	{
		Multi-Hero Mode Enabled: On
	}
}

variables
{
	global:
		0: CPLocations
		1: PioneerList
		2: CPAbilityCounts
		3: CPUltimateTeleportPrimary
		4: CPFacingDirections
		5: CPHeroList
		6: GameStarted
		7: PioneerTimer
		8: CurrentPioneer
		9: MultiHeroEnabled
		10: SkipTimeLimit
		11: InfiniteModeEnabledConstant
		12: AbilityCountsEnabledConstant
		14: PioneerTimeLimitConstant
		15: PlayerMoveSpeedConstant
		16: NonInfiniteModeWinTime
		17: PioneerMinDistanceConstant
		18: PunchGraceEnabled
		19: PrimaryFireUsefulForTheseHeros
		20: CPRadius
		21: SlamBuffEnabled
		22: HeroRoster
		23: CPGreenSphereArray
		24: GreenSphereRadiusConstant
		25: CPEffectLockSphereArray
		26: EffectLockSphereRadiusConstant
		27: DevModeEngaged
		28: CPKillSphereArray
		29: UltimateAbilitiesEnabledConstant
		30: ReplaysEnabledConstant
		31: ReplayPioneerPositionArray
		32: ReplayPioneerFacingArray
		33: UsingMemoryRecall
		34: CPPlayerScaleArray
		35: AllowedPlayerScalesArray
		36: EffectLockAbilitiesArray
		37: DisableHUDConstant
		38: EffectLocksOrderMatters

	player:
		0: CurrentCP
		2: MaxUnlockedCP
		3: Invisible
		4: CPAbilityCounts
		5: CountUltimateTeleportPrimary
		6: FacingDirectionLeavingCP
		7: TeleportEnabled
		8: TimeSpentOnCP
		9: SpectateMode
		10: ForceRespawn
		11: BlockArriveNextPoint
		12: BlockPioneerNewPoint
		13: EffectLockObtained
		14: SlamTimer
		15: PunchFixStore
		16: GreenSphereLocation
		17: EffectLockSphereLocation
		18: KillSphereLocation
		19: ReplayPosition
		20: ReplayFacing
		21: PlayerScale
		22: TempVariable
		23: TempVariable2
		24: CancelPointTimer
		25: TempMenuIDStore
		26: sigma_barrier_ready_to_destroy
		27: sigma_barrier_ON
		28: sigma_barrier_direction
		29: sigma_barrier_init_position
		30: sigma_barrier_chase
		31: sigma_barrier_position
		32: Grace
		33: WinstonLeapGrace
		34: Count360Slam125
		35: BlockPioneerPass
		36: WinstonWallClimbEnabled
		37: WinstonWallClimbTimer
		38: WinstonBubbleLocation
		39: WinstonBouncyBubbleCooldown
		40: WinstonBubbleEffect
		41: HeroSelectMenuOpen
		42: MenuInWorldLocationTempStore
		43: MenuTextIDTempStore
		44: TempIterator
		45: AnaSleepDartTeleLocation
		46: RoadhogHookPosition
		47: AbilitiesForEffectLock
		48: TextIDTempStore
		49: AbilityLimitsDisplayVar
		50: EffectLockTimerChase
}

subroutines
{
	0: RespawnPlayer
	2: CancelMomentum
	3: HandleSkipTimer
	4: MemoryRecall
	5: UpdatePlayerScale
	6: CheckAbilityCounts
	7: CreateEffectLocks
}

rule("--------MEMORY: PASTE VARIABLES HERE -------------------")
{
	event
	{
		Subroutine;
		MemoryRecall;
	}
}

disabled rule("Initialization")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Initialize Globals")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Disable Inspector Recording;
		Pause Match Time;
		"These are the allowed heros for multi-hero mode"
		Global.HeroRoster = Array(Hero(Doomfist), Hero(Sigma), Hero(Genji), Hero(Winston), Hero(Wrecking Ball), Hero(LÃºcio), Hero(Roadhog),
			Hero(Junkrat), Hero(Ana));
		Global.AllowedPlayerScalesArray = Array(0.100, 1, 2, 5);
		Global.AbilityCountsEnabledConstant = Workshop Setting Toggle(Custom String("Important Settings"), Custom String(
			"Ability Count Limits Enabled"), True, 0);
		Global.PioneerTimeLimitConstant = Workshop Setting Integer(Custom String("Important Settings"), Custom String(
			"Pioneer Time Limit in Seconds"), 180, 30, 420, 0);
		Global.SkipTimeLimit = Workshop Setting Integer(Custom String("Important Settings"), Custom String(
			"Seconds Before Player Can Skip Level"), 240, 60, 9999, 0);
		Global.ReplaysEnabledConstant = Workshop Setting Toggle(Custom String("Experimental"), Custom String(
			"Enable Pioneer Replays (Can cause large server load)"), True, 0);
		Global.UltimateAbilitiesEnabledConstant = Workshop Setting Toggle(Custom String("Gameplay"), Custom String(
			"Ultimate Abilites Enabled"), False, 0);
		Global.PunchGraceEnabled = Workshop Setting Toggle(Custom String("Gameplay"), Custom String("Punch Grace Enabled"), True, 0);
		Global.SlamBuffEnabled = Workshop Setting Toggle(Custom String("Gameplay"), Custom String("Slam Buff Enabled (Slam resets bhop)"),
			False, 0);
		Global.NonInfiniteModeWinTime = Workshop Setting Integer(Custom String("Infinite Mode"), Custom String(
			"Time Limit Before Victory in Non-Infinite Mode"), 300, 90, 1200, 0);
		"Set up workshop toggle/int/real variables"
		Global.InfiniteModeEnabledConstant = Workshop Setting Toggle(Custom String("Infinite Mode"), Custom String(
			"Infinite Mode Enabled"), True, 0);
		Global.CPRadius = Workshop Setting Real(Custom String("Game Constants"), Custom String("Checkpoint Radius (m)"), 2, 0, 20, 0);
		Global.MultiHeroEnabled = Workshop Setting Toggle(Custom String("Gameplay"), Custom String("Multi-Hero Mode Enabled"), False, 0);
		Global.PlayerMoveSpeedConstant = Workshop Setting Real(Custom String("Game Constants"), Custom String(
			"Player Move Speed Scale Factor"), 100, 10, 1000, 0);
		Global.PioneerMinDistanceConstant = 6;
		Global.PrimaryFireUsefulForTheseHeros = Array(Hero(Ana));
		Global.GameStarted = False;
		Global.GreenSphereRadiusConstant = Workshop Setting Real(Custom String("Game Constants"), Custom String(
			"Environmental Collision Sphere Radius"), 3.500, 1, 5, 0);
		Global.EffectLockSphereRadiusConstant = Workshop Setting Real(Custom String("Game Constants"), Custom String(
			"Effect Lock (White) Sphere Radius"), 2, 1, 5, 0);
		Global.DevModeEngaged = False;
		Global.ReplayPioneerPositionArray = Empty Array;
		Global.ReplayPioneerFacingArray = Empty Array;
		Global.DisableHUDConstant = Workshop Setting Toggle(Custom String("Other"), Custom String("Disable HUD"), False, 9);
		"Green Sphere Create Pioneer Only"
		Create Effect(Filtered Array(Global.CurrentPioneer, Current Array Element.GreenSphereLocation != Null), Sphere, Color(Green),
			Global.CurrentPioneer.GreenSphereLocation, Global.GreenSphereRadiusConstant, Visible To Position and Radius);
		"Kill Sphere Create Pioneer Only"
		Create Effect(Filtered Array(Global.CurrentPioneer, Current Array Element.KillSphereLocation != Null), Sphere, Color(Red),
			Global.CurrentPioneer.KillSphereLocation, Global.GreenSphereRadiusConstant, Visible To Position and Radius);
		Global.EffectLocksOrderMatters = Workshop Setting Toggle(Custom String("Important Settings"), Custom String(
			"Effect Locks Must Be Obtained In Pioneer Order"), True, 9);
	}
}

rule("Global HUD + Controls HUD + General Effects / Icons")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.DisableHUDConstant == False;
	}

	actions
	{
		"Only show pioneer info to players within 1-2 CP's of final CP"
		Create HUD Text(Filtered Array(All Players(All Teams),
			Global.GameStarted && Global.CurrentPioneer != Null && Current Array Element.CurrentCP + 2 >= Count Of(Global.CPLocations)),
			Custom String("Pioneer: {0}\r\nTime: {1}", Global.CurrentPioneer != Null ? Global.CurrentPioneer : Custom String("None"),
			Global.PioneerTimer), Null, Null, Left, -1, Color(White), Color(White), Color(White), Visible To and String,
			Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Global.GameStarted == False), Custom String(
			"{0} Press R to Create Origin Point!", Host Player), Null, Null, Top, 0, Color(Green), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Create HUD Text(Host Player, Null, Null, Custom String("Server Load {0} | Avg {1} | Peak {2}", Server Load, Server Load Average,
			Server Load Peak), Right, -1, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Living Players(All Teams), !Is Button Held(Current Array Element, Button(Interact))), Null,
			Null, Custom String("Hold {0} For Controls / Game Settings\r\nNeed Healing | Checkpoint Help", Input Binding String(Button(
			Interact))), Left, -1, Color(White), Color(White), Color(Red), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("Workshop Code: YMVCR"), Right, -2, Color(White), Color(White),
			Color(White), Visible To, Default Visibility);
		"Create HUD showing abilities the pioneer has used"
		disabled Create HUD Text(Global.CurrentPioneer, Custom String("Abilty Counts\r\n{0} {1} {2}", Custom String("{0} {1}", Ability Icon String(
			Hero Of(Global.CurrentPioneer), Button(Secondary Fire)), X Component Of(Global.CurrentPioneer.CPAbilityCounts)), Custom String(
			"{0} {1}", Ability Icon String(Hero Of(Global.CurrentPioneer), Button(Ability 1)), Y Component Of(
			Global.CurrentPioneer.CPAbilityCounts)), Custom String("{0} {1}", Ability Icon String(Hero Of(Global.CurrentPioneer), Button(
			Ability 2)), Z Component Of(Global.CurrentPioneer.CPAbilityCounts))), Null, Null, Top, -1.400, Color(Blue), Color(White),
			Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Is Button Held(Current Array Element, Button(Interact))), Null, Null,
			Custom String("{0} | Quick Reset\r\n{1} +\r\n{2}", Input Binding String(Button(Reload)), Input Binding String(Button(
			Interact)), Custom String("{0}\r\n{1}\r\n{2}", Custom String(
			"    +  {0}  | Preview Next Checkpoint (Look at effect lock to view location)\r\n    +  {1}  | Spectate", Input Binding String(
			Button(Primary Fire)), Input Binding String(Button(Melee))), Custom String(
			"    +  {0}  | Skip CP (After {1}sec)\r\n    +  {2}  | Previous CP", Input Binding String(Button(Jump)), Global.SkipTimeLimit,
			Input Binding String(Button(Crouch))), Custom String("{0}", Custom String(
			"{0}  +  {1}  | Toggle Invisiblity\r\nNeed Healing/Help | Replay Pioneer Route", Input Binding String(Button(Jump)),
			Input Binding String(Button(Crouch)))))), Left, 0, Color(White), Color(White), Color(White), Visible To and String,
			Visible Never);
		Create HUD Text(Filtered Array(All Players(All Teams), Is Button Held(Current Array Element, Button(Interact))), Null, Null,
			Custom String(" \r\n- - - - - - - - - - - Pioneer Controls - - - - - - - - - - -\r\n{0}\r\n{1}\r\n", Custom String(
			"{0} | Create Effect Lock\r\n{1} | Create Env. Collision Sphere\r\nGroup Up | Create Kill Sphere", Input Binding String(Button(
			Melee)), Input Binding String(Button(Crouch))), Custom String(
			"{0}  +  {1}  | Reset Sphere Effects\r\n     +  Up/Down  | Change Size\r\n     +  Ult Status  | Hero Switch Menu\r\n{2}",
			Input Binding String(Button(Interact)), Input Binding String(Button(Reload)), Custom String("{0}  +  {1}  | Teleport",
			Input Binding String(Button(Primary Fire)), Input Binding String(Button(Melee))))), Left, 1, Color(White), Color(White), Color(
			White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Is Button Held(Current Array Element, Button(Interact))), Null, Null,
			Custom String(
			"- - - - - - - - - - - - - - - - - - - - - -Host Controls- - - - - - - - - - - - - - - - - - - - - -\r\n{0}\r\n{1}\r\n{2}",
			Custom String("{0} + Hello | Dev Mode (Players Can Skip Levels)\r\n{1} + Emote + Dev Mode On | Delete Last CP",
			Input Binding String(Button(Interact)), Input Binding String(Button(Melee))), Custom String(
			" \r\nLobby-> Settings-> Workshop Settings: Update Game Constants"), Custom String(" \r\n{0}\r\n{1}", Custom String(
			"Save Map:\r\n1. Open Workshop Inspector, set \"variable target\" to Global\r\n2. Press button [X] on bottom to copy all variables"),
			Custom String(
			"3. Open Workshop Editor, open first rule & paste. \r\nDelete the two \"ReplayPioneer\" variables (giant arrays)"))), Right, 2,
			Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		"Updated to use the \"Local Player\" functionality - Surprisingly it appears to add server load, rather than reduce it."
		Create HUD Text(All Living Players(All Teams), Null, Null, Custom String("Checkpoint {0}/{1} - Time Spent On CP {2}",
			Local Player.CurrentCP, Count Of(Global.CPLocations) - 1, Local Player.TimeSpentOnCP), Top, 0, Color(White), Color(White),
			Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Living Players(All Teams),
			Global.AbilityCountsEnabledConstant && Current Array Element.CurrentCP + 1 < Count Of(Global.CPLocations)), Custom String(
			"Checkpoint Abilty Limits\r\n{0} {1} {2}", Custom String("{0} {1}", Ability Icon String(Hero Of(Local Player), Button(
			Secondary Fire)), X Component Of(Local Player.AbilityLimitsDisplayVar)), Custom String("{0} {1}", Ability Icon String(Hero Of(
			Local Player), Button(Ability 1)), Y Component Of(Local Player.AbilityLimitsDisplayVar)), Custom String("{0} {1}",
			Ability Icon String(Hero Of(Local Player), Button(Ability 2)), Z Component Of(Local Player.AbilityLimitsDisplayVar))), Null,
			Null, Top, -1.400, Color(Blue), Color(White), Color(White), Visible To and String, Default Visibility);
		Create Icon(Filtered Array(All Living Players(All Teams), Count Of(Global.CPLocations) > Current Array Element.CurrentCP + 1),
			Global.CPLocations[Local Player.CurrentCP + 1] + Up, Flag, Visible To and Position, Color(Yellow), True);
		Create In-World Text(Filtered Array(All Living Players(All Teams), Count Of(Global.CPLocations)
			> Current Array Element.CurrentCP + 1), Custom String("Come Here\r\nPioneer: {0}",
			Global.PioneerList[Local Player.CurrentCP + 1]), Global.CPLocations[Local Player.CurrentCP + 1] + Up, 1.300, Do Not Clip,
			Visible To Position and String, Color(Yellow), Default Visibility);
		"Effect lock icon over CP (before getting all locks) - similar to hax framework"
		Create In-World Text(Filtered Array(All Living Players(All Teams), Count Of(
			Global.CPEffectLockSphereArray[Current Array Element.CurrentCP]) > 0 && Count Of(Current Array Element.EffectLockObtained)
			< Count Of(Global.CPEffectLockSphereArray[Current Array Element.CurrentCP])), Custom String("{0}", Ability Icon String(Hero(
			Winston), Button(Ability 2))), Global.CPLocations[Local Player.CurrentCP + 1], 1.300, Clip Against Surfaces,
			Visible To and Position, Color(White), Default Visibility);
	}
}

rule("Initialize player + Ring Effects")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Event Player.PlayerScale = 1;
		"Punch grace from Hax framework"
		Chase Player Variable At Rate(Event Player, Grace, Is Firing Secondary(Event Player) ? 0.500 : False, Is Firing Secondary(
			Event Player) ? 0.260 : True, Destination and Rate);
		Event Player.CurrentCP = 0;
		Event Player.BlockArriveNextPoint = False;
		Set Status(Event Player, Null, Phased Out, 9999);
		Event Player.BlockPioneerNewPoint = False;
		Event Player.CancelPointTimer = 0;
		Event Player.TeleportEnabled = True;
		Enable Death Spectate All Players(Event Player);
		Enable Death Spectate Target HUD(Event Player);
		Disable Game Mode In-World UI(Event Player);
		Disable Game Mode HUD(Event Player);
		Event Player.TimeSpentOnCP = 0;
		Event Player.Invisible = True;
		Set Invisible(Event Player, All);
		Event Player.BlockPioneerPass = False;
		Chase Player Variable At Rate(Event Player, EffectLockTimerChase, 0, 1, None);
		"Create Ring Effects"
		Create Effect(Event Player, Ring, Color(White), Global.CPLocations[Event Player.CurrentCP], Global.CPRadius,
			Visible To Position and Radius);
		Create Effect(Filtered Array(Event Player, Count Of(Global.CPLocations) > Current Array Element.CurrentCP + 1), Ring, Color(
			Purple), Global.CPLocations[Event Player.CurrentCP + 1], Global.CPRadius, Visible To Position and Radius);
	}
}

rule("Player-Specific HUD")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.DisableHUDConstant == False;
	}

	actions
	{
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} {1}", Evaluate Once(Event Player),
			Event Player.MaxUnlockedCP), Right, 100 - Event Player.MaxUnlockedCP, Color(White), Color(White), Color(Green),
			Visible To and String, Default Visibility);
		disabled Create In-World Text(Filtered Array(Event Player, Count Of(Global.CPLocations) > Current Array Element.CurrentCP + 1),
			Custom String("Come Here\r\nPioneer: {0}", Global.PioneerList[Event Player.CurrentCP + 1]),
			Global.CPLocations[Event Player.CurrentCP + 1] + Up, 1.300, Do Not Clip, Visible To Position and String, Color(Yellow),
			Default Visibility);
		"Effect lock icon over CP (before getting all locks) - similar to hax framework"
		disabled Create In-World Text(Filtered Array(Event Player, Count Of(Global.CPEffectLockSphereArray[Current Array Element.CurrentCP])
			> 0 && Count Of(Current Array Element.EffectLockObtained) < Count Of(
			Global.CPEffectLockSphereArray[Current Array Element.CurrentCP])), Custom String("{0}", Ability Icon String(Hero(Winston),
			Button(Ability 2))), Global.CPLocations[Event Player.CurrentCP + 1], 1.300, Clip Against Surfaces, Visible To and Position,
			Color(White), Default Visibility);
		disabled Create Icon(Filtered Array(Event Player, Count Of(Global.CPLocations) > Event Player.CurrentCP + 1),
			Global.CPLocations[Event Player.CurrentCP + 1] + Up, Flag, Visible To and Position, Color(Yellow), True);
		disabled Create HUD Text(Filtered Array(Event Player, Global.GameStarted), Null, Null, Custom String(
			"Checkpoint {0}/{1} - Time Spent On CP {2}", Event Player.CurrentCP, Count Of(Global.CPLocations) - 1,
			Event Player.TimeSpentOnCP), Top, 0, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		disabled Create HUD Text(Filtered Array(Event Player, Global.AbilityCountsEnabledConstant && Current Array Element.CurrentCP + 1 < Count Of(
			Global.CPLocations)), Custom String("Checkpoint Abilty Limits\r\n{0} {1} {2}", Custom String("{0} {1}", Ability Icon String(
			Hero Of(Event Player), Button(Secondary Fire)), X Component Of(Event Player.AbilityLimitsDisplayVar)), Custom String("{0} {1}",
			Ability Icon String(Hero Of(Event Player), Button(Ability 1)), Y Component Of(Event Player.AbilityLimitsDisplayVar)),
			Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Ability 2)), Z Component Of(
			Event Player.AbilityLimitsDisplayVar))), Null, Null, Top, -1.400, Color(Blue), Color(White), Color(White),
			Visible To and String, Default Visibility);
	}
}

disabled rule("Game Framework")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Create Origin Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player == Host Player;
		Global.GameStarted == False;
		Is On Ground(Event Player) == True;
		Has Spawned(Event Player) == True;
		Is Button Held(Event Player, Button(Reload)) == True;
	}

	actions
	{
		Small Message(All Players(All Teams), Custom String("Creating origin point"));
		Global.CPLocations = Array(Position Of(Event Player));
		Global.CPAbilityCounts = Empty Array;
		Global.CPUltimateTeleportPrimary = Empty Array;
		Global.CPFacingDirections = Empty Array;
		Global.PioneerList = Array(Custom String("{0}", Event Player));
		Global.CurrentPioneer = Event Player;
		Global.GameStarted = True;
		Global.CPHeroList = Array();
		Global.CPGreenSphereArray = Empty Array;
		Global.CPEffectLockSphereArray = Empty Array;
		Global.CPKillSphereArray = Empty Array;
		Global.ReplayPioneerPositionArray = Empty Array;
		Global.ReplayPioneerFacingArray = Empty Array;
		Global.CPPlayerScaleArray = Empty Array;
		Global.EffectLockAbilitiesArray = Empty Array;
	}
}

rule("Game Started (origin point just created by host) - Create World Effects")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.GameStarted == True;
	}

	actions
	{
		"Restart player at origin point after it's created and start timer"
		Call Subroutine(RespawnPlayer);
		Call Subroutine(HandleSkipTimer);
	}
}

rule("Pioneer Create Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Is On Ground(Event Player) == True;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius;
		disabled Distance Between(Global.CPLocations[Event Player.CurrentCP + 1], Position Of(Event Player)) <= Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
		Event Player.BlockPioneerNewPoint == False;
		"Can't pioneer in spectate mode"
		Event Player.SpectateMode == False;
		"Punch grace from Hax framework"
		(!Global.PunchGraceEnabled || Is Firing Secondary(Event Player) || Event Player.Grace < 0.120) == True;
		"Slam Buff"
		!(Global.SlamBuffEnabled && Is Using Ability 2(Event Player) && True) == True;
		"Winston Leap Bhop Fix"
		(Hero Of(Event Player) != Hero(Winston) || Event Player.WinstonLeapGrace <= 0) == True;
	}

	actions
	{
		"Make sure they pioneered far enough"
		If(Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentCP]) < Global.PioneerMinDistanceConstant);
			Small Message(Event Player, Custom String("Pioneer more than {0}m!", Global.PioneerMinDistanceConstant));
			Call Subroutine(RespawnPlayer);
			Abort;
		End;
		Event Player.BlockPioneerPass = True;
		Play Effect(Event Player, Ring Explosion Sound, Color(White), Event Player, 60);
		Event Player.TempVariable2 = Position Of(Event Player);
		Start Forcing Player Position(Event Player, Evaluate Once(Event Player.TempVariable2), True);
		"Allow player 3 sec to cancel the CP"
		Event Player.CancelPointTimer = 3;
		Chase Player Variable At Rate(Event Player, CancelPointTimer, 0, 1, Destination and Rate);
		If(!Global.DisableHUDConstant);
			Create Progress Bar HUD Text(Event Player, Event Player.CancelPointTimer / 0.030, Custom String(
				"Press R within {0} sec to cancel checkpoint", Event Player.CancelPointTimer), Top, 0, Color(White), Color(Red),
				Visible To and Values, Visible Never);
			Event Player.MenuTextIDTempStore = Last Text ID;
		End;
		"Wait for player to cancel point with R, or let the CP complete"
		Wait Until(Is Button Held(Event Player, Button(Reload)), 3);
		If(Event Player.CancelPointTimer > 0);
			Stop Forcing Player Position(Event Player);
			Call Subroutine(RespawnPlayer);
			Destroy Progress Bar HUD Text(Event Player.MenuTextIDTempStore);
			Event Player.BlockPioneerPass = False;
			Abort;
		End;
		Stop Forcing Player Position(Event Player);
		Destroy Progress Bar HUD Text(Event Player.MenuTextIDTempStore);
		"Hopefully tempvariable doesn't conflict with \"Pioneer runs out of time\" rule"
		For Player Variable(Event Player, TempVariable, 0, Count Of(All Living Players(All Teams)), 1);
			If(All Living Players(All Teams)[Event Player.TempVariable].CurrentCP == Count Of(Global.CPLocations) - 1);
				All Living Players(All Teams)[Event Player.TempVariable].ForceRespawn = True;
			End;
		End;
		"Create the next point"
		Event Player.BlockArriveNextPoint = True;
		Modify Global Variable(CPLocations, Append To Array, Event Player.TempVariable2);
		Modify Global Variable(PioneerList, Append To Array, Custom String("{0}", Event Player));
		Modify Global Variable(CPAbilityCounts, Append To Array, Event Player.CPAbilityCounts);
		Modify Global Variable(CPUltimateTeleportPrimary, Append To Array, Event Player.CountUltimateTeleportPrimary);
		Modify Global Variable(CPHeroList, Append To Array, Hero Of(Event Player));
		Modify Global Variable(CPGreenSphereArray, Append To Array, Event Player.GreenSphereLocation);
		Modify Global Variable(CPKillSphereArray, Append To Array, Event Player.KillSphereLocation);
		"Don't allow effect locks on teleport points"
		If(Y Component Of(Event Player.CountUltimateTeleportPrimary) > 0);
			Event Player.EffectLockSphereLocation = Empty Array;
		End;
		Global.CPEffectLockSphereArray[Count Of(Global.CPEffectLockSphereArray)] = Event Player.EffectLockSphereLocation;
		Global.ReplayPioneerPositionArray[Event Player.CurrentCP] = Event Player.ReplayPosition;
		Global.EffectLockAbilitiesArray[Count Of(Global.EffectLockAbilitiesArray)] = Event Player.AbilitiesForEffectLock;
		Global.ReplayPioneerFacingArray[Event Player.CurrentCP] = Event Player.ReplayFacing;
		Event Player.FacingDirectionLeavingCP = Global.CPFacingDirections[Event Player.CurrentCP];
		Modify Global Variable(CPPlayerScaleArray, Append To Array, Event Player.PlayerScale);
		Call Subroutine(RespawnPlayer);
		Event Player.BlockArriveNextPoint = False;
		Event Player.TimeSpentOnCP = 0;
		Chase Player Variable At Rate(Event Player, TimeSpentOnCP, 9999, 1, Destination and Rate);
		Global.CurrentPioneer = Null;
		Enable Inspector Recording;
		Log To Inspector(Custom String("Created Checkpoint {0}", Count Of(Global.CPLocations)));
		Disable Inspector Recording;
		Call Subroutine(CreateEffectLocks);
		Event Player.BlockPioneerPass = False;
	}
}

rule("Non-Pioneer Respawn If Touch Ground Outside of current or next CP")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Is On Ground(Event Player) == True;
		Event Player.BlockArriveNextPoint == False;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius;
		Distance Between(Global.CPLocations[Event Player.CurrentCP + 1], Position Of(Event Player)) > Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
		"Punch grace from Hax framework"
		(!Global.PunchGraceEnabled || Is Firing Secondary(Event Player) || Event Player.Grace < 0.120) == True;
		"Slam Buff"
		!(Global.SlamBuffEnabled && Is Using Ability 2(Event Player) && True) == True;
		"Winston Leap Bhop Fix"
		(Hero Of(Event Player) != Hero(Winston) || Event Player.WinstonLeapGrace <= 0) == True;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Non-Pioneer Arrive At CP")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Is On Ground(Event Player) == True;
		Event Player.BlockArriveNextPoint == False;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius;
		Distance Between(Global.CPLocations[Event Player.CurrentCP + 1], Position Of(Event Player)) <= Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
		Count Of(Global.CPLocations) > Event Player.CurrentCP + 1;
	}

	actions
	{
		"Check if player got effect lock obtained, if they haven't respawn them"
		If(Count Of(Event Player.EffectLockObtained) < Count Of(Global.CPEffectLockSphereArray[Event Player.CurrentCP]));
			Play Effect(Event Player, Debuff Impact Sound, Color(White), Event Player, 60);
			Small Message(Event Player, Custom String("Checkpoint requires you to get the effect lock!"));
			Call Subroutine(RespawnPlayer);
			Abort;
		End;
		Play Effect(Event Player, Buff Impact Sound, Color(White), Event Player, 60);
		Event Player.CurrentCP += 1;
		Event Player.MaxUnlockedCP = Max(Event Player.MaxUnlockedCP, Event Player.CurrentCP);
		If(Count Of(Global.CPLocations) == Event Player.CurrentCP + 1);
			If(Global.CurrentPioneer == Null);
				"So you can't pioneer your own point unless you are the only player alive (aka not spectating)"
				If(Count Of(Filtered Array(All Players(All Teams), !Is Dummy Bot(Current Array Element))) == 1 || Last Of(Global.PioneerList)
					!= Custom String("{0}", Event Player));
					If(!Global.DisableHUDConstant);
						Big Message(Event Player, Custom String("You are pioneer! Use your skills to make the next checkpoint!"));
					End;
					Global.CurrentPioneer = Event Player;
				End;
			End;
		End;
		Event Player.FacingDirectionLeavingCP = Global.CPFacingDirections[Event Player.CurrentCP];
		Call Subroutine(RespawnPlayer);
		Call Subroutine(HandleSkipTimer);
		Call Subroutine(CreateEffectLocks);
	}
}

rule("If player joins after origin point created, start them at origin point")
{
	event
	{
		Player Joined Match;
		All;
		All;
	}

	conditions
	{
		Global.GameStarted == True;
	}

	actions
	{
		Wait(0.100, Ignore Condition);
		Loop If(!Has Spawned(Event Player));
		Wait(0.100, Ignore Condition);
		Call Subroutine(HandleSkipTimer);
		Event Player.FacingDirectionLeavingCP = Global.CPFacingDirections[Event Player.CurrentCP];
		Call Subroutine(RespawnPlayer);
		Call Subroutine(CreateEffectLocks);
		Big Message(Event Player, Custom String("Press Interact ({0}) to see game controls", Input Binding String(Button(Interact))));
	}
}

rule("Handle ForceRespawn")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.ForceRespawn == True;
	}

	actions
	{
		Event Player.BlockPioneerNewPoint = True;
		"Hopefully to avoid the pioneer rule from still being executed while player \"HandleSkipTimer\" subroutine is running"
		Wait(0.200, Ignore Condition);
		Call Subroutine(RespawnPlayer);
		Event Player.ForceRespawn = False;
		Event Player.BlockPioneerNewPoint = False;
		Event Player.FacingDirectionLeavingCP = Global.CPFacingDirections[Event Player.CurrentCP];
		Call Subroutine(HandleSkipTimer);
	}
}

rule("Start Pioneer Timer and set Invisible when player becomes pioneer")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Global.PioneerTimer = Global.PioneerTimeLimitConstant;
		Chase Global Variable At Rate(PioneerTimer, 0, 1, Destination and Rate);
		Disallow Button(Event Player, Button(Melee));
		If(Hero Of(Event Player) != Hero(Wrecking Ball));
			Set Invisible(Event Player, All);
		End;
	}
}

rule("Set Non-Pioneer Visible")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Allow Button(Event Player, Button(Melee));
		If(Event Player.Invisible);
			Set Invisible(Event Player, All);
		Else;
			Set Invisible(Event Player, None);
		End;
	}
}

rule("Set Pioneer Timer to Zero if there isn't a pioneer")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.CurrentPioneer == Null;
	}

	actions
	{
		Global.PioneerTimer = 0;
	}
}

disabled rule("Other Features / Key Bindings")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Reload - Quick Reset")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Reload)) == True;
		disabled Is On Ground(Event Player) != True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
		"So player can't R and get teleported outside map before origin point is selected"
		Global.GameStarted == True;
		"Quick Reset Disabled for Ana, so you can reload - modify the array here for additional disable"
		disabled Index Of Array Value(Global.PrimaryFireUsefulForTheseHeros, Hero Of(Event Player)) < 0;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Crouch + Interact - Move Back A Checkpoint")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.BlockArriveNextPoint = True;
		If(Global.CurrentPioneer == Event Player);
			Small Message(Event Player, Custom String("Can't move back a level while pioneer! Make a checkpoint!"));
			Abort;
		End;
		If(Event Player.CurrentCP > 0);
			Event Player.CurrentCP += -1;
		Else;
			"If on Checkpoint 0, go to greatest unlocked checkpoint on level"
			Event Player.CurrentCP = Event Player.MaxUnlockedCP;
		End;
		Call Subroutine(HandleSkipTimer);
		Call Subroutine(RespawnPlayer);
		Event Player.BlockArriveNextPoint = False;
		Call Subroutine(CreateEffectLocks);
	}
}

rule("Interact + Left Click: Camera To See Next Point (or the effect lock sphere)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		"Make sure next point exists"
		Count Of(Global.CPLocations) > Event Player.CurrentCP + 1;
		"Is not pioneer"
		Global.CurrentPioneer != Event Player;
	}

	actions
	{
		Set Primary Fire Enabled(Event Player, False);
		Set Facing(Event Player, Vector(-10, -10, 0), To World);
		"Look at effect lock sphere if it exists and is within 10 degrees of where the player is looking when pressing left click + interact. Otherwise look at next CP"
		If(Global.CPEffectLockSphereArray[Event Player.CurrentCP] != Empty Array && Is True For Any(
			Global.CPEffectLockSphereArray[Event Player.CurrentCP], Angle Between Vectors(Direction Towards(Eye Position(Event Player),
			Current Array Element), Facing Direction Of(Event Player)) < 10) && Angle Between Vectors(Facing Direction Of(Event Player),
			Direction Towards(Eye Position(Event Player), Global.CPLocations[Event Player.CurrentCP + 1])) > 10);
			Event Player.TempVariable2 = First Of(Sorted Array(Global.CPEffectLockSphereArray[Event Player.CurrentCP], Angle Between Vectors(
				Direction Towards(Eye Position(Event Player), Current Array Element), Facing Direction Of(Event Player))));
			Start Camera(Event Player, Ray Cast Hit Position(Event Player.TempVariable2, Event Player.TempVariable2 + Facing Direction Of(
				Event Player) * -15, All Players(All Teams), Event Player, True), Event Player.TempVariable2, 30);
		Else;
			Start Camera(Event Player, Ray Cast Hit Position(Global.CPLocations[Event Player.CurrentCP + 1],
				Global.CPLocations[Event Player.CurrentCP + 1] + Facing Direction Of(Event Player) * -15, All Players(All Teams), Event Player,
				True), Global.CPLocations[Event Player.CurrentCP + 1], 30);
		End;
		Wait Until(!(Is Button Held(Event Player, Button(Primary Fire)) && Is Button Held(Event Player, Button(Interact))), 20);
		Stop Camera(Event Player);
		Set Primary Fire Enabled(Event Player, True);
		Set Facing(Event Player, Global.CPFacingDirections[Event Player.CurrentCP], To World);
	}
}

rule("Interact + Jump -> Skip Checkpoint")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		If(Global.CurrentPioneer == Event Player);
			Small Message(Event Player, Custom String("Can't change level while pioneer! Make a checkpoint!"));
			Abort;
		End;
		"If player is not on last unlocked CP"
		If(Event Player.CurrentCP < Event Player.MaxUnlockedCP);
			Event Player.CurrentCP += 1;
		Else;
			If((Global.DevModeEngaged || Event Player.TimeSpentOnCP > Global.SkipTimeLimit) && Event Player.CurrentCP + 1 < Count Of(
				Global.CPLocations));
				Event Player.CurrentCP += 1;
				Event Player.MaxUnlockedCP = Event Player.CurrentCP;
				Event Player.BlockArriveNextPoint = True;
				Call Subroutine(RespawnPlayer);
				"Allow player to pioneer using CP skip"
				If(Count Of(Global.CPLocations) == Event Player.CurrentCP + 1);
					If(Global.CurrentPioneer == Null);
						Big Message(Event Player, Custom String("You are pioneer! Use your skills to make the next checkpoint!"));
						Global.CurrentPioneer = Event Player;
					End;
				End;
				Event Player.BlockArriveNextPoint = False;
				Call Subroutine(HandleSkipTimer);
				Call Subroutine(CreateEffectLocks);
				Abort;
			Else;
				"If haven't unlocked next CP yet, go back to CP 0"
				Event Player.CurrentCP = 0;
			End;
		End;
		Call Subroutine(HandleSkipTimer);
		Call Subroutine(RespawnPlayer);
		Call Subroutine(CreateEffectLocks);
	}
}

rule("Interact + Melee : Spectate Other Players")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Melee)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
	}

	actions
	{
		Enable Death Spectate All Players(All Players(All Teams));
		If(Is Dead(Event Player));
			Enable Built-In Game Mode Respawning(Event Player);
			Resurrect(Event Player);
			Wait(0.100, Ignore Condition);
			Call Subroutine(RespawnPlayer);
			Event Player.SpectateMode = False;
		Else;
			Big Message(Event Player, Custom String("Use \"Interact + Melee\" to exit Spectate Mode!"));
			Event Player.SpectateMode = True;
			Disable Built-In Game Mode Respawning(Event Player);
			Kill(Event Player, Null);
		End;
		Set Status(Event Player, Null, Phased Out, 9999);
	}
}

rule("Melee + Left Click = Teleport")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Is Button Held(Event Player, Button(Melee)) == True;
		(Event Player.TeleportEnabled || Global.DevModeEngaged) == True;
	}

	actions
	{
		Teleport(Event Player, Ray Cast Hit Position(Position Of(Event Player), Position Of(Event Player) + Facing Direction Of(
			Event Player) * 60, All Players(All Teams), Event Player, True));
		Event Player.CountUltimateTeleportPrimary += Up;
	}
}

rule("Interact + Hello Voiceline = Dev Mode Engaged")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player == Host Player;
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Communicating(Event Player, Hello) == True;
	}

	actions
	{
		"Right now Dev Mode lets all players teleport and skip any points with zero time using jump + interact"
		disabled Wait(0.250, Ignore Condition);
		If(Global.DevModeEngaged);
			Small Message(All Players(All Teams), Custom String("Dev Mode Disengaged"));
			Global.DevModeEngaged = False;
		Else;
			Small Message(All Players(All Teams), Custom String("Dev Mode Engaged"));
			Global.DevModeEngaged = True;
		End;
	}
}

rule("Crouch + Jump: Toggle Invisiblity")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) == True;
		Is Button Held(Event Player, Button(Crouch)) == True;
		Global.CurrentPioneer != Event Player;
	}

	actions
	{
		If(Event Player.Invisible);
			Set Invisible(Event Player, None);
			Small Message(Event Player, Custom String("Visible"));
		Else;
			Small Message(Event Player, Custom String("Invisible"));
			Set Invisible(Event Player, All);
		End;
		Event Player.Invisible = !Event Player.Invisible;
	}
}

rule("Interact + Ultimate Status Voiceline = Pioneer can switch hero")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		disabled Is Button Held(Event Player, Button(Jump)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
		"Is pioneer or is waiting for pioneer"
		(Global.CurrentPioneer == Event Player || Count Of(Global.CPLocations) == Event Player.CurrentCP + 1) == True;
		Global.MultiHeroEnabled == True;
		Is Communicating(Event Player, Ultimate Status) == True;
	}

	actions
	{
		"If a menu is already open, delete the in world text and recreate the menu in the proper location"
		If(Event Player.HeroSelectMenuOpen);
			For Player Variable(Event Player, TempIterator, 0, Count Of(Event Player.MenuTextIDTempStore), 1);
				Destroy In-World Text(Event Player.MenuTextIDTempStore[Event Player.TempIterator]);
				Abort;
			End;
		End;
		Event Player.MenuInWorldLocationTempStore = Empty Array;
		Event Player.MenuTextIDTempStore = Empty Array;
		For Player Variable(Event Player, TempIterator, 0, Count Of(Global.HeroRoster), 1);
			Modify Player Variable(Event Player, MenuInWorldLocationTempStore, Append To Array, Eye Position(Event Player)
				+ Facing Direction Of(Event Player) * 1 + 0.400 * World Vector Of(Vector(Sine From Degrees(360 * (
				Event Player.TempIterator / Count Of(Global.HeroRoster))), Cosine From Degrees(360 * (Event Player.TempIterator / Count Of(
				Global.HeroRoster))), 0), Event Player, Rotation));
			Create In-World Text(Event Player, Custom String("{0}", Hero Icon String(Global.HeroRoster[Event Player.TempIterator])),
				Event Player.MenuInWorldLocationTempStore[Event Player.TempIterator] + Vector(0, -0.100, 0), 3, Do Not Clip, None, Color(
				White), Default Visibility);
			Modify Player Variable(Event Player, MenuTextIDTempStore, Append To Array, Last Text ID);
			Wait(0.016, Ignore Condition);
		End;
		Event Player.HeroSelectMenuOpen = True;
		Big Message(Event Player, Custom String("Release Interact Over The Hero You Want To Select"));
	}
}

rule("Close Hero Select Menu When Player Stops Holding Interact")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == False;
		Has Spawned(Event Player) == True;
		Event Player.HeroSelectMenuOpen == True;
	}

	actions
	{
		Start Forcing Player To Be Hero(Event Player, Global.HeroRoster[Index Of Array Value(Event Player.MenuInWorldLocationTempStore,
			First Of(Sorted Array(Event Player.MenuInWorldLocationTempStore, Angle Between Vectors(Facing Direction Of(Event Player),
			Direction Towards(Eye Position(Event Player), Current Array Element)))))]);
		For Player Variable(Event Player, TempIterator, 0, Count Of(Event Player.MenuTextIDTempStore), 1);
			Destroy In-World Text(Event Player.MenuTextIDTempStore[Event Player.TempIterator]);
		End;
		If(Hero Of(Event Player) == Hero(Wrecking Ball));
			Set Invisible(Event Player, None);
		End;
		Event Player.HeroSelectMenuOpen = False;
	}
}

rule("Interact + Up/Down to increase/decrease pioneer player size")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Player is pioneer or waiting for pioneer"
		Event Player.CurrentCP + 1 == Count Of(Global.CPLocations);
		Is Button Held(Event Player, Button(Interact)) == True;
		Absolute Value(Z Component Of(Throttle Of(Event Player))) == 1;
		Is On Ground(Event Player) == True;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) < Global.CPRadius;
		Global.GameStarted == True;
	}

	actions
	{
		"Cycle through allowed player scales"
		Event Player.PlayerScale = Global.AllowedPlayerScalesArray[(Index Of Array Value(Global.AllowedPlayerScalesArray,
			Event Player.PlayerScale) + Z Component Of(Throttle Of(Event Player))) % Count Of(Global.AllowedPlayerScalesArray)];
		Call Subroutine(UpdatePlayerScale);
		Wait(0.100, Ignore Condition);
		Small Message(Event Player, Custom String("Setting player scale to {0}", Event Player.PlayerScale));
	}
}

rule("Melee + Emote + Dev Mode Engaged: Delete Last Checkpoint")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player == Host Player;
		Global.DevModeEngaged == True;
		Is Button Held(Event Player, Button(Melee)) == True;
		Is Communicating Any Emote(Event Player) == True;
		"Cant delete the origin point"
		Count Of(Global.CPLocations) > 1;
	}

	actions
	{
		Small Message(All Players(All Teams), Custom String("Deleting last checkpoint"));
		"Hopefully tempvariable doesn't conflict with \"Pioneer runs out of time\" rule"
		For Player Variable(Event Player, TempVariable, 0, Count Of(All Living Players(All Teams)), 1);
			If(All Living Players(All Teams)[Event Player.TempVariable].CurrentCP == Count Of(Global.CPLocations) - 1);
				All Living Players(All Teams)[Event Player.TempVariable].CurrentCP = Count Of(Global.CPLocations) - 2;
				All Living Players(All Teams)[Event Player.TempVariable].ForceRespawn = True;
			End;
		End;
		Wait(0.250, Ignore Condition);
		Global.PioneerTimer = Global.PioneerTimeLimitConstant;
		Global.CurrentPioneer = First Of(Filtered Array(All Players(All Teams), Custom String("{0}", Current Array Element) == Last Of(
			Global.PioneerList)));
		Modify Global Variable(CPLocations, Remove From Array By Index, Count Of(Global.CPLocations) - 1);
		Modify Global Variable(PioneerList, Remove From Array By Index, Count Of(Global.PioneerList) - 1);
		Modify Global Variable(CPAbilityCounts, Remove From Array By Index, Count Of(Global.CPAbilityCounts) - 1);
		Modify Global Variable(CPUltimateTeleportPrimary, Remove From Array By Index, Count Of(Global.CPUltimateTeleportPrimary) - 1);
		Modify Global Variable(CPHeroList, Remove From Array By Index, Count Of(Global.CPHeroList) - 1);
		Modify Global Variable(CPGreenSphereArray, Remove From Array By Index, Count Of(Global.CPGreenSphereArray) - 1);
		Modify Global Variable(CPKillSphereArray, Remove From Array By Index, Count Of(Global.CPKillSphereArray) - 1);
		Modify Global Variable(CPEffectLockSphereArray, Remove From Array By Index, Count Of(Global.CPEffectLockSphereArray) - 1);
		Modify Global Variable(ReplayPioneerPositionArray, Remove From Array By Index, Count Of(Global.ReplayPioneerPositionArray) - 1);
		Modify Global Variable(EffectLockAbilitiesArray, Remove From Array By Index, Count Of(Global.EffectLockAbilitiesArray) - 1);
		Modify Global Variable(ReplayPioneerFacingArray, Remove From Array By Index, Count Of(Global.ReplayPioneerFacingArray) - 1);
		Modify Global Variable(CPFacingDirections, Remove From Array By Index, Count Of(Global.CPFacingDirections) - 1);
		Modify Global Variable(CPPlayerScaleArray, Remove From Array By Index, Count Of(Global.CPPlayerScaleArray) - 1);
		"Hopefully tempvariable doesn't conflict with \"Pioneer runs out of time\" rule"
		For Player Variable(Event Player, TempVariable, 0, Count Of(All Living Players(All Teams)), 1);
			If(All Living Players(All Teams)[Event Player.TempVariable].CurrentCP == Count Of(Global.CPLocations) - 1);
				All Living Players(All Teams)[Event Player.TempVariable].ForceRespawn = True;
			End;
		End;
		"Hopefully tempvariable doesn't conflict with \"Pioneer runs out of time\" rule"
		For Player Variable(Event Player, TempVariable, 0, Count Of(All Players(All Teams)), 1);
			If(All Players(All Teams)[Event Player.TempVariable].CurrentCP == Count Of(Global.CPLocations) - 1);
				All Players(All Teams)[Event Player.TempVariable].MaxUnlockedCP = Count Of(Global.CPLocations) - 1;
			End;
		End;
		Event Player.TimeSpentOnCP = 0;
		Call Subroutine(CreateEffectLocks);
		Call Subroutine(HandleSkipTimer);
		Call Subroutine(CheckAbilityCounts);
		Enable Inspector Recording;
		Log To Inspector(Custom String("Removed Checkpoint {0}", Count Of(Global.CPLocations) + 1));
		Disable Inspector Recording;
	}
}

rule("Interact + Ultimate: Start again from checkpoint 0 (disabled when Ultimates are enabled in Workshop Settings)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Button Held(Event Player, Button(Ultimate)) == True;
		Global.UltimateAbilitiesEnabledConstant == False;
		Global.CurrentPioneer != Event Player;
	}

	actions
	{
		Event Player.CurrentCP = 0;
		Call Subroutine(RespawnPlayer);
		Call Subroutine(HandleSkipTimer);
		Call Subroutine(CreateEffectLocks);
	}
}

disabled rule("Replay Saving / Watching Code")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Pioneer Save Replay")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		"Has left starting CP or is using an ability"
		(Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius || Is Firing Secondary(
			Event Player) || Is Using Ability 1(Event Player) || Is Using Ability 2(Event Player) || Is Using Ultimate(Event Player))
			== True;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
		Event Player.CancelPointTimer == 0;
		Global.ReplaysEnabledConstant == True;
	}

	actions
	{
		Modify Player Variable(Event Player, ReplayPosition, Append To Array, Eye Position(Event Player));
		Modify Player Variable(Event Player, ReplayFacing, Append To Array, Facing Direction Of(Event Player));
		Wait(Speed Of(Event Player) <= 2.750 ? 0.480 : 0.160, Ignore Condition);
		Loop If Condition Is True;
		Modify Player Variable(Event Player, ReplayPosition, Append To Array, Eye Position(Event Player));
		Modify Player Variable(Event Player, ReplayFacing, Append To Array, Facing Direction Of(Event Player));
	}
}

rule("Need Healing/Help: View Replay")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Is Communicating(Event Player, Need Healing) || Is Communicating(Event Player, Need Help)) == True;
	}

	actions
	{
		If(!Global.ReplaysEnabledConstant);
			Small Message(Event Player, Custom String("Replays Disabled (Host Can Turn It On In Workshop Settings)"));
			Abort;
		End;
		If(Global.ReplayPioneerPositionArray[Event Player.CurrentCP] == Null);
			Small Message(Event Player, Custom String(
				"Pioneer replay not saved for this CP (saving CP's in workshop rules can exceed workshop size limit)"));
			Abort;
		End;
		Start Camera(Event Player, Global.ReplayPioneerPositionArray[Event Player.CurrentCP][Event Player.TempIterator],
			Global.ReplayPioneerPositionArray[Event Player.CurrentCP][Event Player.TempIterator] + Global.ReplayPioneerFacingArray[Event Player.CurrentCP][Event Player.TempIterator],
			30);
		Create Progress Bar HUD Text(Event Player, 100 * ((Event Player.TempIterator + 1) / Count Of(
			Global.ReplayPioneerPositionArray[Event Player.CurrentCP])), Custom String("Press R to cancel replay"), Top, 5, Color(White),
			Color(White), Values, Default Visibility);
		"This can POTENTIALLY conflict with the pioneering of a point location variable"
		Event Player.TempVariable2 = Last Text ID;
		For Player Variable(Event Player, TempIterator, 0, Count Of(Global.ReplayPioneerPositionArray[Event Player.CurrentCP]) - 1, 1);
			Wait(0.100, Ignore Condition);
			If(Is Button Held(Event Player, Button(Reload)));
				Stop Camera(Event Player);
				Destroy Progress Bar HUD Text(Event Player.TempVariable2);
				Abort;
			End;
		End;
		Wait(0.500, Ignore Condition);
		Stop Camera(Event Player);
		Destroy Progress Bar HUD Text(Event Player.TempVariable2);
	}
}

disabled rule("Handle Ability Counts")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Handle Ability Count Limits (if enabled)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.AbilityCountsEnabledConstant == True;
		(Is Using Ability 1(Event Player) || Is Using Ability 2(Event Player) || Is Firing Secondary(Event Player)) == True;
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations);
		Global.GameStarted == True;
	}

	actions
	{
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
		Call Subroutine(CheckAbilityCounts);
	}
}

rule("Used Primary Fire (If Ana)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ana;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
		"Don't trigger if player has complete point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.CountUltimateTeleportPrimary += Forward;
	}
}

rule("Used Ultimate")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		"Don't trigger if player has complete point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.CountUltimateTeleportPrimary += Left;
	}
}

rule("Used Secondary (Rocket Punch)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
		"Don't trigger if player has complete point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.Grace = 0.119;
		If(Event Player.EffectLockSphereLocation == Empty Array);
			Event Player.CPAbilityCounts += Left;
		Else;
			Event Player.AbilitiesForEffectLock[Count Of(Event Player.AbilitiesForEffectLock) - 1] += Left;
		End;
	}
}

rule("Used Ability 1 (Uppercut)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
		"Don't trigger if player has complete point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		If(Event Player.EffectLockSphereLocation == Empty Array);
			Event Player.CPAbilityCounts += Up;
		Else;
			Event Player.AbilitiesForEffectLock[Count Of(Event Player.AbilitiesForEffectLock) - 1] += Up;
		End;
	}
}

rule("Used Ability 2 - NON DOOMFIST")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		Event Player.CancelPointTimer == 0;
		Hero Of(Event Player) != Hero(Doomfist);
	}

	actions
	{
		If(Event Player.EffectLockSphereLocation == Empty Array);
			Event Player.CPAbilityCounts += Forward;
		Else;
			Event Player.AbilitiesForEffectLock[Count Of(Event Player.AbilitiesForEffectLock) - 1] += Forward;
		End;
	}
}

rule("Used Ability 2 - Start Slam Timer")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		"Don't trigger if player has complete point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.SlamTimer = 0;
		Chase Player Variable At Rate(Event Player, SlamTimer, 99, 1, Destination and Rate);
	}
}

rule("Used Ability 2 + 125 Slam Detector")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == False;
		Has Spawned(Event Player) == True;
		"To stop this rule from double triggering"
		Event Player.SlamTimer > 0;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, SlamTimer);
		Event Player.SlamTimer = 0;
	}
}

rule("Increment Slam Counter")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		"Prevents invalid slam (where player presses slam button but can't slam) from being counted"
		((Is On Ground(Event Player) && Event Player.SlamTimer > 0.040 && Event Player.SlamTimer < 0.250) || (
			Event Player.SlamTimer > 0.250) || (Global.CurrentPioneer == Event Player && True)) == True;
		Has Spawned(Event Player) == True;
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		If(Event Player.EffectLockSphereLocation == Empty Array);
			Event Player.CPAbilityCounts += Forward;
		Else;
			Event Player.AbilitiesForEffectLock[Count Of(Event Player.AbilitiesForEffectLock) - 1] += Forward;
		End;
		If(Is On Ground(Event Player));
			Stop Chasing Player Variable(Event Player, SlamTimer);
			Event Player.SlamTimer = 0;
		End;
	}
}

disabled rule("125 Slam Detection")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		"Actual time is 1.53 for 125 slam + cancel, but removing cancel ~.3 sec"
		Event Player.SlamTimer >= 1.220;
		Is Using Ability 2(Event Player) == True;
		"To prevent player from just holding down slam at invalid slam angle to get a 125 slam"
		Is Button Held(Event Player, Button(Ability 2)) == False;
	}

	actions
	{
		Event Player.Count360Slam125 += Up;
		disabled Small Message(Event Player, Custom String("125 Slam"));
		disabled Play Effect(Event Player, Buff Impact Sound, Color(White), Event Player, 60);
	}
}

disabled rule("Handle Edge Cases")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Reset Cooldowns If In Starting CP Ring")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) < Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
		(Ability Cooldown(Event Player, Button(Secondary Fire)) > 0 || Ability Cooldown(Event Player, Button(Ability 1))
			> 0 || Ability Cooldown(Event Player, Button(Ability 2)) > 0) == True;
		(Is Using Ability 1(Event Player) || Is Using Ability 2(Event Player) || Is Firing Secondary(Event Player)) == False;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		"if u charge punch, then jump and land in circle, it takes your punch away "
		disabled Event Player.CPAbilityCounts = Vector(0, 0, 0);
		Event Player.CountUltimateTeleportPrimary = Vector(0, 0, 0);
	}
}

rule("Declare Winner If Not Infinite Mode")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.InfiniteModeEnabledConstant == False;
		Count Of(Global.CPLocations) > 30;
	}

	actions
	{
		Wait(1, Ignore Condition);
		Declare Player Victory(Global.CurrentPioneer);
		Declare Team Victory(Team 1);
	}
}

rule("Handle Player Death")
{
	event
	{
		Player Died;
		All;
		All;
	}

	conditions
	{
		Event Player.SpectateMode != True;
	}

	actions
	{
		Event Player.BlockPioneerNewPoint = True;
		"In case you die during 3 seconds after pioneering"
		If(Event Player.CancelPointTimer > 0);
			Wait(3, Ignore Condition);
		End;
		Respawn(Event Player);
		Wait(0.100, Ignore Condition);
		If(Global.GameStarted);
			Call Subroutine(RespawnPlayer);
			Wait(0.100, Ignore Condition);
		End;
		Clear Status(Event Player, Phased Out);
		Set Status(Event Player, Null, Phased Out, 9999);
		Event Player.BlockPioneerNewPoint = False;
	}
}

rule("Save CP Facing Direction when leaving the CP (for both pioneer and non-pioneer)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		disabled Global.CurrentPioneer == Event Player;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		If(Global.CurrentPioneer == Event Player);
			Global.CPFacingDirections[Event Player.CurrentCP] = Facing Direction Of(Event Player);
		End;
		Event Player.FacingDirectionLeavingCP = Facing Direction Of(Event Player);
	}
}

rule("Pioneer runs out of time")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.PioneerTimer == 0;
		Has Spawned(Event Player) == True;
		Global.CurrentPioneer == Event Player;
		Event Player.BlockPioneerPass == False;
	}

	actions
	{
		Wait(0.100, Abort When False);
		Event Player.BlockPioneerNewPoint = True;
		Wait(0.100, Ignore Condition);
		"Is there a player on final checkpoint waiting for pioneer"
		If(Count Of(Filtered Array(All Players(All Teams), Global.CurrentPioneer != Current Array Element && Count Of(Global.CPLocations)
			== Current Array Element.CurrentCP + 1)) > 0);
			Event Player.TempVariable = Random Value In Array(Filtered Array(All Players(All Teams),
				Global.CurrentPioneer != Current Array Element && Count Of(Global.CPLocations) == Current Array Element.CurrentCP + 1));
			Global.PioneerTimer = Global.PioneerTimeLimitConstant;
			Event Player.TempVariable.BlockPioneerNewPoint = True;
			Event Player.TempVariable.ForceRespawn = True;
			"Hopefully to avoid the pioneer rule from still being executed while player \"HandleSkipTimer\" subroutine is running"
			Wait(0.200, Ignore Condition);
			Global.CurrentPioneer = Event Player.TempVariable;
			Wait(0.100, Ignore Condition);
			Event Player.TempVariable.BlockPioneerNewPoint = False;
			Big Message(All Players(All Teams), Custom String("Pioneer ran out of time. Pioneer passed to {0}", Global.CurrentPioneer));
		Else;
			Global.PioneerTimer = Global.PioneerTimeLimitConstant;
			Big Message(All Players(All Teams), Custom String("No one to pass pioneer to"));
		End;
		Event Player.BlockPioneerNewPoint = False;
	}
}

rule("Pioneer Left Match")
{
	event
	{
		Player Left Match;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Null;
	}

	actions
	{
		Event Player.BlockPioneerNewPoint = True;
		"Pioneer is not in game"
		If(Count Of(Filtered Array(All Players(All Teams), Current Array Element == Global.CurrentPioneer)) == 0);
			"Is there a player on final checkpoint waiting for pioneer"
			If(Count Of(Filtered Array(All Players(All Teams), True && Count Of(Global.CPLocations) == Current Array Element.CurrentCP + 1))
				> 0);
				Event Player.TempVariable = Random Value In Array(Filtered Array(All Players(All Teams), Count Of(Global.CPLocations)
					== Current Array Element.CurrentCP + 1));
				Global.PioneerTimer = Global.PioneerTimeLimitConstant;
				Event Player.TempVariable.ForceRespawn = True;
				Global.CurrentPioneer = Event Player.TempVariable;
				Wait(0.100, Ignore Condition);
				Big Message(All Players(All Teams), Custom String("Pioneer ran out of time. Pioneer passed to {0}", Global.CurrentPioneer));
			End;
		End;
		Event Player.BlockPioneerNewPoint = False;
	}
}

rule("Handle Memory Recall")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"To make sure this rule executes after global initialize"
		Wait(0.500, Ignore Condition);
		Call Subroutine(MemoryRecall);
		"If something in memory"
		If(Count Of(Global.CPLocations) > 0);
			Global.GameStarted = True;
			Global.UsingMemoryRecall = True;
			"In case dev mode was on when vars were saved"
			Global.DevModeEngaged = False;
			"If pioneer replays were deleted (most likely to be true), initialize replays to be arrays of NULL"
			If(Count Of(Global.CPLocations) != Count Of(Global.ReplayPioneerPositionArray) || Count Of(Global.CPLocations) != Count Of(
				Global.ReplayPioneerFacingArray));
				"I think this should initialize whole array to NULL"
				Global.ReplayPioneerPositionArray[Count Of(Global.CPLocations) - 1] = Null;
				"I think this should initialize whole array to NULL"
				Global.ReplayPioneerFacingArray[Count Of(Global.CPLocations) - 1] = Null;
			End;
			Enable Inspector Recording;
			Log To Inspector(Custom String("Memory Recall Initialize Snapshot"));
			Disable Inspector Recording;
		Else;
			Global.UsingMemoryRecall = False;
		End;
	}
}

disabled rule("Subroutines")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Sub0: RespawnPlayer")
{
	event
	{
		Subroutine;
		RespawnPlayer;
	}

	actions
	{
		Stop Holding Button(Event Player, Button(Secondary Fire));
		Teleport(Event Player, Global.CPLocations[Event Player.CurrentCP]);
		If(Is Button Held(Event Player, Button(Interact)));
			Event Player.FacingDirectionLeavingCP = Global.CPFacingDirections[Event Player.CurrentCP];
		End;
		Set Facing(Event Player, Event Player.FacingDirectionLeavingCP, To World);
		"If player is not pioneer and is not waiting for pioneer"
		If(Count Of(Global.CPLocations) > Event Player.CurrentCP + 1);
			Start Forcing Player To Be Hero(Event Player, Global.CPHeroList[Event Player.CurrentCP]);
		End;
		"Sigma Barrier Reset"
		If(Hero Of(Event Player) == Hero(Sigma));
			If(Event Player.sigma_barrier_ready_to_destroy);
				Press Button(Event Player, Button(Secondary Fire));
			End;
			Event Player.sigma_barrier_ON = False;
			Event Player.sigma_barrier_ready_to_destroy = False;
		End;
		Event Player.PunchFixStore = Hero Of(Event Player) == Hero(Doomfist) && Is Button Held(Event Player, Button(Secondary Fire));
		Cancel Primary Action(Event Player);
		Call Subroutine(CancelMomentum);
		Event Player.CPAbilityCounts = Vector(0, 0, 0);
		Event Player.CountUltimateTeleportPrimary = Vector(0, 0, 0);
		"Added this to fix issue where if you pressed R while using slam, the slam cooldown wasn't reset"
		Wait(0.100, Ignore Condition);
		Stop Chasing Player Variable(Event Player, SlamTimer);
		Event Player.SlamTimer = 0;
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Set Ultimate Charge(Event Player, 100);
		Event Player.CancelPointTimer = 0;
		"If player is not pioneer, player is not waiting for pioneer"
		If(Count Of(Global.CPLocations) > Event Player.CurrentCP + 1);
			If(X Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]) == 0);
				Set Secondary Fire Enabled(Event Player, False);
			Else;
				Set Secondary Fire Enabled(Event Player, True);
			End;
			If(Hero Of(Event Player) == Hero(Ana));
				Set Secondary Fire Enabled(Event Player, True);
			End;
			If(Y Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]) == 0);
				Set Ability 1 Enabled(Event Player, False);
			Else;
				Set Ability 1 Enabled(Event Player, True);
			End;
			If(Z Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]) == 0);
				Set Ability 2 Enabled(Event Player, False);
			Else;
				Set Ability 2 Enabled(Event Player, True);
			End;
			If(X Component Of(Global.CPUltimateTeleportPrimary[Event Player.CurrentCP]) == 0);
				Set Ultimate Ability Enabled(Event Player, False);
			Else;
				Set Ultimate Ability Enabled(Event Player, True);
			End;
			If(Y Component Of(Global.CPUltimateTeleportPrimary[Event Player.CurrentCP]) == 0);
				Event Player.TeleportEnabled = False;
			Else;
				Event Player.TeleportEnabled = True;
				If(Event Player.CurrentCP > 0);
					Big Message(Event Player, Custom String("Teleport enabled for this point! Use Left Click + Melee to teleport!"));
				End;
			End;
			If(Index Of Array Value(Global.PrimaryFireUsefulForTheseHeros, Hero Of(Event Player)) >= 0);
				If(Z Component Of(Global.CPUltimateTeleportPrimary[Event Player.CurrentCP]) == 0);
					Set Primary Fire Enabled(Event Player, False);
				Else;
					Set Primary Fire Enabled(Event Player, True);
				End;
			End;
			Event Player.PlayerScale = Global.CPPlayerScaleArray[Event Player.CurrentCP];
			Call Subroutine(UpdatePlayerScale);
		"Is beginning of match, or player is pioneer, or player is waiting for pioneer"
		Else;
			Set Secondary Fire Enabled(Event Player, True);
			Set Ability 1 Enabled(Event Player, True);
			Set Ability 2 Enabled(Event Player, True);
			Event Player.TeleportEnabled = True;
			Set Primary Fire Enabled(Event Player, True);
			Set Ultimate Ability Enabled(Event Player, Global.UltimateAbilitiesEnabledConstant);
		End;
		Event Player.WinstonBouncyBubbleCooldown = 0;
		Destroy Effect(Event Player.WinstonBubbleEffect);
		Event Player.WinstonBubbleLocation = Null;
		"Should Fix Phased Out Status issue"
		Clear Status(Event Player, Phased Out);
		Set Status(Event Player, Null, Phased Out, 9999);
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Set Ability Cooldown(Event Player, Button(Crouch), 0);
		Set Move Speed(Event Player, Global.PlayerMoveSpeedConstant);
		If(Event Player.PunchFixStore && Hero Of(Event Player) == Hero(Doomfist) && Is Button Held(Event Player, Button(Secondary Fire)));
			Start Holding Button(Event Player, Button(Secondary Fire));
		End;
		If(Hero Of(Event Player) == Hero(Junkrat));
			Set Ability Charge(Event Player, Button(Ability 1), 2);
		End;
		Enable Movement Collision With Environment(Event Player);
		"Don't reset env collision / kill sphere locations if you're the pioneer"
		If(Global.CurrentPioneer != Event Player || (Is Button Held(Event Player, Button(Interact)) && Is Button Held(Event Player, Button(
			Reload))));
			Event Player.GreenSphereLocation = Null;
			Event Player.KillSphereLocation = Null;
		End;
		Event Player.WinstonWallClimbEnabled = True;
		Event Player.ReplayPosition = Empty Array;
		Event Player.ReplayFacing = Empty Array;
		Set Gravity(Event Player, 100);
		Event Player.EffectLockSphereLocation = Empty Array;
		Event Player.EffectLockObtained = Empty Array;
		Event Player.AbilitiesForEffectLock = Empty Array;
		Event Player.AbilityLimitsDisplayVar = Global.CPAbilityCounts[Event Player.CurrentCP];
	}
}

rule("Sub2: CancelMomentum")
{
	event
	{
		Subroutine;
		CancelMomentum;
	}

	actions
	{
		Apply Impulse(Event Player, Up, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Down, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Left, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Right, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Forward, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Backward, 0.001, To World, Cancel Contrary Motion);
	}
}

rule("Sub3: HandleSkipTimer")
{
	event
	{
		Subroutine;
		HandleSkipTimer;
	}

	actions
	{
		Wait(0.200, Ignore Condition);
		"If Player is pioneer or waiting for pioneer"
		If(Count Of(Global.CPLocations) == Event Player.CurrentCP + 1 || False);
			Stop Chasing Player Variable(Event Player, TimeSpentOnCP);
			Event Player.TimeSpentOnCP = 0;
		Else;
			Event Player.TimeSpentOnCP = 0;
			Chase Player Variable At Rate(Event Player, TimeSpentOnCP, 9999, 1, Destination and Rate);
		End;
	}
}

rule("Sub5: Update Player Scale")
{
	event
	{
		Subroutine;
		UpdatePlayerScale;
	}

	actions
	{
		Start Scaling Player(Event Player, Event Player.PlayerScale, False);
		If(Event Player.PlayerScale < 0.700);
			Start Modifying Hero Voice Lines(Event Player, 4, False);
		Else If(Event Player.PlayerScale > 1.500);
			Start Modifying Hero Voice Lines(Event Player, 0.650, False);
		Else;
			Start Modifying Hero Voice Lines(Event Player, 1, False);
		End;
	}
}

rule("Sub6: CheckAbilityCounts")
{
	event
	{
		Subroutine;
		CheckAbilityCounts;
	}

	actions
	{
		If(Count Of(Event Player.EffectLockObtained) > 0);
			Event Player.AbilityLimitsDisplayVar = Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Last Of(
				Event Player.EffectLockObtained)] - Event Player.CPAbilityCounts;
			"Round the Z component (it gets set to a non-integer to tell game to cancel slam when you hit that orb, but don't display the 0.9, just round it)"
			Event Player.AbilityLimitsDisplayVar = Vector(X Component Of(Event Player.AbilityLimitsDisplayVar), Y Component Of(
				Event Player.AbilityLimitsDisplayVar), Round To Integer(Z Component Of(Event Player.AbilityLimitsDisplayVar), Up));
			If(Y Component Of(Event Player.CPAbilityCounts) >= Y Component Of(Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Last Of(
				Event Player.EffectLockObtained)]));
				Wait Until(!Is Using Ability 1(Event Player), 1);
				Set Ability 1 Enabled(Event Player, False);
			Else;
				Set Ability 1 Enabled(Event Player, True);
			End;
			If(Z Component Of(Event Player.CPAbilityCounts) >= Z Component Of(Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Last Of(
				Event Player.EffectLockObtained)]));
				Wait Until(!Is Using Ability 2(Event Player), 5);
				Skip If(Z Component Of(Event Player.CPAbilityCounts) < Z Component Of(
					Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Last Of(Event Player.EffectLockObtained)]), 1);
				Set Ability 2 Enabled(Event Player, False);
			Else;
				Set Ability 2 Enabled(Event Player, True);
			End;
			If(X Component Of(Event Player.CPAbilityCounts) >= X Component Of(Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Last Of(
				Event Player.EffectLockObtained)]));
				"Have to wait to disable punch because otherwise it would disable immediately after using, stopping the punch from continuing."
				Wait(Event Player.Grace, Ignore Condition);
				"This is to fix interaction with the Quick Reset (R) right after using punch, so this doesn't disable punch after you respawn"
				Abort If(True && Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentCP]) < Global.CPRadius);
				"So that you can punch through an effect lock without losing momentum"
				Abort If(Event Player.EffectLockTimerChase > 0 && X Component Of(Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Last Of(
					Event Player.EffectLockObtained)]) > 0);
				Set Secondary Fire Enabled(Event Player, False);
			Else;
				Set Secondary Fire Enabled(Event Player, True);
			End;
		Else;
			If(Y Component Of(Event Player.CPAbilityCounts) >= Y Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]));
				Set Ability 1 Enabled(Event Player, False);
			End;
			If(Z Component Of(Event Player.CPAbilityCounts) >= Z Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]));
				Set Ability 2 Enabled(Event Player, False);
			End;
			If(X Component Of(Event Player.CPAbilityCounts) >= X Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]));
				"Have to wait to disable punch because otherwise it would disable immediately after using preventing punch from working properly."
				Wait(0.800, Ignore Condition);
				"This is to fix interaction with the Quick Reset (R) right after using punch, so this doesn't disable punch after you respawn. Can have slight bug where player is punching through the start location, and doesn't set cooldown properly."
				Abort If(True && Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentCP]) < Global.CPRadius);
				"Adding this to fix issue of starting punch going through an effect lock that also allows punch. Otherwise, the effect lock would enable punch, then this rule would disable it!"
				Abort If(Event Player.EffectLockTimerChase > 0);
				Set Secondary Fire Enabled(Event Player, False);
			End;
			Event Player.AbilityLimitsDisplayVar = Global.CPAbilityCounts[Event Player.CurrentCP] - Event Player.CPAbilityCounts;
		End;
	}
}

rule("Sub7: Create Effect Locks and Env / Kill spheres")
{
	event
	{
		Subroutine;
		CreateEffectLocks;
	}

	actions
	{
		For Player Variable(Event Player, TempIterator, 0, Count Of(Event Player.TempMenuIDStore), 1);
			Destroy Effect(Event Player.TempMenuIDStore[Event Player.TempIterator]);
			Destroy In-World Text(Event Player.TextIDTempStore[Event Player.TempIterator]);
		End;
		Event Player.TempMenuIDStore = Empty Array;
		Event Player.TextIDTempStore = Empty Array;
		If(Global.CurrentPioneer == Event Player);
			Abort;
		End;
		For Player Variable(Event Player, TempIterator, 0, Count Of(Global.CPEffectLockSphereArray[Event Player.CurrentCP]), 1);
			"Effect Lock Sphere Create Non-Pioneer"
			Create Effect(Filtered Array(Event Player, Index Of Array Value(Current Array Element.EffectLockObtained, Evaluate Once(
				Event Player.TempIterator)) == -1), Sphere, Custom Color(192, 192, 192, 192), Evaluate Once(
				Global.CPEffectLockSphereArray[Event Player.CurrentCP][Event Player.TempIterator]), Evaluate Once(
				Global.EffectLockSphereRadiusConstant + -1), Visible To);
			Modify Player Variable(Event Player, TempMenuIDStore, Append To Array, Last Created Entity);
			Create In-World Text(Filtered Array(Event Player, Index Of Array Value(Current Array Element.EffectLockObtained, Evaluate Once(
				Event Player.TempIterator)) == -1), Custom String("{0} {1}", Custom String("{0}{1}{2}", X Component Of(
				Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Evaluate Once(Event Player.TempIterator)]) > 0 ? Ability Icon String(
				Hero Of(Event Player), Button(Secondary Fire)) : String(""), Y Component Of(
				Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Evaluate Once(Event Player.TempIterator)]) > 0 ? Ability Icon String(
				Hero Of(Event Player), Button(Ability 1)) : String(""), Z Component Of(
				Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Evaluate Once(Event Player.TempIterator)]) > 0 ? Ability Icon String(
				Hero Of(Event Player), Button(Ability 2)) : String("")), Global.EffectLocksOrderMatters ? Custom String("#{0}",
				Event Player.TempIterator + 1) : String("")), Evaluate Once(
				Global.CPEffectLockSphereArray[Event Player.CurrentCP][Event Player.TempIterator]), 1.300, Do Not Clip, Visible To, Color(
				Yellow), Default Visibility);
			Modify Player Variable(Event Player, TextIDTempStore, Append To Array, Last Text ID);
			Wait(0.016, Ignore Condition);
		End;
		If(Global.CPGreenSphereArray[Event Player.CurrentCP] != Null);
			"Green Sphere Create"
			Create Effect(Event Player, Sphere, Color(Green), Global.CPGreenSphereArray[Event Player.CurrentCP],
				Global.GreenSphereRadiusConstant, None);
			Modify Player Variable(Event Player, TempMenuIDStore, Append To Array, Last Created Entity);
		End;
		If(Global.CPKillSphereArray[Event Player.CurrentCP] != Null);
			"Kill Sphere Create"
			Create Effect(Event Player, Sphere, Color(Red), Global.CPKillSphereArray[Event Player.CurrentCP], Global.GreenSphereRadiusConstant,
				None);
			Modify Player Variable(Event Player, TempMenuIDStore, Append To Array, Last Created Entity);
		End;
	}
}

disabled rule("Pioneer Effect Lock And Environment Collision Spheres + Player Scaling")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Pioneer Create Effect Lock Sphere with Melee")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Is Button Held(Event Player, Button(Melee)) == True;
		Event Player.CancelPointTimer == 0;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player))
			> Global.EffectLockSphereRadiusConstant * 2;
		"No effect lock created yet or distance to last effect lock > effect lock sphere radius"
		(Event Player.EffectLockSphereLocation == Empty Array || Is True For All(Event Player.EffectLockSphereLocation, Distance Between(
			Eye Position(Event Player), Current Array Element) > Global.EffectLockSphereRadiusConstant * 2)) == True;
	}

	actions
	{
		Modify Player Variable(Event Player, AbilitiesForEffectLock, Append To Array, Vector(0, 0, 0));
		Modify Player Variable(Event Player, EffectLockSphereLocation, Append To Array, Eye Position(Event Player));
		If(!Global.DisableHUDConstant);
			Small Message(Event Player, Custom String("Effect Lock Sphere Created!"));
		End;
		Play Effect(Event Player, Ring Explosion Sound, Color(White), Event Player, 60);
		"If player starts holding punch before creating effect lock, add punch to effect lock abilities"
		If(Hero Of(Event Player) == Hero(Doomfist) && Is Firing Secondary(Event Player));
			Event Player.AbilitiesForEffectLock[Count Of(Event Player.AbilitiesForEffectLock) - 1] += Left;
		End;
		If(Hero Of(Event Player) == Hero(Doomfist) && Is Using Ability 2(Event Player));
			If(Speed Of(Event Player) > 8);
				Cancel Primary Action(Event Player);
				Event Player.AbilitiesForEffectLock[Count Of(Event Player.AbilitiesForEffectLock) - 1] += Vector(0, 0, -0.100);
			End;
		End;
		"to stop pioneer from creating spheres too many in a row"
		Wait(0.250, Ignore Condition);
	}
}

rule("Obtain Effect Lock Sphere (Non-Pioneer)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Global.CPEffectLockSphereArray[Event Player.CurrentCP] != Empty Array;
		Is True For Any(Global.CPEffectLockSphereArray[Event Player.CurrentCP], Distance Between(Eye Position(Event Player),
			Current Array Element) <= Global.EffectLockSphereRadiusConstant && Index Of Array Value(Event Player.EffectLockObtained,
			Current Array Index) == -1) == True;
		Global.GameStarted == True;
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations);
	}

	actions
	{
		"Get index of this effect lock sphere"
		Event Player.TempVariable2 = Index Of Array Value(Global.CPEffectLockSphereArray[Event Player.CurrentCP], First Of(Filtered Array(
			Global.CPEffectLockSphereArray[Event Player.CurrentCP], Distance Between(Eye Position(Event Player), Current Array Element)
			< Global.EffectLockSphereRadiusConstant)));
		If(Global.EffectLocksOrderMatters && Count Of(Event Player.EffectLockObtained) != Event Player.TempVariable2);
			Small Message(Event Player, Custom String("Effect Locks Must Be Obtained In Order!"));
			Abort;
		End;
		Modify Player Variable(Event Player, EffectLockObtained, Append To Array, Event Player.TempVariable2);
		Play Effect(Event Player, Ring Explosion Sound, Color(White), Event Player, 60);
		If(!Global.DisableHUDConstant);
			Small Message(Event Player, Custom String("Effect Lock Obtained: {0} of {1}", Count Of(Event Player.EffectLockObtained), Count Of(
				Global.CPEffectLockSphereArray[Event Player.CurrentCP]), Event Player.TempVariable2));
		End;
		If(Hero Of(Event Player) == Hero(Doomfist) && Is Using Ability 2(Event Player));
			If(Round To Integer(Z Component Of(Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Event Player.TempVariable2]),
				To Nearest) != Z Component Of(Global.EffectLockAbilitiesArray[Event Player.CurrentCP][Event Player.TempVariable2]));
				Cancel Primary Action(Event Player);
			End;
		End;
		Event Player.CPAbilityCounts = Vector(0, 0, 0);
		Wait Until(!Is Using Ability 2(Event Player), 5);
		Event Player.EffectLockTimerChase = 0.800;
		Start Rule(CheckAbilityCounts, Restart Rule);
	}
}

rule("Pioneer Create Green Sphere with Crouch")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Is Button Held(Event Player, Button(Crouch)) == True;
		Hero Of(Event Player) != Hero(Wrecking Ball);
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		disabled Event Player.GreenSphereLocation = Eye Position(Event Player);
		Event Player.GreenSphereLocation = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 12, Null, Event Player, True);
	}
}

rule("Green Sphere Rule (Pioneer Only) - In Sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Event Player.GreenSphereLocation != Null;
		Distance Between(Eye Position(Event Player), Event Player.GreenSphereLocation) < Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Disable Movement Collision With Environment(Event Player, False);
	}
}

rule("Green Sphere Rule (Pioneer Only) - Outside Sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Event Player.GreenSphereLocation != Null;
		Distance Between(Eye Position(Event Player), Event Player.GreenSphereLocation) > Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Wait(0.250, Ignore Condition);
		Enable Movement Collision With Environment(Event Player);
	}
}

rule("Green Sphere Rule (Non-Pioneer) - In Sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Global.CPGreenSphereArray[Event Player.CurrentCP] != Null;
		Distance Between(Eye Position(Event Player), Global.CPGreenSphereArray[Event Player.CurrentCP]) < Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Disable Movement Collision With Environment(Event Player, False);
	}
}

rule("Green Sphere Rule (Non-Pioneer) - Outside Sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Global.CPGreenSphereArray[Event Player.CurrentCP] != Null;
		Distance Between(Eye Position(Event Player), Global.CPGreenSphereArray[Event Player.CurrentCP]) > Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Wait(0.250, Ignore Condition);
		Enable Movement Collision With Environment(Event Player);
	}
}

rule("Pioneer Create Kill Sphere With Group Up")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Is Communicating(Event Player, Group Up) == True;
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.KillSphereLocation = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 20, Null, Event Player, True);
		Small Message(Event Player, Custom String("Kill Sphere Created!"));
		Play Effect(Event Player, Buff Explosion Sound, Color(White), Event Player, 60);
	}
}

rule("Pioneer Respawns if in kill sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Event Player.KillSphereLocation != Null;
		Distance Between(Eye Position(Event Player), Event Player.KillSphereLocation) < Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
		Small Message(Event Player, Custom String("Avoid the red spheres!"));
	}
}

rule("Non-Pioneer Respawns if in Kill Sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Global.CPKillSphereArray[Event Player.CurrentCP] != Null;
		Distance Between(Eye Position(Event Player), Global.CPKillSphereArray[Event Player.CurrentCP]) < Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
		Small Message(Event Player, Custom String("Avoid the red spheres!"));
	}
}

disabled rule("Sigma Abilities")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Barrier {1}")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.sigma_barrier_ON = True;
		Event Player.sigma_barrier_init_position = Eye Position(Event Player) + Facing Direction Of(Event Player) * 3;
		Event Player.sigma_barrier_direction = Facing Direction Of(Event Player);
		Event Player.sigma_barrier_chase = 0;
		Chase Player Variable At Rate(Event Player, sigma_barrier_chase, Distance Between(Event Player.sigma_barrier_init_position,
			Ray Cast Hit Position(Event Player.sigma_barrier_init_position,
			Event Player.sigma_barrier_init_position + Event Player.sigma_barrier_direction * 200, Null, Event Player, False)), 16.500,
			Destination and Rate);
		"Updates barrier position"
		While(True);
			Event Player.sigma_barrier_position = Event Player.sigma_barrier_init_position + Event Player.sigma_barrier_direction * Event Player.sigma_barrier_chase;
			Wait(0.016, Ignore Condition);
			Abort If Condition Is False;
		End;
	}
}

rule("Barrier {2}")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == False;
		Event Player.sigma_barrier_ON == True;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, sigma_barrier_chase);
		Wait(0.192, Ignore Condition);
		Event Player.sigma_barrier_ready_to_destroy = True;
	}
}

rule("Barrier Launch")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Event Player.sigma_barrier_ON == True;
		Distance Between(Eye Position(Event Player), Event Player.sigma_barrier_position) < 3;
	}

	actions
	{
		"{Turns shield into a bouncepad instead when turned on}"
		disabled Event Player.sigma_barrier_direction = Vector(X Component Of(Event Player.sigma_barrier_direction), Absolute Value(Y Component Of(
			Event Player.sigma_barrier_direction)), Z Component Of(Event Player.sigma_barrier_direction));
		Apply Impulse(Event Player, Event Player.sigma_barrier_direction, 30, To World, Cancel Contrary Motion);
	}
}

rule("Remove Barrier")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Event Player.sigma_barrier_ready_to_destroy == True;
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
	}

	actions
	{
		Event Player.sigma_barrier_ON = False;
		Wait(0.016, Ignore Condition);
		Event Player.sigma_barrier_ready_to_destroy = False;
	}
}

rule("Destroy Pulse On Death")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Dead(Event Player) == True;
	}

	actions
	{
		Event Player.sigma_barrier_ON = False;
		Event Player.sigma_barrier_ready_to_destroy = False;
	}
}

rule("Vortex Drag {By default, using vortex makes you glide across the ground without resetting during the animation}")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Set Gravity(Event Player, 0);
		Set Move Speed(Event Player, Global.PlayerMoveSpeedConstant * 1.200);
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Wait Until(Is Button Held(Event Player, Button(Reload)), 2);
		Set Gravity(Event Player, 100);
		Set Move Speed(Event Player, Global.PlayerMoveSpeedConstant);
		Stop Forcing Throttle(Event Player);
	}
}

rule("Vortex Refresh")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Dead(Event Player) == True;
	}

	actions
	{
		Set Move Speed(Event Player, 100);
		Set Gravity(Event Player, 100);
	}
}

rule("Rock Booster")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		"Rock can be used during the vortex animation"
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Wait(0.650, Ignore Condition);
		Apply Impulse(Event Player, Facing Direction Of(Event Player), -14, To World, Cancel Contrary Motion);
	}
}

disabled rule("WINSTON STUFF")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Initialize Winston")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	actions
	{
		Event Player.WinstonBubbleLocation = Null;
	}
}

rule("Winston Leap Grace - Toggle On When Using Leap")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
		disabled Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius;
		disabled Distance Between(Global.CPLocations[Event Player.CurrentCP + 1], Position Of(Event Player)) > Global.CPRadius;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, WinstonLeapGrace);
		Event Player.WinstonLeapGrace = 0.250;
		disabled Chase Player Variable At Rate(Event Player, WinstonLeapGrace, 0, 1, Destination and Rate);
	}
}

rule("Winston Leap Grace - Set Grace Variable Chase When Touching Ground")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == False;
		Is On Ground(Event Player) == True;
	}

	actions
	{
		Chase Player Variable At Rate(Event Player, WinstonLeapGrace, 0, 1, Destination and Rate);
	}
}

rule("Create Bubble")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		"Place Bubble on ground below player. Easier for new players to figure out what's going on (compared to Ray Cast bubble position)."
		Event Player.WinstonBubbleLocation = Position Of(Event Player) + World Vector Of(Forward, Event Player, Rotation)
			* Horizontal Speed Of(Event Player) * 0.300 + Down * Altitude Of(Event Player);
		"Use Ray Cast to determine bubble position"
		disabled Event Player.WinstonBubbleLocation = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 160, All Players(All Teams), Event Player, False);
		If(Distance Between(Event Player.WinstonBubbleLocation, Position Of(Event Player)) > 100);
			Small Message(Event Player, Custom String("Barrier Cast Out Of Range (100m)"));
			Set Ability Cooldown(Event Player, Button(Ability 2), 0);
			Abort;
		End;
		Create Effect(Event Player, Sphere, Color(Blue), Event Player.WinstonBubbleLocation, 5, Visible To Position and Radius);
		Event Player.WinstonBubbleEffect = Last Created Entity;
		Event Player.WinstonBouncyBubbleCooldown = 9;
		Chase Player Variable At Rate(Event Player, WinstonBouncyBubbleCooldown, 0, 1, Destination and Rate);
		While(Event Player.WinstonBouncyBubbleCooldown > 0 && !Is Dead(Event Player));
			Wait(0.100, Ignore Condition);
		End;
		Destroy Effect(Event Player.WinstonBubbleEffect);
		Event Player.WinstonBubbleLocation = Null;
	}
}

rule("Winston Bubble Physics Rule")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Event Player.WinstonBubbleLocation != Null;
		Distance Between(Position Of(Event Player), Event Player.WinstonBubbleLocation) <= 5;
	}

	actions
	{
		"Direct Impulse - Cancel's Player Motion, so physically inaccurate bounce"
		Apply Impulse(Event Player, Direction Towards(Event Player.WinstonBubbleLocation, Position Of(Event Player)), Speed Of(
			Event Player) * 1.300, To World, Cancel Contrary Motion);
	}
}

rule("Winston Wall Climb")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) == True;
		"Make this so a player can't use wall climb multiple times in a row."
		Event Player.WinstonWallClimbEnabled == True;
	}

	actions
	{
		Event Player.WinstonWallClimbTimer = 4;
		"Set Wall Climb to have a max of 4 sec duration. This prevents you from wall climing against a roof/skybox for indefinite stall."
		Chase Player Variable Over Time(Event Player, WinstonWallClimbTimer, 0, 4, Destination and Duration);
		"Wall Climb while Jump is held, have been wall climbing less than 4 sec, are within 0.5m of wall"
		While(Is Button Held(Event Player, Button(Jump)) && Event Player.WinstonWallClimbTimer > 0 && Distance Between(
			Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + Direction From Angles(
			Horizontal Angle From Direction(Facing Direction Of(Event Player)), 0) * 10, All Players(All Teams), Event Player, True),
			Eye Position(Event Player)) < 3);
			Wait(0.033, Ignore Condition);
			Set Move Speed(Event Player, 0);
			Apply Impulse(Event Player, Up, 7, To World, Cancel Contrary Motion);
			Apply Impulse(Event Player, Forward, 1, To Player, Cancel Contrary Motion);
			Event Player.WinstonWallClimbEnabled = False;
		End;
		Set Move Speed(Event Player, 100);
		Wait(0.033, Ignore Condition);
		Loop If Condition Is True;
	}
}

disabled rule("ANA MODIFIERS")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Ana Primary Impulse")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ana;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
		Has Status(Event Player, Rooted) == False;
		disabled Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Set Gravity(Event Player, 0);
		Apply Impulse(Event Player, Facing Direction Of(Event Player), 15, To World, Cancel Contrary Motion);
		Wait(0.060, Ignore Condition);
		Set Gravity(Event Player, 100);
	}
}

rule("Ana Sleep Dart Teleport")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ana;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Stop Camera(Event Player);
		"The duration before Ana fires sleep dart"
		Wait(0.300, Ignore Condition);
		Event Player.AnaSleepDartTeleLocation = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 180, All Players(All Teams), Event Player, True);
		"Shorten ray cast to avoid unintended tele through surfaces"
		Event Player.AnaSleepDartTeleLocation -= Direction Towards(Eye Position(Event Player), Event Player.AnaSleepDartTeleLocation)
			* 0.500;
		"Need to find a better way to do skybox detection - this has issues on maps like Nepal that have high variance in altitude"
		If(Y Component Of(Event Player.AnaSleepDartTeleLocation) > 24);
			Small Message(Event Player, Custom String("Teleport location elevation too high"));
			Cancel Primary Action(Event Player);
			Wait(0.100, Ignore Condition);
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
			Abort;
		End;
		"Sleep dart travel time"
		Wait(Distance Between(Eye Position(Event Player), Event Player.AnaSleepDartTeleLocation) / 60, Ignore Condition);
		Teleport(Event Player, Event Player.AnaSleepDartTeleLocation);
		Call Subroutine(CancelMomentum);
		disabled Small Message(Event Player, Custom String("{0} alt {1}", Event Player.AnaSleepDartTeleLocation, Altitude Of(Event Player)));
	}
}

rule("Heal = Impulse {must be damaged when spawning}")
{
	event
	{
		Player Dealt Healing;
		All;
		Ana;
	}

	conditions
	{
		Healee == Healer;
		Has Status(Event Player, Rooted) == False;
	}

	actions
	{
		Apply Impulse(Event Player, Facing Direction Of(Event Player), -15, To World, Cancel Contrary Motion);
		Wait(1, Ignore Condition);
	}
}

rule("Ana Health Managment")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ana;
	}

	conditions
	{
		Normalized Health(Event Player) >= 1;
		Is In Spawn Room(Event Player) != True;
	}

	actions
	{
		Clear Status(Event Player, Phased Out);
		Damage(Event Player, Event Player, 50);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
		Set Status(Event Player, Null, Phased Out, 9999);
	}
}

disabled rule("ROADHOG STUFF")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Change Hook to Grappling Hook")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		"Initial impulse to let you hook in midair without falling too far while hook is out"
		Apply Impulse(Event Player, Up, 3, To World, Cancel Contrary Motion);
		"Issue here is that we are using ray cast to determine hook impact, which isn't visually accurate, so the hook may impact a wall but not be deteted."
		Event Player.RoadhogHookPosition = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ 120 * Facing Direction Of(Event Player), All Players(All Teams), Event Player, True);
		"Abort if hook didn't connect with a wall within 25m. For reference, 20m is hook range for normal roadhog."
		If(Distance Between(Position Of(Event Player), Event Player.RoadhogHookPosition) > 25);
			Small Message(Event Player, Custom String("Out of hook range!"));
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
			Abort;
		End;
		"Wait for hook to \"hit\" something. Hook moves at 40m/s"
		Wait(Distance Between(Position Of(Event Player), Event Player.RoadhogHookPosition) / 40, Ignore Condition);
		"Impulse that increases with hook range. Hook impulse = Base Impulse + Hook Range x Range Multiplier."
		Apply Impulse(Event Player, Direction Towards(Position Of(Event Player), Event Player.RoadhogHookPosition), 20 + Distance Between(
			Event Player.RoadhogHookPosition, Position Of(Event Player)) * 0.800, To World, Cancel Contrary Motion);
		"Large Linear Impulse. Disabled while testing impulse that increases with range."
		disabled Apply Impulse(Event Player, Direction Towards(Position Of(Event Player), Event Player.RoadhogHookPosition), 40, To World,
			Cancel Contrary Motion);
	}
}

rule("Change Take A Breather to Bouncy Ball Hog")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		disabled Is On Ground(Event Player) == True;
		Altitude Of(Event Player) <= 1.500;
	}

	actions
	{
		Apply Impulse(Event Player, Up, Speed Of(Event Player) * 1.200, To World, Cancel Contrary Motion);
	}
}

rule("Add Knockback When Secondary Fire Used")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Apply Impulse(Event Player, Facing Direction Of(Event Player), -12, To World, Cancel Contrary Motion);
	}
}