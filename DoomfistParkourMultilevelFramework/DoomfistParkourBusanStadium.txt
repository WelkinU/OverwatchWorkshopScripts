settings
{
	main
	{
		Description: "Doomfist Parkour Busan Stadium! MultiLevel Framework by WelkinTern. Make a Pull Request on the code repository: https://github.com/WelkinU/OverwatchWorkshopScripts/tree/master/DoomfistParkourMultilevelFramework"
	}

	lobby
	{
		Max Team 1 Players: 6
		Max Team 2 Players: 6
	}

	modes
	{
		disabled Assault
		{
			Hero Limit: Off
			Kill Cam: Off
			Kill Feed: Off
			Respawn Time Scalar: 10%
		}

		disabled Control
		{
			Hero Limit: Off
			Kill Cam: Off
			Kill Feed: Off
			Respawn Time Scalar: 10%
		}

		disabled Escort
		{
			Hero Limit: Off
			Kill Cam: Off
			Kill Feed: Off
			Respawn Time Scalar: 10%
		}

		disabled Hybrid
		{
			Hero Limit: Off
			Kill Cam: Off
			Kill Feed: Off
			Respawn Time Scalar: 10%
		}

		LÃºcioball
		{
			Game Length Seconds: 900
			Reset Players After Goal Scored: Off
			Score Lead Needed To Win: 100

			enabled maps
			{
				Busan Stadium
			}
		}

		disabled Skirmish
		{
			Hero Limit: Off
			Kill Cam: Off
			Kill Feed: Off
			Respawn Time Scalar: 10%
		}
	}

	heroes
	{
		General
		{
			Doomfist
			{
				Seismic Slam Cooldown Time: 66%
			}
		}
	}
}

variables
{
	global:
		0: CPLocations
		1: LevelNames
		2: CPFacing
		3: CPPunchUpperSlamCounts
		4: CPUltimate360MaxSlamCounts
		5: CPTeleport
		6: CPRadii
		7: LevelsWithLimitedAbilityCounts
		8: LevelOrigins
		9: TopScoreTimes
		10: TopScorePlayer
		11: TopScoreString
		12: AllScoreString
		14: LevelDescriptions
		15: DevModeEngaged
		17: CPRadius
		19: TempTeleport
		20: TempUltimate360MaxSlam
		21: TempRadii
		22: TempFacing
		24: CPIterator
		25: LevelIterator

	player:
		0: CurrentCP
		1: CurrentLevel
		3: LevelTimer
		4: PunchUpperSlamUsed
		5: FreeRoamEnabled
		7: TopPersonalScores
		9: SpectateMode
		14: SlamTimer
		15: BlockArriveAtNextPoint
		21: AllScoreboardString
		22: TopScoreboardString
		32: Array360
		33: Timer360
		34: Count360Slam125
		35: TempViewNextPointPosition
}

subroutines
{
	0: RespawnPlayer
	1: AutogenerateMapVariables
	2: OverrideAutogenVariables
	3: CancelMomentum
	4: OverrideVariablesUserInput
	5: UpdateTopScoreboard
}

rule("-------------UPDATE MAP CONSTANTS HERE - CHECKPOINTS, ABILITIES-------------")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"MAP MAKING INSTRUCTIONS\r\nStep 1: level checkpoints and abilities below\r\nStep 2: CP facing/radii/teleports/ultimates are autogenerated - override using the rule below this one"
		disabled Wait(0.250, Ignore Condition);
		"Default Checkpoint Radius"
		Global.CPRadius = 2;
		"Set level descriptions here, make sure the level number matches the index (ie. make sure Level 1 is on index 1)"
		Global.LevelNames = Array(Null, Custom String("Level 1"), Custom String("Level 2"), Custom String("Level 3"), Custom String(
			"Level 4"), Custom String("Level 5"), Custom String("Slam Only"), Custom String("Scoring Challenge"));
		Global.LevelDescriptions = Array(Null, Custom String("Speedrun"), Custom String("Medium"), Custom String("Hard"), Custom String(
			"Off Map"), Custom String("Very Hard"), Custom String("Speedrun"), Custom String("Get On Fire To Finish"));
		"Add to this array the level numbers of levels you want to have ability limits on"
		Global.LevelsWithLimitedAbilityCounts = Array();
		"Set the starting position when the player loads into the game"
		Global.CPLocations = Array(Array(Vector(4.158, 17.108, 0.007)));
		"Set the starting position abilities when the player loads into the game"
		Global.CPPunchUpperSlamCounts = Array(Array(Vector(1, 1, 1)));
		"--------------Set Level 1 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[1] = Array(Null, Vector(23.676, 12.613, -6.996), Vector(23.613, 12.613, 7.184), Vector(-23.588, 12.528, 6.870),
			Vector(6.168, 15.830, 13.441), Vector(-6.141, 15.820, -13.673), Vector(-23.776, 12.528, 6.874), Vector(14.113, 1.500, -12.221),
			Vector(-23.282, 12.528, -6.625), Vector(23.528, 12.613, 6.770), Vector(1.715, 18.359, 0.240), Vector(7.353, 26.006, 12.555),
			Vector(-6.808, 26.006, 13.180), Vector(-7.791, 26.007, -12.128), Vector(6.725, 26.006, 13.816));
		Global.CPPunchUpperSlamCounts[1] = Array(Null, Vector(0, 0, 1), Vector(1, 1, 1), Vector(0, 1, 1), Vector(1, 1, 1), Vector(1, 0, 0),
			Vector(1, 0, 1), Vector(1, 1, 1), Vector(1, 1, 1), Vector(1, 1, 0), Vector(0, 1, 1), Vector(0, 0, 1), Vector(1, 1, 0), Vector(
			1, 0, 1), Vector(1, 1, 1));
		"--------------Set Level 2 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[2] = Array(Null, Vector(23.800, 12.613, 7.130), Vector(23.534, 12.613, -7.408), Vector(-23.373, 12.528, -6.927),
			Vector(4.494, 16.758, 2.908), Vector(-33.877, 1.500, -0.333), Vector(-2.191, 15.535, -13.742), Vector(-0.360, 15.535, 13.652),
			Vector(4.160, 15.520, 0), Vector(7.089, 26.006, 12.756), Vector(-13.206, 1.850, -23.109), Vector(28.810, 1.500, -8.005),
			Vector(-23.729, 1.498, 4.492));
		Global.CPPunchUpperSlamCounts[2] = Array(Null, Vector(0, 1, 0), Vector(1, 1, 0), Vector(1, 0, 1), Vector(1, 0, 0), Vector(1, 0, 1),
			Vector(1, 0, 0), Vector(1, 0, 0), Vector(1, 0, 1), Vector(0, 1, 1), Vector(1, 0, 1), Vector(1, 1, 0), Vector(1, 1, 1));
		"--------------Set Level 3 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[3] = Array(Null, Vector(31.907, 1.500, 0.300), Vector(-4.975, 16.715, 2.369), Vector(-35.092, 1.500, 0.734),
			Vector(-23.868, 12.528, -6.945), Vector(23.643, 12.613, 6.999), Vector(-15.696, 1.500, -13.304), Vector(-4.938, 15.535,
			-13.293), Vector(7.743, 26.006, 12.403), Vector(-7.690, 26.006, 12.417), Vector(0, 0, 8), Vector(-4.182, 17.100, 0.050));
		Global.CPPunchUpperSlamCounts[3] = Array(Null, Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 0), Vector(1, 1, 0), Vector(1, 0, 1),
			Vector(1, 0, 1), Vector(1, 0, 1), Vector(0, 1, 0), Vector(0, 0, 1), Vector(1, 0, 0), Vector(1, 1, 1));
		"--------------Set Level 4 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[4] = Array(Null, Vector(31.120, 1.500, 16.702), Vector(37.583, 1.421, -67.758), Vector(14.500, 2.862, -34.188),
			Vector(36.651, 1.421, -67.442), Vector(-20.114, 3.801, -33.914), Vector(15.121, 2.863, -34.183), Vector(-14.056, 2.863,
			33.508), Vector(40.315, 2.421, 60.853), Vector(31.652, 5.122, 58.561), Vector(31.831, 5.219, 55.399), Vector(-17.669, 2.862,
			33.422), Vector(-53.019, 1.723, 98.501), Vector(-36.892, 1.760, 112.122), Vector(6.643, 0.587, -140.070), Vector(6.900, 12.100,
			-171.600));
		Global.CPPunchUpperSlamCounts[4] = Array(Null, Vector(1, 1, 1), Vector(0, 1, 1), Vector(1, 0, 0), Vector(1, 1, 1), Vector(0, 1, 1),
			Vector(1, 1, 1), Vector(1, 1, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(1, 0, 1), Vector(1, 0, 1), Vector(0, 1, 0), Vector(
			1, 1, 1), Vector(1, 1, 0), Vector(1, 1, 1));
		"--------------Set Level 5 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[5] = Array(Null, Vector(41.839, 1.527, 0.308), Vector(8.359, 28.435, 13.560), Vector(-7.858, 28.435, -13.340),
			Vector(-29.645, 1.500, 7.509), Vector(-33.856, 1.776, -19.822), Vector(15.551, 1.499, -13.271), Vector(5.450, 15.553, 13.520),
			Vector(-1.930, 14, 6.100), Vector(-28.564, 1.500, 4.498), Vector(7.049, 26.006, -12.831));
		Global.CPPunchUpperSlamCounts[5] = Array(Null, Vector(1, 1, 1), Vector(0, 1, 1), Vector(0, 0, 0), Vector(0, 0, 0), Vector(1, 1, 0),
			Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 1, 0), Vector(1, 1, 0), Vector(1, 1, 1));
		"--------------Set Level 6 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[6] = Array(Null, Vector(31.953, 1.500, -17.060), Vector(8.562, 28.435, 13.705), Vector(-8.700, 28.435, 13.601),
			Vector(0.521, 29.064, -1.182), Vector(-8.647, 28.435, -14.052), Vector(7.752, 28.435, -13.890), Vector(-6.729, 26.006,
			-13.455), Vector(6.729, 26.006, -13.456), Vector(-4.877, 16.899, 0.453), Vector(5.941, 15.742, 13.757), Vector(23.317, 12.613,
			6.989), Vector(23.574, 12.611, -6.976), Vector(-2.444, 1.500, -8.274), Vector(-23.630, 12.528, -7.057), Vector(-23.585, 12.527,
			7.465), Vector(-14.542, 2.862, 33.525), Vector(2.126, 2.846, 33.566), Vector(7.233, 2.775, 44.118), Vector(17.575, 2.870,
			33.195), Vector(30.601, 2.434, 48.764), Vector(24.773, 2.433, 63.564), Vector(40.454, 2.423, 60.909), Vector(31.862, 5.159,
			58.339), Vector(31.496, 5.119, 55.193));
		Global.CPPunchUpperSlamCounts[6] = Array(Null, Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1),
			Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(
			0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0,
			1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(1, 1, 1));
		"--------------Set Level 7 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[7] = Array(Null, Vector(-4.625, 16.943, -0.952), Vector(0, 29.064, 0));
		Global.CPPunchUpperSlamCounts[7] = Array(Null, Vector(1, 1, 1), Vector(1, 1, 1));
		"Autogenerate checkpoint facing, radii, and other variables based on CPLocations"
		Call Subroutine(AutogenerateMapVariables);
		"Override autogenerated variables based on rule right below this one"
		Call Subroutine(OverrideAutogenVariables);
	}
}

rule("-------------OVERRIDE AUTO-GENERATED CP RADII / FACING, SET TELEPORTS, ULTIMATE ENABLE HERE-------------")
{
	event
	{
		Subroutine;
		OverrideVariablesUserInput;
	}

	actions
	{
		"OVERRIDING CHECKPOINT PARAMETERS INSTRUCTIONS\r\nStep 1: Copy/paste code block from \"If(Global.LevelIterator == 0)\" to next \"End\" statement\r\nStep 2: Change the 0 in If(Global.LevelIterator == 0) to the level\r\nStep 3: Add the modifiers for that level (see the"
		disabled Wait(0.250, Ignore Condition);
		"------------------Use this code block to set Level 0 modifiers------------------"
		If(Global.LevelIterator == 0);
			Global.TempRadii[0] = 6;
			Global.TempFacing[0] = Vector(1, 0, 0);
		End;
		"------------------Use this code block to set Level 2 modifiers------------------"
		If(Global.LevelIterator == 2);
			Global.TempUltimate360MaxSlam[1] = Vector(0, 1, 0);
			Global.TempUltimate360MaxSlam[7] = Vector(0, 1, 0);
			Global.TempFacing[8] = Vector(-0.960, -0.060, 0.290);
			Global.TempRadii[10] = 3;
		End;
		"------------------Use this code block to set Level 3 modifiers------------------"
		If(Global.LevelIterator == 3);
			"Example: Use this code to override CP12 to enable require a 360 to complete the point"
			Global.TempUltimate360MaxSlam[3] = Vector(0, 1, 0);
			Global.TempUltimate360MaxSlam[5] = Vector(0, 0, 1);
			"Example: Code block to override Level 0 CP 0 facing direction (1,0,0)"
			Global.TempFacing[6] = Vector(-0.750, 0, 0.660);
			Global.TempUltimate360MaxSlam[9] = Vector(0, 0, 1);
			"------------------Use this code block to set Level 1 modifiers------------------"
			If(Global.LevelIterator == 1);
			End;
			Global.TempRadii[10] = 6;
		End;
		"------------------Use this code block to set Level 4 modifiers------------------"
		If(Global.LevelIterator == 4);
			Global.TempTeleport[1] = True;
			Global.TempTeleport[6] = True;
			Global.TempUltimate360MaxSlam[9] = Vector(0, 0, 1);
			Global.TempRadii[13] = 1;
			Global.TempTeleport[13] = True;
			Global.TempRadii[15] = 10;
		End;
		"------------------Use this code block to set Level 5 modifiers------------------"
		If(Global.LevelIterator == 5);
			Global.TempTeleport[1] = True;
			Global.TempUltimate360MaxSlam[3] = Vector(1, 0, 0);
			Global.TempRadii[6] = 3.500;
			Global.TempRadii[8] = 1;
		End;
		"------------------Use this code block to set Level 6 modifiers------------------"
		If(Global.LevelIterator == 6);
			Global.TempTeleport[1] = True;
			Global.TempTeleport[15] = True;
		End;
		"------------------Use this code block to set Level 7 modifiers------------------"
		If(Global.LevelIterator == 7);
			Global.TempRadii[1] = 5;
		End;
	}
}

rule("Get On Fire To Finish Scoring Challenge Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.CurrentLevel == 7;
		Event Player.CurrentCP == 1;
		Is Portrait On Fire(Event Player) == True;
	}

	actions
	{
		Teleport(Event Player, Global.CPLocations[5][2]);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Scoring Challenge Level Notification")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.CurrentLevel == 7;
		Event Player.CurrentCP == 1;
	}

	actions
	{
		If(Is Game In Progress);
			Big Message(Event Player, Custom String("Become on fire to finish the level. Score goals to get on fire!"));
		Else;
			Small Message(All Players(All Teams), Custom String("Match Not Started! Host must click Start Game Mode!"));
			Event Player.CurrentCP = 0;
			Event Player.CurrentLevel = 0;
			Call Subroutine(RespawnPlayer);
		End;
	}
}

rule("Level 4 End Boss Get on Train Notification")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Event Player.CurrentCP == 14;
		Event Player.CurrentLevel == 4;
	}

	actions
	{
		Big Message(Event Player, Custom String("Get on the train!"));
	}
}

disabled rule("Initialize Player and Map")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Initialize Other Global Constants")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.TopScoreString = Custom String("");
		Global.AllScoreString = Custom String("");
		Global.DevModeEngaged = False;
		Enable Death Spectate Target HUD(All Players(All Teams));
		Set Match Time(3599);
		Pause Match Time;
		Disable Built-In Game Mode Completion;
		Disable Built-In Game Mode Scoring;
	}
}

rule("Initialize Global HUD and Effects")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Wait for Map Checkpoints, radii, etc to get generated. Prevents this rule from running out of order with map generation rules."
		Wait(0.200, Ignore Condition);
		"Create Origin Point Ring"
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0), Ring, Purple, Global.CPLocations[0][0],
			Global.CPRadii[0][0], Visible To);
		For Global Variable(LevelIterator, 1, Count Of(Global.CPLocations), 1);
			"Create Level Entry Rings"
			Create Effect(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0), Ring, Purple,
				Global.CPLocations[Global.LevelIterator][1], Global.CPRadii[Global.LevelIterator][1], Visible To);
			"Put checkpoint numbers under level description (looked bad)"
			disabled Create In-World Text(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0), Custom String(
				"{0}\r\nCheckpoints: {1}", Global.LevelNames[Global.LevelIterator], Count Of(Global.CPLocations[Global.LevelIterator])),
				Global.CPLocations[Global.LevelIterator][1], 1.500, Do Not Clip, Visible To, Yellow, Default Visibility);
			Create In-World Text(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0), Custom String("{0} ({1})",
				Global.LevelNames[Global.LevelIterator], Global.LevelDescriptions[Global.LevelIterator]),
				Global.CPLocations[Global.LevelIterator][1], 1.500, Do Not Clip, Visible To, Orange, Default Visibility);
			Create Icon(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0),
				Global.CPLocations[Global.LevelIterator][1], Flag, Visible To, Yellow, True);
		End;
		"Hide Game HUD"
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(
			" \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"),
			Top, 0, White, White, White, Visible To and String, Default Visibility);
		"Controls HUD"
		Create HUD Text(All Players(All Teams), Custom String("Controls"), Null, Null, Left, -2, White, White, White,
			Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(
			"Quick Reset - R\r\nSkip Checkpoint - Jump + Interact\r\n{0}\r\n{1}", Custom String(
			"Previous Checkpoint - Crouch + Interact\r\nChoose New Level - Ultimate + Interact"), Custom String(
			"View Level Entry / CP Location - Left Click + Interact\r\nSpectate - Need Healing Voiceline\r\nFree Roam - Hello + Interact")),
			Left, 0, White, White, White, Visible To and String, Default Visibility);
		"Top Scores HUD"
		Create HUD Text(Filtered Array(All Players(All Teams), Global.TopScoreString != Custom String("")), Custom String("Top Scores"),
			Null, Null, Left, 1, White, White, Green, Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Global.TopScoreString != Custom String("")), Null, Null, Custom String(
			"{0}", Global.TopScoreString), Left, 2, White, White, Green, Visible To and String, Default Visibility);
		"All Scores HUD"
		disabled Create HUD Text(Filtered Array(All Players(All Teams), Global.AllScoreString != Custom String("")), Custom String("All Scores"),
			Null, Null, Right, 2, White, White, White, Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Global.AllScoreString != Custom String("")), Null, Null, Custom String(
			"{0}", Global.AllScoreString), Right, 3, White, White, White, Visible To and String, Default Visibility);
		"Workshop Code HUD"
		Create HUD Text(All Players(All Teams), Custom String("Workshop Code: 55ESWS"), Null, Null, Right, -9, Green, White, White,
			Visible To, Default Visibility);
	}
}

rule("Initialize Player Variables")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Disable Game Mode In-World UI(Event Player);
		Disable Game Mode HUD(Event Player);
		Start Forcing Player To Be Hero(Event Player, Hero(Doomfist));
		Event Player.CurrentCP = 0;
		Event Player.CurrentLevel = 0;
		Event Player.FreeRoamEnabled = False;
		Event Player.BlockArriveAtNextPoint = False;
		Call Subroutine(RespawnPlayer);
		For Player Variable(Event Player, Z, 0, Count Of(Global.CPLocations), 1);
			Event Player.TopPersonalScores[Event Player.Z] = 9999;
		End;
	}
}

rule("Initialize Player HUD and Effects")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Create HUD Text(Event Player, Null, Null, Custom String("{0} Checkpoint {1} - Time {2}",
			Global.LevelNames[Event Player.CurrentLevel], Custom String("{0}/{1}", Event Player.CurrentCP, Count Of(
			Global.CPLocations[Event Player.CurrentLevel]) - 1), Event Player.LevelTimer), Top, -2, White, White, White,
			Visible To and String, Default Visibility);
		"Create Current Checkpoint Ring"
		Create Effect(Filtered Array(Event Player, Event Player.CurrentCP > 0 && Event Player.CurrentCP + 1 < Count Of(
			Global.CPLocations[Event Player.CurrentLevel])), Ring, Purple,
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP],
			Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP], Visible To Position and Radius);
		"Next Checkpoint Ring"
		Create Effect(Filtered Array(Event Player, Current Array Element.CurrentCP > 0), Ring, Purple,
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1],
			Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 1], Visible To Position and Radius);
		"Create Next Checkpoint Text"
		Create In-World Text(Filtered Array(Event Player, Event Player.CurrentCP > 0 && Event Player.CurrentCP + 1 < Count Of(
			Global.CPLocations[Event Player.CurrentLevel])), Custom String("Come Here!"),
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1], 1.300, Do Not Clip, Visible To Position and String,
			Yellow, Default Visibility);
		"Create Next Checkpoint Icon"
		Create Icon(Filtered Array(Event Player, Event Player.CurrentCP > 0 && Event Player.CurrentCP + 1 < Count Of(
			Global.CPLocations[Event Player.CurrentLevel])), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1],
			Flag, Visible To and Position, Yellow, True);
		"Level 3 HUD: Ability Limits "
		Create HUD Text(Filtered Array(Event Player, Index Of Array Value(Global.LevelsWithLimitedAbilityCounts, Event Player.CurrentLevel)
			>= 0 && Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel])), Custom String(
			"Checkpoint Abilty Limits\r\n{0} {1} {2}", Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(
			Secondary Fire)), X Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])
			- X Component Of(Event Player.PunchUpperSlamUsed)), Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(
			Ability 1)), Y Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) - Y Component Of(
			Event Player.PunchUpperSlamUsed)), Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Ability 2)),
			Z Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) - Z Component Of(
			Event Player.PunchUpperSlamUsed))), Null, Null, Top, -1.400, Blue, White, White, Visible To and String, Default Visibility);
		"360 Required HUD"
		Create HUD Text(Filtered Array(Event Player, Y Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) > 0), Custom String(
			"360's Required: {0}", Y Component Of(Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])),
			Null, Null, Top, -1, Red, White, White, Visible To and String, Default Visibility);
		"125Slam Required HUD"
		Create HUD Text(Filtered Array(Event Player, Z Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) > 0), Custom String(
			"125 Charge Slams Required: {0}", Z Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])), Null, Null, Top, -1, Red, White, White,
			Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(Event Player, Global.DevModeEngaged), Null, Null, Custom String(
			"--------------Player Variables------------------\r\n{0}\r\n--------------Checkpoint Variables--------------\r\n{1}\r\n{2}\r\n-------------",
			Custom String("Position: {0}\r\nFacing: {1}\r\nNext CP Dist: {2}", Position Of(Event Player), Facing Direction Of(
			Event Player), Distance Between(Position Of(Event Player),
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1])), Custom String(
			"Checkpoint Position: {0}\r\nCheckpoint Abilities {1}\r\n{2}",
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP],
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP], Custom String(
			"Checkpoint Facing: {0}\r\nCheckpoint Radius: {1}", Global.CPFacing[Event Player.CurrentLevel][Event Player.CurrentCP],
			Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP])), Custom String(
			"Checkpoint Ultimate Enabled: {0}\r\nCheckpoint 360 Req'd: {1}\r\nCheckpoint 125 Slam Req'd: {2}", X Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]), Y Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]), Z Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]))), Left, 9, White, White, White,
			Visible To and String, Default Visibility);
		"Free Roam Notification HUD"
		Create HUD Text(Filtered Array(Event Player, Event Player.FreeRoamEnabled), Custom String(
			"Free Roam Enabled! Hello + Interact to exit Free Roam!"), Null, Null, Top, -2, Red, White, White, Visible To,
			Default Visibility);
	}
}

disabled rule("Multi-Level Framework")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Enter Into Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Count Of(Filtered Array(Global.LevelOrigins, Distance Between(Current Array Element, Position Of(Event Player)) < 2)) > 0;
		Is On Ground(Event Player) == True;
		Event Player.CurrentCP == 0;
		Has Spawned(Event Player) == True;
		"Disable this rule if Free Roam Mode enabled"
		Event Player.FreeRoamEnabled == False;
	}

	actions
	{
		Play Effect(Event Player, Buff Explosion Sound, White, Event Player, 60);
		Event Player.CurrentCP = 1;
		Event Player.CurrentLevel = Index Of Array Value(Global.LevelOrigins, First Of(Filtered Array(Global.LevelOrigins,
			Distance Between(Position Of(Event Player), Current Array Element) < 2))) + 1;
		If(Global.CPTeleport[Event Player.CurrentLevel][Event Player.CurrentCP] != Null);
			Event Player.CurrentCP += 1;
		End;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Respawn If Touched Ground Not On Level Entry Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Count Of(Filtered Array(Global.LevelOrigins, Distance Between(Current Array Element, Position Of(Event Player)) < 2)) == 0;
		Is On Ground(Event Player) == True;
		Event Player.CurrentCP == 0;
		Has Spawned(Event Player) == True;
		"Not on current checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 0])
			> Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 0];
		"Disable this rule if Free Roam Mode enabled"
		Event Player.FreeRoamEnabled == False;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Start Timer When Player Leaves Origin Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Distance Between(Position Of(Event Player), Global.CPLocations[0][0]) > Global.CPRadii[0][0];
		Event Player.CurrentCP <= 0;
		Has Spawned(Event Player) == True;
		"Disable this rule if Free Roam Mode enabled"
		Event Player.FreeRoamEnabled == False;
	}

	actions
	{
		"To prevent this rule from triggering before the rule that tele's player to start point"
		Wait(0.250, Abort When False);
		Event Player.LevelTimer = 0;
		Chase Player Variable At Rate(Event Player, LevelTimer, 99999, 1, Destination and Rate);
	}
}

rule("Arrived At Next Checkpoint")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Within range of next checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1])
			< Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 1];
		"Player has selected a level"
		Event Player.CurrentCP > 0;
		Is On Ground(Event Player) == True;
		"Is not on last checkpoint in level"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		Event Player.CurrentLevel > 0;
		Event Player.BlockArriveAtNextPoint != True;
		"Disable this rule if Free Roam Mode enabled"
		Event Player.FreeRoamEnabled == False;
	}

	actions
	{
		Wait(0.033, Abort When False);
		If(Y Component Of(Event Player.Count360Slam125) < Z Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			"Slam grace period"
			Wait(0.050, Ignore Condition);
			If(Y Component Of(Event Player.Count360Slam125) < Z Component Of(
				Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
				Small Message(Event Player, Custom String("Checkpoint Requires 125 charge slam", Z Component Of(
					Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])));
				Call Subroutine(RespawnPlayer);
				Abort;
			End;
		End;
		If(X Component Of(Event Player.Count360Slam125) < Y Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			Small Message(Event Player, Custom String("Checkpoint Requires {0} 360's. Spin Around!", Y Component Of(
				Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])));
			Call Subroutine(RespawnPlayer);
			Abort;
		End;
		Event Player.CurrentCP += 1;
		Play Effect(Event Player, Buff Explosion Sound, White, Event Player, 60);
		If(Global.CPTeleport[Event Player.CurrentLevel][Event Player.CurrentCP] != Null);
			Event Player.CurrentCP += 1;
		End;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Respawn If Touched Ground Not On Checkpoints")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Not on current checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 0])
			> Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 0];
		"Not within range of next checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1])
			> Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 1];
		"Player has selected a level"
		Event Player.CurrentCP > 0;
		Is On Ground(Event Player) == True;
		"Is not on last checkpoint in level"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		"Disable this rule if Free Roam Mode enabled"
		Event Player.FreeRoamEnabled == False;
	}

	actions
	{
		"Is using ultimate and is has other abilities available. Disabling this because it triggers on valid meteor strikes because this rule triggers in middle of RespawnPlayer subroutine before the teleport happens."
		disabled If(Is Using Ultimate(Event Player) && 0 < Dot Product(Vector(1, 1, 1),
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
		disabled Small Message(Event Player, Custom String("Meteor Strike on non-ground point to keep using abilities!"));
		disabled End;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Level End Boss Notification (for fun)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.CurrentLevel > 0;
		Event Player.CurrentCP + 2 == Count Of(Global.CPLocations[Event Player.CurrentLevel]);
	}

	actions
	{
		Big Message(Event Player, Custom String("Level End Boss!"));
	}
}

rule("Finished Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Is on last checkpoint in level"
		Event Player.CurrentCP + 1 == Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		Event Player.CurrentCP > 0;
		Event Player.CurrentLevel > 0;
		Event Player.LevelTimer > 0;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, LevelTimer);
		Big Message(All Players(All Teams), Custom String("{0} Finished {1} in {2}sec", Event Player,
			Global.LevelNames[Event Player.CurrentLevel], Event Player.LevelTimer));
		"If player got top score, update top scores"
		If(Event Player.LevelTimer < Global.TopScoreTimes[Event Player.CurrentLevel]);
			Global.TopScoreTimes[Event Player.CurrentLevel] = Event Player.LevelTimer;
			"Making it save player name as a string, so it works even after they leave the game"
			Global.TopScorePlayer[Event Player.CurrentLevel] = Custom String("{0}", Event Player);
		End;
		"If player got best personal score, update personal scores"
		If(Event Player.LevelTimer < Event Player.TopPersonalScores[Event Player.CurrentLevel]);
			Event Player.TopPersonalScores[Event Player.CurrentLevel] = Event Player.LevelTimer;
		End;
		Call Subroutine(UpdateTopScoreboard);
		Small Message(Event Player, Custom String("Use Ultimate + Interact To Restart"));
	}
}

rule("Respawn Player If They Die")
{
	event
	{
		Player Died;
		All;
		All;
	}

	conditions
	{
		Event Player.SpectateMode == False;
	}

	actions
	{
		Respawn(Event Player);
		Wait(0.100, Ignore Condition);
		Call Subroutine(RespawnPlayer);
	}
}

disabled rule("Additional Features")
{
	event
	{
		Ongoing - Global;
	}
}

rule("R -> Quick Reset")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Reload) == True;
	}

	actions
	{
		Event Player.BlockArriveAtNextPoint = True;
		Call Subroutine(RespawnPlayer);
		Event Player.BlockArriveAtNextPoint = False;
	}
}

rule("Ultimate + Interact -> Reset to Origin Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Ultimate) == True;
		Is Button Held(Event Player, Interact) == True;
		Has Spawned(Event Player) == True;
		"Don't allow this in free roam because otherwise the Doomfist Ultimate cancel bug will happen leaving residual stuff on player's HUD"
		Event Player.FreeRoamEnabled == False;
	}

	actions
	{
		Event Player.CurrentCP = 0;
		Event Player.CurrentLevel = 0;
		Stop Chasing Player Variable(Event Player, LevelTimer);
		Event Player.LevelTimer = 0;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Jump + Interact -> Skip Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Jump) == True;
		Is Button Held(Event Player, Interact) == True;
		Event Player.CurrentLevel > 0;
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		"To mitigate conflict with other button combos"
		Is Button Held(Event Player, Crouch) == False;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, LevelTimer);
		Event Player.LevelTimer = 0;
		Event Player.CurrentCP += 1;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Crouch + Interact -> Go Back A Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Crouch) == True;
		Is Button Held(Event Player, Interact) == True;
		Event Player.CurrentLevel > 0;
		Event Player.CurrentCP + 0 > 1;
		"To mitigate conflict with other button combos"
		Is Button Held(Event Player, Jump) == False;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		"To stop you from going back a checkpoint, and the \"Arrive At Next Checkpoint Rule\" from triggering while you are respawning"
		Event Player.BlockArriveAtNextPoint = True;
		Event Player.CurrentCP -= 1;
		Call Subroutine(RespawnPlayer);
		Wait(0.100, Ignore Condition);
		Event Player.BlockArriveAtNextPoint = False;
	}
}

rule("Left Click + Interact -> Camera To See Next Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Make sure next point exists"
		disabled Count Of(Global.CPLocations[Event Player.CurrentLevel]) > Event Player.CurrentCP + 1;
		Is Button Held(Event Player, Primary Fire) == True;
		Is Button Held(Event Player, Interact) == True;
		"Make sure next point exists"
		(Count Of(Global.CPLocations[Event Player.CurrentLevel]) > Event Player.CurrentCP + 1 || Event Player.CurrentLevel == 0) == True;
	}

	actions
	{
		Set Primary Fire Enabled(Event Player, False);
		If(Event Player.CurrentLevel > 0);
			Event Player.TempViewNextPointPosition = Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1];
		Else;
			Event Player.TempViewNextPointPosition = First Of(Sorted Array(Global.LevelOrigins, Angle Between Vectors(Facing Direction Of(
				Event Player), Direction Towards(Position Of(Event Player), Current Array Element))));
		End;
		Set Facing(Event Player, Vector(-10, -10, 0), To World);
		Start Camera(Event Player, Ray Cast Hit Position(Event Player.TempViewNextPointPosition,
			Event Player.TempViewNextPointPosition + Facing Direction Of(Event Player) * -15, All Players(All Teams), Event Player, True),
			Event Player.TempViewNextPointPosition, 30);
		While(Is Button Held(Event Player, Primary Fire) && Is Button Held(Event Player, Interact));
			Wait(0.033, Ignore Condition);
		End;
		Stop Camera(Event Player);
		Set Primary Fire Enabled(Event Player, True);
	}
}

rule("Need Healing Voiceline -> Spectate Other Players")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating(Event Player, Need Healing) == True;
		disabled Is Button Held(Event Player, Melee) == True;
		disabled Is Button Held(Event Player, Interact) == True;
	}

	actions
	{
		Enable Death Spectate Target HUD(All Players(All Teams));
		Enable Death Spectate All Players(All Players(All Teams));
		If(Is Dead(Event Player));
			Enable Built-In Game Mode Respawning(Event Player);
			Resurrect(Event Player);
			Wait(0.100, Ignore Condition);
			Call Subroutine(RespawnPlayer);
			Event Player.SpectateMode = False;
		Else;
			Big Message(Event Player, Custom String("Use \"Need Healing\" voiceline to exit Spectate Mode!"));
			Event Player.SpectateMode = True;
			Disable Built-In Game Mode Respawning(Event Player);
			Kill(Event Player, Null);
		End;
		Set Status(Event Player, Null, Phased Out, 9999);
	}
}

rule("Hello + Interact -> Free Roam")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating(Event Player, Hello) == True;
		Is Button Held(Event Player, Interact) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		If(Event Player.FreeRoamEnabled);
			"Respawn the player so they can't free roam into next checkpoint, then turn off free roam"
			Call Subroutine(RespawnPlayer);
			If(Event Player.LevelTimer > 0);
				Chase Player Variable At Rate(Event Player, LevelTimer, 9999, 1, Destination and Rate);
			End;
			Event Player.FreeRoamEnabled = False;
			Small Message(Event Player, Custom String("Free Roam Disabled"));
		Else;
			Event Player.FreeRoamEnabled = True;
			Stop Chasing Player Variable(Event Player, LevelTimer);
			Small Message(Event Player, Custom String("Free Roam Enabled. Level Timer Paused."));
			"Give all abilities in free roam"
			Set Secondary Fire Enabled(Event Player, True);
			Set Ability 1 Enabled(Event Player, True);
			Set Ability 2 Enabled(Event Player, True);
			Set Ultimate Ability Enabled(Event Player, True);
			Set Ultimate Charge(Event Player, 100);
		End;
	}
}

rule("Ultimate Charge Always 100% In Free Roam")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.FreeRoamEnabled == True;
		Has Spawned(Event Player) == True;
		Ultimate Charge Percent(Event Player) < 100;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 100);
	}
}

rule("Ultimate Status + Interact -> Dev Mode (Host Only)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Interact) == True;
		Is Communicating(Event Player, Ultimate Status) == True;
		Event Player == Host Player;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Global.DevModeEngaged = !Global.DevModeEngaged;
	}
}

rule("Teleport Enabled with Melee + Left Click if done with level, free roam enabled, or dev mode engaged")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Primary Fire) == True;
		Is Button Held(Event Player, Melee) == True;
		disabled Event Player.CurrentLevel > 0;
		(Event Player.FreeRoamEnabled || Global.DevModeEngaged || Event Player.CurrentCP + 1 >= Count Of(
			Global.CPLocations[Event Player.CurrentLevel])) == True;
	}

	actions
	{
		Teleport(Event Player, Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 60 * Facing Direction Of(
			Event Player), All Players(All Teams), Event Player, True));
	}
}

disabled rule("Can Melee Cancel Slam")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		Is Button Held(Event Player, Melee) == True;
	}

	actions
	{
		Cancel Primary Action(Event Player);
		Small Message(Event Player, Custom String("Testing melee slam cancel"));
	}
}

disabled rule("Subroutines")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Subroutine 0: RespawnPlayer")
{
	event
	{
		Subroutine;
		RespawnPlayer;
	}

	actions
	{
		Disallow Button(Event Player, Interact);
		Disallow Button(Event Player, Secondary Fire);
		Disallow Button(Event Player, Ultimate);
		Disallow Button(Event Player, Ability 1);
		Disallow Button(Event Player, Ability 2);
		Call Subroutine(CancelMomentum);
		Clear Status(Event Player, Phased Out);
		Set Status(Event Player, Null, Phased Out, 9999);
		Cancel Primary Action(Event Player);
		"Safety check in case rules execute out of order, ie Reset to Origin (Q + Interact) pressed same time and get next level"
		If(Event Player.CurrentCP > 0 && Event Player.CurrentLevel == 0);
			Event Player.CurrentCP = 0;
		End;
		disabled Wait(0.100, Ignore Condition);
		"Set location and facing direction of player"
		Teleport(Event Player, Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP]);
		Set Facing(Event Player, Global.CPFacing[Event Player.CurrentLevel][Event Player.CurrentCP], To World);
		"set player abilities"
		Event Player.PunchUpperSlamUsed = Vector(0, 0, 0);
		If(X Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			Set Secondary Fire Enabled(Event Player, False);
		Else;
			Set Secondary Fire Enabled(Event Player, True);
		End;
		If(Y Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			Set Ability 1 Enabled(Event Player, False);
		Else;
			Set Ability 1 Enabled(Event Player, True);
		End;
		If(Z Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			Set Ability 2 Enabled(Event Player, False);
		Else;
			Set Ability 2 Enabled(Event Player, True);
		End;
		If(X Component Of(Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			Set Ultimate Ability Enabled(Event Player, False);
		Else;
			Set Ultimate Ability Enabled(Event Player, True);
		End;
		Set Ultimate Charge(Event Player, 100);
		Wait(0.100, Ignore Condition);
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		If(Event Player.CurrentCP == 0);
			Stop Chasing Player Variable(Event Player, LevelTimer);
			Event Player.LevelTimer = 0;
		End;
		"Redundant, but just in case"
		Event Player.PunchUpperSlamUsed = Vector(0, 0, 0);
		Event Player.Count360Slam125 = Vector(0, 0, 0);
		Allow Button(Event Player, Secondary Fire);
		Allow Button(Event Player, Ability 1);
		Allow Button(Event Player, Ability 2);
		Allow Button(Event Player, Ultimate);
		Set Facing(Event Player, Global.CPFacing[Event Player.CurrentLevel][Event Player.CurrentCP], To World);
		Allow Button(Event Player, Interact);
	}
}

rule("Subroutine 1: AutogenerateMapVariables")
{
	event
	{
		Subroutine;
		AutogenerateMapVariables;
	}

	actions
	{
		"Set the checkpoint location to be the closest walkable position to the CPLocation position entered by player. This is so the map maker can use the Camera button to enter CP locations (which sets eye position instead of player position)"
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + 0, 1);
			Global.X = Global.CPLocations[Global.LevelIterator];
			For Global Variable(CPIterator, 0, Count Of(Global.CPLocations[Global.LevelIterator]) - 0, 1);
				Global.X[Global.CPIterator] = Ray Cast Hit Position(Global.X[Global.CPIterator] + Vector(0, 0.100, 0),
					Global.X[Global.CPIterator] + 2 * Down, All Players(All Teams), Event Player, True);
			End;
			Global.CPLocations[Global.LevelIterator] = Global.X;
			"Initialize TopScoreTimes using this For loop as well"
			Global.TopScoreTimes[Global.LevelIterator] = 10000;
		End;
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + -1, 1);
			Global.LevelOrigins[Global.LevelIterator] = Global.CPLocations[Global.LevelIterator + 1][1];
		End;
		"Autogenerate variable arrays"
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + 0, 1);
			"Set CPFacing array to all NULL. NULL means orient player towards direction of next point."
			Global.CPFacing[Global.LevelIterator] = Null;
			"Set CPFacing array to all NULL. NULL means orient player towards direction of next point."
			Global.CPTeleport[Global.LevelIterator] = Null;
			"Set CPRadii array to all DefaultCPRadius (set in \"Initialize Global Constants\" rule)"
			Global.CPRadii[Global.LevelIterator] = Global.CPRadius;
			"Set Ultimate and other special bindings array to all zeros, as most of the time, these will not be bound to a checkpoint."
			Global.CPUltimate360MaxSlamCounts[Global.LevelIterator] = Vector(0, 0, 0);
			For Global Variable(CPIterator, 1, Count Of(Global.CPLocations[Global.LevelIterator]) - 0, 1);
				Modify Global Variable At Index(CPFacing, Global.LevelIterator, Append To Array, Direction Towards(
					Global.CPLocations[Global.LevelIterator][Global.CPIterator], Global.CPLocations[Global.LevelIterator][Global.CPIterator + 1]));
				Modify Global Variable At Index(CPTeleport, Global.LevelIterator, Append To Array, Null);
				Modify Global Variable At Index(CPRadii, Global.LevelIterator, Append To Array, Global.CPRadius);
				Modify Global Variable At Index(CPUltimate360MaxSlamCounts, Global.LevelIterator, Append To Array, Vector(0, 0, 0));
			End;
		End;
	}
}

rule("Subroutine 2: OverrideAutogenVariables")
{
	event
	{
		Subroutine;
		OverrideAutogenVariables;
	}

	actions
	{
		"OVERRIDING CHECKPOINT PARAMETERS INSTRUCTIONS\r\nStep 1: Copy/paste code block from \"If(Global.LevelIterator == 0)\" to next \"End\" statement\r\nStep 2: Change the 0 in If(Global.LevelIterator == 0) to the level\r\nStep 3: Add the modifiers for that level (see the"
		disabled Wait(0.250, Ignore Condition);
		"Need this whole structure because Workshop Editor doesn't let you index into array's of arrays"
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + 0, 1);
			Global.TempTeleport = Global.CPTeleport[Global.LevelIterator];
			Global.TempUltimate360MaxSlam = Global.CPUltimate360MaxSlamCounts[Global.LevelIterator];
			Global.TempRadii = Global.CPRadii[Global.LevelIterator];
			Global.TempFacing = Global.CPFacing[Global.LevelIterator];
			Call Subroutine(OverrideVariablesUserInput);
			Global.CPFacing[Global.LevelIterator] = Global.TempFacing;
			Global.CPRadii[Global.LevelIterator] = Global.TempRadii;
			Global.CPUltimate360MaxSlamCounts[Global.LevelIterator] = Global.TempUltimate360MaxSlam;
			Global.CPTeleport[Global.LevelIterator] = Global.TempTeleport;
		End;
	}
}

rule("Subroutine 3: Cancel Momentum")
{
	event
	{
		Subroutine;
		CancelMomentum;
	}

	actions
	{
		Apply Impulse(Event Player, Up, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Down, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Left, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Right, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Forward, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Backward, 0.001, To World, Cancel Contrary Motion);
	}
}

rule("Subroutine 5: UpdateTopScoreboard")
{
	event
	{
		Subroutine;
		UpdateTopScoreboard;
	}

	actions
	{
		"Create TOP Scoreboard String"
		Event Player.TopScoreboardString = Custom String("");
		For Player Variable(Event Player, X, Count Of(Global.TopScoreTimes) - 1, -1, -1);
			If(Global.TopScoreTimes[Event Player.X] < 9999);
				If(Event Player.TopScoreboardString == Custom String(""));
					Event Player.TopScoreboardString = Custom String("{0} - {1} {2}", Global.LevelNames[Event Player.X],
						Global.TopScorePlayer[Event Player.X + 0], Global.TopScoreTimes[Event Player.X + 0]);
				Else;
					Event Player.TopScoreboardString = Custom String("{0}\r\n{1}", Event Player.TopScoreboardString, Custom String("{0} - {1} {2}",
						Global.LevelNames[Event Player.X], Global.TopScorePlayer[Event Player.X + 0], Global.TopScoreTimes[Event Player.X + 0]));
				End;
			End;
		End;
		Global.TopScoreString = Event Player.TopScoreboardString;
		"Create All Scoreboard String"
		Event Player.AllScoreboardString = Custom String("");
		For Player Variable(Event Player, X, Count Of(Global.TopScoreTimes) - 1, -1, -1);
			For Player Variable(Event Player, Y, 0, Count Of(All Players(All Teams)), 1);
				If(All Players(All Teams)[Event Player.Y].TopPersonalScores[Event Player.X] < 9999);
					If(All Players(All Teams)[Event Player.Y].TopPersonalScores[Event Player.X] > 0);
						If(Event Player.AllScoreboardString == Custom String(""));
							Event Player.AllScoreboardString = Custom String("{0} - {1} {2}", Global.LevelNames[Event Player.X], All Players(All Teams)
								[Event Player.Y], All Players(All Teams)[Event Player.Y].TopPersonalScores[Event Player.X]);
						Else;
							Event Player.AllScoreboardString = Custom String("{0}\r\n{1}", Event Player.AllScoreboardString, Custom String("{0} - {1} {2}",
								Global.LevelNames[Event Player.X], All Players(All Teams)[Event Player.Y], All Players(All Teams)
								[Event Player.Y].TopPersonalScores[Event Player.X]));
						End;
					End;
				End;
			End;
		End;
		Global.AllScoreString = Event Player.AllScoreboardString;
	}
}

disabled rule("360 Code :D")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}
}

rule("Update 360 Array")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Array360[Round To Integer((Horizontal Facing Angle Of(Event Player) + 180) / 90.010, Down)] != True;
		Has Spawned(Event Player) == True;
		"Can't do 360 in starting checkpoint circle"
		Distance Between(Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP], Position Of(Event Player))
			> Global.CPRadius;
		"So most stalls dont let you 360 for free. Not using \"altitude of\" function because it doesn't work on many roof sides"
		Distance Between(Position Of(Event Player), Ray Cast Hit Position(Position Of(Event Player) + Vector(0, 0.100, 0), Position Of(
			Event Player) + Down * 10, All Players(All Teams), Event Player, True)) > 0.500;
		"So most stalls dont let you 360 for free"
		Altitude Of(Event Player) > 0.500;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		disabled Event Player.Array360[Round To Integer((Horizontal Facing Angle Of(Event Player) + 180) / (360 / Count Of(Event Player.Array360)),
			Down)] = True;
		Event Player.Array360[Round To Integer((Horizontal Facing Angle Of(Event Player) + 180) / 90.010, Down)] = True;
		"Start timer if player has started 360"
		If(Count Of(Filtered Array(Event Player.Array360, Current Array Element == True)) == 2);
			Event Player.Timer360 = 0;
			Chase Player Variable At Rate(Event Player, Timer360, 1, 1, Destination and Rate);
		End;
	}
}

rule("Reset 360 Array after 1 sec")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Timer360 >= 1;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		disabled For Player Variable(Event Player, I, 0, Count Of(Event Player.Array360), 1);
		disabled Event Player.Array360[Event Player.I] = False;
		disabled End;
		Event Player.Array360 = Array(False, False, False, False);
		Event Player.Timer360 = 0;
		Stop Chasing Player Variable(Event Player, Timer360);
	}
}

rule("Successful 360 Detected")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is True For All(Event Player.Array360, Current Array Element) == True;
		Has Spawned(Event Player) == True;
		"Can't do 360 in starting checkpoint circle"
		Distance Between(Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP], Position Of(Event Player))
			> Global.CPRadius;
		"So most stalls dont let you 360 for free"
		Altitude Of(Event Player) > 0.500;
		"So most stalls dont let you 360 for free. Not using \"altitude of\" function because it doesn't work on many roof sides"
		Distance Between(Position Of(Event Player), Ray Cast Hit Position(Position Of(Event Player) + Vector(0, 0.100, 0), Position Of(
			Event Player) + Down * 10, All Players(All Teams), Event Player, True)) > 0.500;
	}

	actions
	{
		Small Message(Event Player, Custom String("360"));
		Event Player.Count360Slam125 += Left;
		Play Effect(Event Player, Buff Impact Sound, White, Event Player, 60);
		Event Player.Array360 = Array(False, False, False, False);
	}
}

disabled rule("Ability Limits Stuff")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Used Secondary (Rocket Punch)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Left;
	}
}

rule("Used Ability 1 (Uppercut)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Up;
	}
}

rule("Used Ability 2 - Start Slam Timer")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Event Player.SlamTimer = 0;
		Chase Player Variable At Rate(Event Player, SlamTimer, 99, 1, Destination and Rate);
	}
}

rule("Stop slam timer when not using slam or on ground")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		(!Is Using Ability 2(Event Player) || (Is On Ground(Event Player) && Event Player.SlamTimer > 0.200)) == True;
		Has Spawned(Event Player) == True;
		"To stop this rule from double triggering"
		Event Player.SlamTimer > 0;
	}

	actions
	{
		Wait(0.050, Ignore Condition);
		Stop Chasing Player Variable(Event Player, SlamTimer);
		Event Player.SlamTimer = 0;
	}
}

rule("Increment Slam Counter")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		"Prevents invalid slam (where player presses slam button but can't slam) from being counted"
		disabled ((Is On Ground(Event Player) && Event Player.SlamTimer > 0.010 && Event Player.SlamTimer < 0.250) || (
			Event Player.SlamTimer > 0.250)) == True;
		Has Spawned(Event Player) == True;
		Is Using Ability 2(Event Player) == True;
		Event Player.SlamTimer > 0.250;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Forward;
		If(Is On Ground(Event Player));
			Stop Chasing Player Variable(Event Player, SlamTimer);
			Event Player.SlamTimer = 0;
		End;
	}
}

rule("125 Slam Detection")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		"Actual time is 1.53 for 125 slam + cancel, but removing cancel ~.3 sec"
		Event Player.SlamTimer >= 1.220;
		Is Using Ability 2(Event Player) == True;
		"To prevent player from just holding down slam at invalid slam angle to get a 125 slam"
		Is Button Held(Event Player, Ability 2) == False;
	}

	actions
	{
		Event Player.Count360Slam125 += Up;
		Small Message(Event Player, Custom String("125 Slam"));
		Play Effect(Event Player, Buff Impact Sound, White, Event Player, 60);
	}
}

rule("Limiter for Ability Counts")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Is in ability limited level"
		Index Of Array Value(Global.LevelsWithLimitedAbilityCounts, Event Player.CurrentLevel) > -1;
		"Is using an ability"
		(Is Using Ability 1(Event Player) || Is Using Ability 2(Event Player) || Is Firing Secondary(Event Player)) == True;
		"Inside a level, not in multilevel portion"
		Event Player.CurrentCP > 0;
		"Is NOT on last checkpoint of the level"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		"Disable this rule if Free Roam Mode enabled"
		Event Player.FreeRoamEnabled == False;
	}

	actions
	{
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
		If(Y Component Of(Event Player.PunchUpperSlamUsed) >= Y Component Of(
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			Set Ability 1 Enabled(Event Player, False);
		End;
		If(Z Component Of(Event Player.PunchUpperSlamUsed) >= Z Component Of(
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			Set Ability 2 Enabled(Event Player, False);
		End;
		If(X Component Of(Event Player.PunchUpperSlamUsed) >= X Component Of(
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			"Have to wait to disable punch because otherwise it would disable immediately after using preventing punch from working properly."
			Wait(0.400, Ignore Condition);
			"This is to fix interaction with the Quick Reset (R) right after using punch, so this doesn't disable punch after you respawn. Can have slight bug where player is punching through the start location, and doesn't set cooldown properly."
			Abort If(True && Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP])
				< Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP]);
			Set Secondary Fire Enabled(Event Player, False);
		End;
	}
}