settings
{
	main
	{
		Description: "Doomfist Parkour: Multi-Hero Edition by WelkinTern. Workshop Code: PZ7ZQ. Sigma hero modifers from ReZero."
	}

	modes
	{
		Skirmish
		{
			enabled maps
			{
				Ilios
			}
		}

		General
		{
			Hero Limit: Off
			Kill Cam: Off
			Kill Feed: Off
			Respawn Time Scalar: 10%
		}
	}

	heroes
	{
		General
		{
			Ana
			{
				Ammunition Clip Size Scalar: 25%
				Biotic Grenade Cooldown Time: 60%
				Sleep Dart Cooldown Time: 75%
			}

			Baptiste
			{
				Immortality Field Cooldown Time: 70%
				Regenerative Burst Cooldown Time: 70%
			}

			Moira
			{
				Projectile Speed: 66%
			}

			Roadhog
			{
				Ammunition Clip Size Scalar: 25%
				Chain Hook Cooldown Time: 75%
				Take a Breather Cooldown Time: 75%
			}

			Sigma
			{
				Accretion Cooldown Time: 60%
				Kinetic Grasp Cooldown Time: 20%
			}

			enabled heroes
			{
				Doomfist
			}
		}
	}
}

variables
{
	global:
		0: CPLocations
		1: LevelNames
		2: CPFacing
		3: CPPunchUpperSlamCounts
		4: CPUltimate360MaxSlamCounts
		5: CPTeleport
		6: CPRadii
		7: LevelsWithLimitedAbilityCounts
		8: LevelOrigins
		9: TopScoreTimes
		10: TopScorePlayer
		11: TopScoreString
		12: AllScoreString
		13: LevelHeros
		14: LevelDescriptions
		15: DevModeEngaged
		17: DefaultCPRadius
		19: TempTeleport
		20: TempUltimate360MaxSlam
		21: TempRadii
		22: TempFacing
		24: CPIterator
		25: LevelIterator
		26: HeroHelpRoster
		27: HeroHelpDescriptions

	player:
		0: CurrentCP
		1: CurrentLevel
		3: LevelTimer
		4: PunchUpperSlamUsed
		5: FreeRoamEnabled
		7: TopPersonalScores
		9: SpectateMode
		14: SlamTimer
		15: BlockArriveAtNextPoint
		16: HeroSelectMenuString
		17: HeroSelectMenuIndex
		21: AllScoreboardString
		22: TopScoreboardString
		26: sigma_barrier_ready_to_destroy
		27: sigma_barrier_ON
		28: sigma_barrier_direction
		29: sigma_barrier_init_position
		30: sigma_barrier_chase
		31: sigma_barrier_position
		32: Array360
		33: Timer360
		34: Count360Slam125
		35: TempViewNextPointPosition
		36: WinstonWallClimbEnabled
		37: WinstonWallClimbTimer
		38: WinstonBubbleLocation
		39: WinstonBouncyBubbleCooldown
		40: WinstonBubbleEffect
		41: AnaSleepDartTeleLocation
		42: RoadhogHookPosition
		43: MoiraOrbPosition
		44: MoiraOrbFacing
		45: MoiraOrbTimer
}

subroutines
{
	0: RespawnPlayer
	1: AutogenerateMapVariables
	2: OverrideAutogenVariables
	3: CancelMomentum
	4: OverrideVariablesUserInput
	5: UpdateTopScoreboard
	6: GenerateHeroSelectMenuText
}

rule("-------------UPDATE MAP CONSTANTS HERE - CHECKPOINTS, ABILITIES-------------")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"MAP MAKING INSTRUCTIONS\r\nStep 1: level checkpoints and abilities below\r\nStep 2: CP facing/radii/teleports/ultimates are autogenerated - override using the rule below this one"
		disabled Wait(0.250, Ignore Condition);
		"Default Checkpoint Radius"
		Global.DefaultCPRadius = 2;
		"Set level descriptions here, make sure the level number matches the index (ie. make sure Level 1 is on index 1)"
		Global.LevelNames = Array(Null, Custom String("Doomfist Level 1", Hero Icon String(Hero(Doomfist))), Custom String(
			"Winston Level 1"), Custom String("Sigma Level 1"), Custom String("Roadhog Level 1"), Custom String("Ana Level 1"),
			Custom String("Sigma Level 2"), Custom String("Winston Level 3"), Custom String("Sigma Level 3"), Custom String(
			"Roadhog Level 3"), Custom String("Doomfist Level 2"), Custom String("Doomfist Level 3"), Custom String("Moira Level 1"));
		Global.LevelDescriptions = Array(Null, Custom String("Easy"), Custom String("Intro"), Custom String("Intro"), Custom String(
			"Intro"), Custom String("Intro"), Custom String("Medium"), Custom String("Hard"), Custom String("Hard"), Custom String("Hard"),
			Custom String("Easy"), Custom String("Medium"), Custom String("Intro"));
		"Set heros for each level, index zero is origin point"
		Global.LevelHeros = Array(Hero(Doomfist), Hero(Doomfist), Hero(Winston), Hero(Sigma), Hero(Roadhog), Hero(Ana), Hero(Sigma), Hero(
			Winston), Hero(Sigma), Hero(Roadhog), Hero(Doomfist), Hero(Doomfist), Hero(Moira));
		"Add to this array the level numbers of levels you want to have ability limits on"
		Global.LevelsWithLimitedAbilityCounts = Array();
		"Set the starting position when the player loads into the game"
		Global.CPLocations = Array(Array(Vector(323.245, -4.861, -36.960)));
		"Set the starting position abilities when the player loads into the game"
		Global.CPPunchUpperSlamCounts = Array(Array(Vector(1, 1, 1)));
		"--------------Set Level 1 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[1] = Array(Null, Vector(330.406, -13.468, -59.449), Vector(320.344, -19.130, -67.381), Vector(340.852, -17.142,
			-31.094), Vector(374.400, -25.456, -0.206), Vector(349.785, -24.119, 22.751), Vector(332.640, -19.241, 11.032), Vector(325.261,
			-23.196, -4.375));
		Global.CPPunchUpperSlamCounts[1] = Array(Null, Vector(0, 1, 0), Vector(1, 1, 1), Vector(1, 1, 1), Vector(1, 1, 0), Vector(1, 0, 1),
			Vector(0, 1, 1), Vector(1, 1, 1));
		"--------------Set Level 2 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[2] = Array(Null, Vector(345.740, -17.278, -32.512), Vector(335.629, -17.274, -55.856), Vector(355.687, -24.262,
			-61.884), Vector(356.923, -16.468, -59.863), Vector(317.473, -16.293, -43.078));
		Global.CPPunchUpperSlamCounts[2] = Array(Null, Vector(0, 1, 0), Vector(0, 0, 1), Vector(0, 0, 0), Vector(0, 1, 1), Vector(1, 1,
			1));
		"--------------Set Level 3 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[3] = Array(Null, Vector(352.190, -16.392, -48.607), Vector(340.612, -17.278, -30.698), Vector(331.705, -13.425,
			-34.930), Vector(340.612, -17.278, -30.698));
		Global.CPPunchUpperSlamCounts[3] = Array(Null, Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1), Vector(1, 1, 1));
		"--------------Set Level 4 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[4] = Array(Null, Vector(333.771, -22.058, -51.609), Vector(331.515, -13.157, -35.126), Vector(331.460, -16.986,
			-55.086), Vector(330.152, -13.309, -59.344));
		Global.CPPunchUpperSlamCounts[4] = Array(Null, Vector(0, 1, 0), Vector(0, 0, 1), Vector(1, 0, 0), Vector(1, 1, 1));
		"--------------Set Level 5 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[5] = Array(Null, Vector(338.253, -22.425, -38.023), Vector(331.246, -17.393, -57.160), Vector(329.897, -13.717,
			-59.325), Vector(327.539, -13.538, -44.569));
		Global.CPPunchUpperSlamCounts[5] = Array(Null, Vector(1, 0, 0), Vector(0, 0, 1), Vector(0, 1, 0), Vector(1, 1, 1));
		"--------------Set Level 6 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[6] = Array(Null, Vector(354.723, -15.798, -41.056), Vector(345.655, -15.470, -32.997), Vector(330.320, -12.867,
			-59.415), Vector(320.992, -13.521, -71.599), Vector(277.655, -16.463, -78.865), Vector(299.284, -14.064, -46.988), Vector(
			325.590, -16.987, -55.710));
		Global.CPPunchUpperSlamCounts[6] = Array(Null, Vector(0, 0, 1), Vector(1, 0, 0), Vector(0, 1, 1), Vector(1, 1, 0), Vector(1, 0, 1),
			Vector(0, 1, 0), Vector(1, 1, 1));
		"--------------Set Level 7 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[7] = Array(Null, Vector(344.474, -13.601, -26.403), Vector(298.984, -14.792, -45.398), Vector(313.301, -14.799,
			-13.603), Vector(310.014, -15.509, 20.890), Vector(366.849, -25.529, 3.204), Vector(276.942, -17.196, -78.412));
		Global.CPPunchUpperSlamCounts[7] = Array(Null, Vector(0, 1, 0), Vector(0, 0, 1), Vector(0, 0, 0), Vector(0, 1, 0), Vector(0, 1, 0),
			Vector(1, 1, 1));
		"--------------Set Level 8 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[8] = Array(Null, Vector(358.274, -24.140, -51.223), Vector(353.467, -15.752, -49.762), Vector(329.255, -16.029,
			-64.328), Vector(330.295, -12.870, -59.185), Vector(331.065, -16.504, -17.441), Vector(336.663, -14.162, 9.212), Vector(
			331.015, -16.543, -17.014));
		Global.CPPunchUpperSlamCounts[8] = Array(Null, Vector(0, 1, 1), Vector(1, 1, 0), Vector(1, 1, 0), Vector(0, 1, 1), Vector(0, 0, 1),
			Vector(0, 1, 0), Vector(1, 1, 1));
		"--------------Set Level 9 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[9] = Array(Null, Vector(335.400, -22.004, -47.195), Vector(359.341, -11.955, 4.481), Vector(353.620, -16.207,
			-45.582), Vector(308.776, -15.221, 21.178), Vector(275.448, -20.803, -71.384));
		Global.CPPunchUpperSlamCounts[9] = Array(Null, Vector(0, 1, 0), Vector(0, 0, 1), Vector(1, 0, 0), Vector(0, 1, 0), Vector(1, 1,
			1));
		"--------------Set Level 10 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[10] = Array(Null, Vector(326.003, -17.139, -55.823), Vector(300.220, -16.160, -44.800), Vector(331.404, -17.101,
			-17.060), Vector(355.572, -14.360, -50.583), Vector(371.751, -25.259, -42.809), Vector(324.158, -16.155, -29.186), Vector(
			108.809, 65.914, -157.408), Vector(55.674, 65.983, -177.915), Vector(36.449, 61.963, -180.084), Vector(50.750, 64.552,
			-180.257), Vector(64.893, 62.456, -174.049), Vector(90.732, 65.802, -173.650), Vector(90.560, 62.199, -148.144), Vector(87.982,
			70.017, -150.597));
		Global.CPPunchUpperSlamCounts[10] = Array(Null, Vector(1, 1, 1), Vector(1, 1, 1), Vector(1, 0, 1), Vector(1, 0, 0), Vector(1, 1,
			1), Vector(1, 1, 1), Vector(1, 1, 1), Vector(0, 0, 1), Vector(0, 1, 0), Vector(0, 0, 1), Vector(1, 1, 0), Vector(0, 1, 1),
			Vector(0, 1, 1), Vector(1, 1, 1));
		"--------------Set Level 11 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[11] = Array(Null, Vector(334.540, -17.143, -55.790), Vector(331.609, -26.142, -91.090), Vector(335.351, -17.040,
			-66.158), Vector(345.633, -15.886, -33.301), Vector(336.399, -23.090, 22.588), Vector(83.242, 69.155, -179.695), Vector(41.308,
			70.190, -163.804), Vector(45.372, 63.504, -138.720), Vector(82.911, 70.018, -150.488), Vector(51.009, 64.537, -179.986),
			Vector(-23.132, 70.016, -162.907), Vector(-237.544, 6.502, -4.081), Vector(-205.048, 11.394, -5.569), Vector(-197.438, 11.394,
			-12.641), Vector(-188.604, 8.475, -7.597), Vector(-189.043, 0.144, -59.483), Vector(-180.276, -2.854, -56.593));
		Global.CPPunchUpperSlamCounts[11] = Array(Null, Vector(1, 1, 1), Vector(1, 1, 1), Vector(1, 0, 1), Vector(0, 0, 0), Vector(1, 1,
			1), Vector(1, 0, 1), Vector(0, 1, 1), Vector(1, 1, 1), Vector(1, 0, 1), Vector(0, 1, 1), Vector(1, 1, 1), Vector(1, 0, 0),
			Vector(0, 0, 0), Vector(0, 0, 0), Vector(1, 1, 0), Vector(0, 0, 1), Vector(1, 1, 1));
		"--------------Set Level 12 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[12] = Array(Null, Vector(350.005, -23.541, -41.827), Vector(345.687, -23.941, -52.970), Vector(349.452, -16.150,
			-55.493), Vector(366.728, -25.941, -9.434), Vector(356.805, -25.941, -18.186));
		Global.CPPunchUpperSlamCounts[12] = Array(Null, Vector(0, 1, 0), Vector(1, 0, 0), Vector(0, 0, 1), Vector(0, 0, 1), Vector(1, 1,
			1));
		"Autogenerate checkpoint facing, radii, and other variables based on CPLocations"
		Call Subroutine(AutogenerateMapVariables);
		"Override autogenerated variables based on rule right below this one"
		Call Subroutine(OverrideAutogenVariables);
	}
}

rule("-------------OVERRIDE AUTO-GENERATED CP RADII / FACING, SET TELEPORTS, ULTIMATE ENABLE HERE-------------")
{
	event
	{
		Subroutine;
		OverrideVariablesUserInput;
	}

	actions
	{
		"OVERRIDING CHECKPOINT PARAMETERS INSTRUCTIONS\r\nStep 1: Copy/paste code block from \"If(Global.LevelIterator == 0)\" to next \"End\" statement\r\nStep 2: Change the 0 in If(Global.LevelIterator == 0) to the level\r\nStep 3: Add the modifiers for that level (see the"
		disabled Wait(0.250, Ignore Condition);
		"------------------Use this code block to set Level 0 modifiers------------------"
		If(Global.LevelIterator == 0);
			"Example: Use this code to override CP 0 radius to be 3m"
			Global.TempRadii[0] = 3;
			"Example: Code block to override Level 0 CP 0 facing direction (1,0,0)"
			Global.TempFacing[0] = Vector(0.620, -0.250, -0.720);
		End;
		"------------------Use this code block to set Level 1 modifiers------------------"
		If(Global.LevelIterator == 1);
			"Use this code to make them do a 360 max-slam on CP 6"
			Global.TempUltimate360MaxSlam[6] = Vector(0, 1, 1);
			disabled Global.TempUltimate360MaxSlam[13] = Vector(0, 1, 0);
		End;
		"------------------Use this code block to set Level 6 modifiers------------------"
		If(Global.LevelIterator == 6);
			Global.CPUltimate360MaxSlamCounts[6] = Vector(0, 1, 0);
		End;
		"------------------Use this code block to set Level 10 modifiers------------------"
		If(Global.LevelIterator == 10);
			"Example: Use this code to override CP 3 radius to be 3.5m"
			Global.TempRadii[5] = 3.500;
			"Example: Use this code to override CP 5 to set it to teleport to the next checkpoint"
			Global.TempTeleport[6] = True;
			Global.TempRadii[9] = 1.500;
			"Example: Use this code to override CP 11 to enable require a 125 Slam to complete checkpoint"
			Global.TempUltimate360MaxSlam[12] = Vector(0, 0, 1);
			"Example: Use this code to override CP12 to enable require a 360 to complete the point"
			Global.TempUltimate360MaxSlam[13] = Vector(0, 1, 0);
			"Example: Use this code to override CP 3 to enable Ultimate"
			disabled Global.TempUltimate360MaxSlam[3] = Vector(1, 0, 0);
		End;
		"------------------Use this code block to set Level 11 modifiers------------------"
		If(Global.LevelIterator == 11);
			Global.TempUltimate360MaxSlam[1] = Vector(1, 0, 0);
			Global.TempUltimate360MaxSlam[1] = Vector(0, 0, 1);
			Global.TempUltimate360MaxSlam[4] = Vector(1, 0, 0);
			Global.TempTeleport[5] = True;
			"Example: Use this code to override CP 3 to enable Ultimate"
			Global.TempUltimate360MaxSlam[10] = Vector(1, 0, 0);
			Global.TempTeleport[11] = True;
			Global.TempUltimate360MaxSlam[16] = Vector(0, 0, 1);
		End;
		"------------------Use this code block to set Level 12 modifiers------------------"
		If(Global.LevelIterator == 12);
			"Example: Use this code to override CP 3 radius to be 3.5m"
			Global.TempRadii[5] = 3.500;
		End;
	}
}

rule("-------------OVERRIDE HERO HELP DESCRIPTIONS HERE-----------")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.HeroHelpRoster[0] = Hero(Doomfist);
		"Description order: Right Click, Ability 1, Ability 2, Ultimate, Left Click, Passive"
		Global.HeroHelpDescriptions[0] = Array(Custom String("Rocket Punch"), Custom String("Uppercut"), Custom String("Seismic Slam"),
			Custom String("Meteor Strike"), Null, Null);
		Global.HeroHelpRoster[1] = Hero(Sigma);
		Global.HeroHelpDescriptions[1] = Array(Custom String("Barrier = Launchpad"), Custom String(
			"Sets Gravity to Zero, Preserves Momentum"), Custom String("Launches You In Opposite Direction"), Custom String(
			"Gravitic Flux"), Null, Null);
		Global.HeroHelpRoster[2] = Hero(Winston);
		Global.HeroHelpDescriptions[2] = Array(Null, Custom String("Jump Pack"), Custom String("Creates Bubble You Can Bounce On (9 sec)"),
			Custom String("Primal Rage"), Null, Custom String("{0} Passive: Wall Climb", Icon String(Arrow: Up)));
		Global.HeroHelpRoster[3] = Hero(Roadhog);
		Global.HeroHelpDescriptions[3] = Array(Custom String("Right Click = Impulse"), Custom String("Is Now Grappling Hook"),
			Custom String("You Bounce Off Ground. Faster Speed = Higher Bounce"), Custom String("Impulse Backward"), Null, Null);
		Global.HeroHelpRoster[4] = Hero(Ana);
		Global.HeroHelpDescriptions[4] = Array(Null, Custom String("Teleports To Sleep Dart Impact Location"), Custom String(
			"Impulse When Healing Yourself"), Null, Custom String("Impulse In Direction You're Facing"), Null);
		Global.HeroHelpRoster[5] = Hero(Moira);
		Global.HeroHelpDescriptions[5] = Array(Null, Custom String("Fade"), Custom String("Teleport To Orb Location Using Melee"),
			Custom String("Weird Grapple Thing (In Work)"), Null, Null);
	}
}

disabled rule("Initialize Player and Map")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Initialize Other Global Constants")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.TopScoreString = Custom String("");
		Global.AllScoreString = Custom String("");
		Global.DevModeEngaged = False;
		Enable Death Spectate Target HUD(All Players(All Teams));
		Set Match Time(3599);
		Pause Match Time;
		Disable Built-In Game Mode Completion;
		Disable Built-In Game Mode Scoring;
	}
}

rule("Initialize Global HUD and Effects")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Wait for Map Checkpoints, radii, etc to get generated. Prevents this rule from running out of order with map generation rules."
		Wait(0.200, Ignore Condition);
		"Create Origin Point Ring"
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0), Ring, Purple, Global.CPLocations[0][0],
			Global.CPRadii[0][0], Visible To);
		For Global Variable(LevelIterator, 1, Count Of(Global.CPLocations), 1);
			If(Index Of Array Value(Global.HeroHelpRoster, Global.LevelHeros[Global.LevelIterator]) == 0);
				"Create Level Entry Rings"
				Create Effect(Filtered Array(All Players(All Teams),
					Current Array Element.CurrentCP == 0 && Current Array Element.HeroSelectMenuIndex == 0 && True), Ring, Purple,
					Global.CPLocations[Global.LevelIterator][1], Global.CPRadii[Global.LevelIterator][1], Visible To);
				Create In-World Text(Filtered Array(All Players(All Teams),
					Current Array Element.CurrentCP == 0 && Current Array Element.HeroSelectMenuIndex == 0), Custom String("{0} ({1})",
					Global.LevelNames[Global.LevelIterator], Global.LevelDescriptions[Global.LevelIterator]),
					Global.CPLocations[Global.LevelIterator][1], 1.500, Do Not Clip, Visible To, Orange, Default Visibility);
				Create Icon(Filtered Array(All Players(All Teams),
					Current Array Element.CurrentCP == 0 && Current Array Element.HeroSelectMenuIndex == 0),
					Global.CPLocations[Global.LevelIterator][1], Flag, Visible To, Yellow, True);
			Else If(Index Of Array Value(Global.HeroHelpRoster, Global.LevelHeros[Global.LevelIterator]) == 1);
				"Create Level Entry Rings"
				Create Effect(Filtered Array(All Players(All Teams),
					Current Array Element.CurrentCP == 0 && Current Array Element.HeroSelectMenuIndex == 1 && True), Ring, Purple,
					Global.CPLocations[Global.LevelIterator][1], Global.CPRadii[Global.LevelIterator][1], Visible To);
				Create In-World Text(Filtered Array(All Players(All Teams),
					Current Array Element.CurrentCP == 0 && Current Array Element.HeroSelectMenuIndex == 1), Custom String("{0} ({1})",
					Global.LevelNames[Global.LevelIterator], Global.LevelDescriptions[Global.LevelIterator]),
					Global.CPLocations[Global.LevelIterator][1], 1.500, Do Not Clip, Visible To, Orange, Default Visibility);
				Create Icon(Filtered Array(All Players(All Teams),
					Current Array Element.CurrentCP == 0 && Current Array Element.HeroSelectMenuIndex == 1),
					Global.CPLocations[Global.LevelIterator][1], Flag, Visible To, Yellow, True);
			Else If(Index Of Array Value(Global.HeroHelpRoster, Global.LevelHeros[Global.LevelIterator]) == 2);
				"Create Level Entry Rings"
				Create Effect(Filtered Array(All Players(All Teams),
					Current Array Element.CurrentCP == 0 && Current Array Element.HeroSelectMenuIndex == 2 && True), Ring, Purple,
					Global.CPLocations[Global.LevelIterator][1], Global.CPRadii[Global.LevelIterator][1], Visible To);
				Create In-World Text(Filtered Array(All Players(All Teams),
					Current Array Element.CurrentCP == 0 && Current Array Element.HeroSelectMenuIndex == 2), Custom String("{0} ({1})",
					Global.LevelNames[Global.LevelIterator], Global.LevelDescriptions[Global.LevelIterator]),
					Global.CPLocations[Global.LevelIterator][1], 1.500, Do Not Clip, Visible To, Orange, Default Visibility);
				Create Icon(Filtered Array(All Players(All Teams),
					Current Array Element.CurrentCP == 0 && Current Array Element.HeroSelectMenuIndex == 2),
					Global.CPLocations[Global.LevelIterator][1], Flag, Visible To, Yellow, True);
			Else If(Index Of Array Value(Global.HeroHelpRoster, Global.LevelHeros[Global.LevelIterator]) == 3);
				"Create Level Entry Rings"
				Create Effect(Filtered Array(All Players(All Teams),
					Current Array Element.CurrentCP == 0 && Current Array Element.HeroSelectMenuIndex == 3 && True), Ring, Purple,
					Global.CPLocations[Global.LevelIterator][1], Global.CPRadii[Global.LevelIterator][1], Visible To);
				Create In-World Text(Filtered Array(All Players(All Teams),
					Current Array Element.CurrentCP == 0 && Current Array Element.HeroSelectMenuIndex == 3), Custom String("{0} ({1})",
					Global.LevelNames[Global.LevelIterator], Global.LevelDescriptions[Global.LevelIterator]),
					Global.CPLocations[Global.LevelIterator][1], 1.500, Do Not Clip, Visible To, Orange, Default Visibility);
				Create Icon(Filtered Array(All Players(All Teams),
					Current Array Element.CurrentCP == 0 && Current Array Element.HeroSelectMenuIndex == 3),
					Global.CPLocations[Global.LevelIterator][1], Flag, Visible To, Yellow, True);
			Else If(Index Of Array Value(Global.HeroHelpRoster, Global.LevelHeros[Global.LevelIterator]) == 4);
				"Create Level Entry Rings"
				Create Effect(Filtered Array(All Players(All Teams),
					Current Array Element.CurrentCP == 0 && Current Array Element.HeroSelectMenuIndex == 4 && True), Ring, Purple,
					Global.CPLocations[Global.LevelIterator][1], Global.CPRadii[Global.LevelIterator][1], Visible To);
				Create In-World Text(Filtered Array(All Players(All Teams),
					Current Array Element.CurrentCP == 0 && Current Array Element.HeroSelectMenuIndex == 4), Custom String("{0} ({1})",
					Global.LevelNames[Global.LevelIterator], Global.LevelDescriptions[Global.LevelIterator]),
					Global.CPLocations[Global.LevelIterator][1], 1.500, Do Not Clip, Visible To, Orange, Default Visibility);
				Create Icon(Filtered Array(All Players(All Teams),
					Current Array Element.CurrentCP == 0 && Current Array Element.HeroSelectMenuIndex == 4),
					Global.CPLocations[Global.LevelIterator][1], Flag, Visible To, Yellow, True);
			Else If(Index Of Array Value(Global.HeroHelpRoster, Global.LevelHeros[Global.LevelIterator]) == 5);
				"Create Level Entry Rings"
				Create Effect(Filtered Array(All Players(All Teams),
					Current Array Element.CurrentCP == 0 && Current Array Element.HeroSelectMenuIndex == 5 && True), Ring, Purple,
					Global.CPLocations[Global.LevelIterator][1], Global.CPRadii[Global.LevelIterator][1], Visible To);
				Create In-World Text(Filtered Array(All Players(All Teams),
					Current Array Element.CurrentCP == 0 && Current Array Element.HeroSelectMenuIndex == 5), Custom String("{0} ({1})",
					Global.LevelNames[Global.LevelIterator], Global.LevelDescriptions[Global.LevelIterator]),
					Global.CPLocations[Global.LevelIterator][1], 1.500, Do Not Clip, Visible To, Orange, Default Visibility);
				Create Icon(Filtered Array(All Players(All Teams),
					Current Array Element.CurrentCP == 0 && Current Array Element.HeroSelectMenuIndex == 5),
					Global.CPLocations[Global.LevelIterator][1], Flag, Visible To, Yellow, True);
			End;
			disabled Create In-World Text(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0), Custom String("{0} ({1})",
				Global.LevelNames[Global.LevelIterator], Global.LevelDescriptions[Global.LevelIterator]),
				Global.CPLocations[Global.LevelIterator][1], 1.500, Do Not Clip, Visible To, Orange, Default Visibility);
			disabled Create Icon(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0),
				Global.CPLocations[Global.LevelIterator][1], Flag, Visible To, Yellow, True);
		End;
		"Controls HUD"
		Create HUD Text(All Players(All Teams), Custom String("Controls"), Null, Null, Left, -2, White, White, White,
			Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(
			"Quick Reset - R\r\nSkip Checkpoint - Jump + Interact\r\n{0}\r\n{1}", Custom String(
			"Previous Checkpoint - Crouch + Interact\r\nChoose New Level - Ultimate + Interact"), Custom String(
			"View Level Entry / CP Location - Left Click + Interact\r\nSpectate - Need Healing Voiceline\r\nFree Roam - Hello + Interact")),
			Left, 0, White, White, White, Visible To and String, Default Visibility);
		"Seperator at end of controls block"
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(" \r\n "), Left, 1, White, White, White, Visible To and String,
			Default Visibility);
		"Top Scores HUD"
		Create HUD Text(Filtered Array(All Players(All Teams), Global.TopScoreString != Custom String("")), Custom String("Top Scores"),
			Null, Null, Right, 0, White, White, Green, Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Global.TopScoreString != Custom String("")), Null, Null, Custom String(
			"{0}", Global.TopScoreString), Right, 1, White, White, Green, Visible To and String, Default Visibility);
		"All Scores HUD"
		Create HUD Text(Filtered Array(All Players(All Teams), Global.AllScoreString != Custom String("")), Custom String("All Scores"),
			Null, Null, Right, 4, White, White, White, Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Global.AllScoreString != Custom String("")), Null, Null, Custom String(
			"{0}", Global.AllScoreString), Right, 5, White, White, White, Visible To and String, Default Visibility);
		"Workshop Code HUD"
		Create HUD Text(All Players(All Teams), Custom String("Workshop Code: PZ7ZQ"), Null, Null, Right, -9, Green, White, White,
			Visible To, Default Visibility);
	}
}

rule("Initialize Player Variables")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Event Player.CurrentCP = 0;
		Event Player.CurrentLevel = 0;
		Event Player.FreeRoamEnabled = False;
		Event Player.BlockArriveAtNextPoint = False;
		Call Subroutine(RespawnPlayer);
		For Player Variable(Event Player, Z, 0, Count Of(Global.CPLocations), 1);
			Event Player.TopPersonalScores[Event Player.Z] = 9999;
		End;
		Disable Game Mode HUD(Event Player);
		Event Player.HeroSelectMenuIndex = 0;
		Call Subroutine(GenerateHeroSelectMenuText);
	}
}

rule("Initialize Player HUD and Effects")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Create HUD Text(Event Player, Null, Null, Custom String("{0} Checkpoint {1} - Time {2}",
			Global.LevelNames[Event Player.CurrentLevel], Custom String("{0}/{1}", Event Player.CurrentCP, Count Of(
			Global.CPLocations[Event Player.CurrentLevel]) - 1), Event Player.LevelTimer), Top, -2, White, White, White,
			Visible To and String, Default Visibility);
		"Create Current Checkpoint Ring"
		Create Effect(Filtered Array(Event Player, Event Player.CurrentCP > 0 && Event Player.CurrentCP + 1 < Count Of(
			Global.CPLocations[Event Player.CurrentLevel])), Ring, Purple,
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP],
			Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP], Visible To Position and Radius);
		"Next Checkpoint Ring"
		Create Effect(Filtered Array(Event Player, Current Array Element.CurrentCP > 0), Ring, Purple,
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1],
			Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 1], Visible To Position and Radius);
		"Create Next Checkpoint Text"
		Create In-World Text(Filtered Array(Event Player, Event Player.CurrentCP > 0 && Event Player.CurrentCP + 1 < Count Of(
			Global.CPLocations[Event Player.CurrentLevel])), Custom String("Come Here!"),
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1], 1.300, Do Not Clip, Visible To Position and String,
			Yellow, Default Visibility);
		"Create Next Checkpoint Icon"
		Create Icon(Filtered Array(Event Player, Event Player.CurrentCP > 0 && Event Player.CurrentCP + 1 < Count Of(
			Global.CPLocations[Event Player.CurrentLevel])), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1],
			Flag, Visible To and Position, Yellow, True);
		"Level 3 HUD: Ability Limits "
		Create HUD Text(Filtered Array(Event Player, Index Of Array Value(Global.LevelsWithLimitedAbilityCounts, Event Player.CurrentLevel)
			>= 0 && Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel])), Custom String(
			"Checkpoint Abilty Limits\r\n{0} {1} {2}", Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(
			Secondary Fire)), X Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])
			- X Component Of(Event Player.PunchUpperSlamUsed)), Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(
			Ability 1)), Y Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) - Y Component Of(
			Event Player.PunchUpperSlamUsed)), Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Ability 2)),
			Z Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) - Z Component Of(
			Event Player.PunchUpperSlamUsed))), Null, Null, Top, -1.400, Blue, White, White, Visible To and String, Default Visibility);
		"360 Required HUD"
		Create HUD Text(Filtered Array(Event Player, Y Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) > 0), Custom String(
			"360's Required: {0}", Y Component Of(Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])),
			Null, Null, Top, -1, Red, White, White, Visible To and String, Default Visibility);
		"125Slam Required HUD"
		Create HUD Text(Filtered Array(Event Player, Z Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) > 0), Custom String(
			"125 Charge Slams Required: {0}", Z Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])), Null, Null, Top, -1, Red, White, White,
			Visible To and String, Default Visibility);
		"Dev Mode HUD"
		Create HUD Text(Filtered Array(Event Player, Global.DevModeEngaged), Null, Null, Custom String(
			"--------------Player Variables------------------\r\n{0}\r\n--------------Checkpoint Variables--------------\r\n{1}\r\n{2}\r\n-------------",
			Custom String("{0}\r\nNext CP Dist: {2}", Custom String("Position: {0}\r\nFacing: {1}\r\nBackend Level Index: {2}",
			Position Of(Event Player), Facing Direction Of(Event Player), Event Player.CurrentLevel), Null, Distance Between(Position Of(
			Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1])), Custom String(
			"Checkpoint Position: {0}\r\nCheckpoint Abilities {1}\r\n{2}",
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP],
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP], Custom String(
			"Checkpoint Facing: {0}\r\nCheckpoint Radius: {1}", Global.CPFacing[Event Player.CurrentLevel][Event Player.CurrentCP],
			Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP])), Custom String(
			"Checkpoint Ultimate Enabled: {0}\r\nCheckpoint 360 Req'd: {1}\r\nCheckpoint 125 Slam Req'd: {2}", X Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]), Y Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]), Z Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]))), Left, 9, White, White, White,
			Visible To and String, Default Visibility);
		"Free Roam Notification HUD"
		Create HUD Text(Filtered Array(Event Player, Event Player.FreeRoamEnabled), Custom String(
			"Free Roam Enabled! Hello + Interact to exit Free Roam!"), Null, Null, Top, -2, Red, White, White, Visible To,
			Default Visibility);
		"Hero Select Menu Text Display"
		Create HUD Text(Filtered Array(Event Player, Event Player.CurrentLevel == 0 && Event Player.CurrentCP == 0), Custom String("{0}",
			Event Player.HeroSelectMenuString), Null, Null, Top, 1, White, White, White, Visible To and String, Default Visibility);
	}
}

rule("Initialize Hero Help HUD")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Create HUD Text(Event Player, Custom String("{0} Hero Help", Hero Icon String(Hero Of(Event Player))), Null, Null, Left, 10, White,
			White, White, Visible To and String, Default Visibility);
		"Right Click Help"
		Create HUD Text(Filtered Array(Event Player, Global.HeroHelpDescriptions[Index Of Array Value(Global.HeroHelpRoster, Hero Of(
			Event Player))][0] != Null), Custom String("{0}", Ability Icon String(Hero Of(Event Player), Button(Secondary Fire))), Null,
			Global.HeroHelpDescriptions[Index Of Array Value(Global.HeroHelpRoster, Hero Of(Event Player))][0], Left, 11, White, White,
			White, Visible To and String, Default Visibility);
		"Ability 1 Help"
		Create HUD Text(Filtered Array(Event Player, Global.HeroHelpDescriptions[Index Of Array Value(Global.HeroHelpRoster, Hero Of(
			Event Player))][1] != Null), Custom String("{0}", Ability Icon String(Hero Of(Event Player), Button(Ability 1))), Null,
			Global.HeroHelpDescriptions[Index Of Array Value(Global.HeroHelpRoster, Hero Of(Event Player))][1], Left, 12, White, White,
			White, Visible To and String, Default Visibility);
		"Ability 2 Help"
		Create HUD Text(Filtered Array(Event Player, Global.HeroHelpDescriptions[Index Of Array Value(Global.HeroHelpRoster, Hero Of(
			Event Player))][2] != Null), Custom String("{0}", Ability Icon String(Hero Of(Event Player), Button(Ability 2))), Null,
			Global.HeroHelpDescriptions[Index Of Array Value(Global.HeroHelpRoster, Hero Of(Event Player))][2], Left, 13, White, White,
			White, Visible To and String, Default Visibility);
		"Ultimate Help"
		Create HUD Text(Filtered Array(Event Player, Global.HeroHelpDescriptions[Index Of Array Value(Global.HeroHelpRoster, Hero Of(
			Event Player))][3] != Null), Custom String("{0}", Ability Icon String(Hero Of(Event Player), Button(Ultimate))), Null,
			Global.HeroHelpDescriptions[Index Of Array Value(Global.HeroHelpRoster, Hero Of(Event Player))][3], Left, 14, White, White,
			White, Visible To and String, Default Visibility);
		"Primary Fire Help"
		Create HUD Text(Filtered Array(Event Player, Global.HeroHelpDescriptions[Index Of Array Value(Global.HeroHelpRoster, Hero Of(
			Event Player))][4] != Null), Custom String("{0}", Ability Icon String(Hero Of(Event Player), Button(Primary Fire))), Null,
			Global.HeroHelpDescriptions[Index Of Array Value(Global.HeroHelpRoster, Hero Of(Event Player))][4], Left, 15, White, White,
			White, Visible To and String, Default Visibility);
		"Passive Help"
		Create HUD Text(Filtered Array(Event Player, Global.HeroHelpDescriptions[Index Of Array Value(Global.HeroHelpRoster, Hero Of(
			Event Player))][5] != Null), Custom String("{0}", Ability Icon String(Hero(Pharah), Button(Jump))), Null,
			Global.HeroHelpDescriptions[Index Of Array Value(Global.HeroHelpRoster, Hero Of(Event Player))][5], Left, 16, White, White,
			White, Visible To and String, Default Visibility);
		"Seperator at end of help text block"
		Create HUD Text(Event Player, Null, Null, Custom String(" \r\n "), Left, 18, White, White, White, Visible To and String,
			Default Visibility);
		"Seperator at end of help text block"
		disabled Create HUD Text(Event Player, Null, Null, Custom String(" \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n"), Left, 18,
			White, White, White, Visible To and String, Default Visibility);
	}
}

disabled rule("Multi-Level Framework")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Update Hero Select Menu via Melee Key")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Melee) == True;
		Event Player.CurrentCP == 0;
		Event Player.CurrentLevel == 0;
	}

	actions
	{
		Event Player.HeroSelectMenuIndex = (Event Player.HeroSelectMenuIndex + 1) % Count Of(Global.HeroHelpRoster);
		Call Subroutine(GenerateHeroSelectMenuText);
	}
}

rule("Enter Into Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
		Event Player.CurrentCP == 0;
		Has Spawned(Event Player) == True;
		"Disable this rule if Free Roam Mode enabled"
		Event Player.FreeRoamEnabled == False;
		Count Of(Filtered Array(Global.LevelOrigins, Distance Between(Current Array Element, Position Of(Event Player))
			< 2 && Global.LevelHeros[Current Array Index + 1] == Global.HeroHelpRoster[Event Player.HeroSelectMenuIndex] && True)) > 0;
	}

	actions
	{
		Event Player.CurrentLevel = Index Of Array Value(Global.LevelOrigins, First Of(Filtered Array(Global.LevelOrigins,
			Distance Between(Current Array Element, Position Of(Event Player))
			< 2 && Global.LevelHeros[Current Array Index + 1] == Global.HeroHelpRoster[Event Player.HeroSelectMenuIndex]))) + 1;
		"If player is on level that's wrong hero, respawn them"
		disabled If(Global.LevelHeros[Event Player.CurrentLevel] != Global.HeroHelpRoster[Event Player.HeroSelectMenuIndex]);
		disabled Event Player.CurrentLevel = 0;
		disabled Call Subroutine(RespawnPlayer);
		disabled Abort;
		disabled End;
		Event Player.CurrentCP = 1;
		Play Effect(Event Player, Buff Explosion Sound, White, Event Player, 60);
		If(Global.CPTeleport[Event Player.CurrentLevel][Event Player.CurrentCP] != Null);
			Event Player.CurrentCP += 1;
		End;
		Call Subroutine(RespawnPlayer);
		Start Forcing Player To Be Hero(Event Player, Global.LevelHeros[Event Player.CurrentLevel]);
		If(Hero Of(Event Player) != Hero(Doomfist));
			Big Message(Event Player, Custom String("{0} See Hero Abilitiy Help HUD {0}", Icon String(Arrow: Left)));
		End;
	}
}

rule("Respawn If Touched Ground Not On Level Entry Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
		Event Player.CurrentCP == 0;
		Has Spawned(Event Player) == True;
		"Not on current checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 0])
			> Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 0];
		"Disable this rule if Free Roam Mode enabled"
		Event Player.FreeRoamEnabled == False;
		disabled Count Of(Filtered Array(Global.LevelOrigins, Distance Between(Current Array Element, Position Of(Event Player)) < 2)) == 0;
		Count Of(Filtered Array(Global.LevelOrigins, Distance Between(Current Array Element, Position Of(Event Player))
			< 2 && Global.LevelHeros[Current Array Index + 1] == Global.HeroHelpRoster[Event Player.HeroSelectMenuIndex] && True)) == 0;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Start Timer When Player Leaves Origin Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Distance Between(Position Of(Event Player), Global.CPLocations[0][0]) > Global.CPRadii[0][0];
		Event Player.CurrentCP <= 0;
		Has Spawned(Event Player) == True;
		"Disable this rule if Free Roam Mode enabled"
		Event Player.FreeRoamEnabled == False;
	}

	actions
	{
		"To prevent this rule from triggering before the rule that tele's player to start point"
		Wait(0.250, Abort When False);
		Event Player.LevelTimer = 0;
		Chase Player Variable At Rate(Event Player, LevelTimer, 99999, 1, Destination and Rate);
	}
}

rule("Arrived At Next Checkpoint")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Within range of next checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1])
			< Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 1];
		"Player has selected a level"
		Event Player.CurrentCP > 0;
		Is On Ground(Event Player) == True;
		"Is not on last checkpoint in level"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		Event Player.CurrentLevel > 0;
		Event Player.BlockArriveAtNextPoint != True;
		"Disable this rule if Free Roam Mode enabled"
		Event Player.FreeRoamEnabled == False;
	}

	actions
	{
		If(Y Component Of(Event Player.Count360Slam125) < Z Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			"Grace period"
			Wait(0.050, Ignore Condition);
			If(Y Component Of(Event Player.Count360Slam125) < Z Component Of(
				Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
				Small Message(Event Player, Custom String("Checkpoint Requires 125 charge slam", Z Component Of(
					Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])));
				Call Subroutine(RespawnPlayer);
				Abort;
			End;
		End;
		If(X Component Of(Event Player.Count360Slam125) < Y Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			Small Message(Event Player, Custom String("Checkpoint Requires {0} 360's. Spin Around!", Y Component Of(
				Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])));
			Call Subroutine(RespawnPlayer);
			Abort;
		End;
		Event Player.CurrentCP += 1;
		Play Effect(Event Player, Buff Explosion Sound, White, Event Player, 60);
		If(Global.CPTeleport[Event Player.CurrentLevel][Event Player.CurrentCP] != Null);
			Event Player.CurrentCP += 1;
		End;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Respawn If Touched Ground Not On Checkpoints")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Not on current checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 0])
			> Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 0];
		"Not within range of next checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1])
			> Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 1];
		"Player has selected a level"
		Event Player.CurrentCP > 0;
		Is On Ground(Event Player) == True;
		"Is not on last checkpoint in level"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		"Disable this rule if Free Roam Mode enabled"
		Event Player.FreeRoamEnabled == False;
		(Hero Of(Event Player) == Hero(Roadhog) && Is Using Ability 2(Event Player)) == False;
	}

	actions
	{
		"Is using ultimate and is has other abilities available. Disabling this because it triggers on valid meteor strikes because this rule triggers in middle of RespawnPlayer subroutine before the teleport happens."
		disabled If(Is Using Ultimate(Event Player) && 0 < Dot Product(Vector(1, 1, 1),
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
		disabled Small Message(Event Player, Custom String("Meteor Strike on non-ground point to keep using abilities!"));
		disabled End;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Level End Boss Notification (for fun)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.CurrentLevel > 0;
		Event Player.CurrentCP + 2 == Count Of(Global.CPLocations[Event Player.CurrentLevel]);
	}

	actions
	{
		Big Message(Event Player, Custom String("Level End Boss!"));
	}
}

rule("Finished Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Is on last checkpoint in level"
		Event Player.CurrentCP + 1 == Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		Event Player.CurrentCP > 0;
		Event Player.CurrentLevel > 0;
		Event Player.LevelTimer > 0;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, LevelTimer);
		Big Message(All Players(All Teams), Custom String("{0} Finished {1} in {2}sec", Event Player,
			Global.LevelNames[Event Player.CurrentLevel], Event Player.LevelTimer));
		"If player got top score, update top scores"
		If(Event Player.LevelTimer < Global.TopScoreTimes[Event Player.CurrentLevel]);
			Global.TopScoreTimes[Event Player.CurrentLevel] = Event Player.LevelTimer;
			"Making it save player name as a string, so it works even after they leave the game"
			Global.TopScorePlayer[Event Player.CurrentLevel] = Custom String("{0}", Event Player);
		End;
		"If player got best personal score, update personal scores"
		If(Event Player.LevelTimer < Event Player.TopPersonalScores[Event Player.CurrentLevel]);
			Event Player.TopPersonalScores[Event Player.CurrentLevel] = Event Player.LevelTimer;
		End;
		Call Subroutine(UpdateTopScoreboard);
		Small Message(Event Player, Custom String("Use Ultimate + Interact To Restart"));
	}
}

rule("Respawn Player If They Die")
{
	event
	{
		Player Died;
		All;
		All;
	}

	conditions
	{
		Event Player.SpectateMode == False;
	}

	actions
	{
		Respawn(Event Player);
		Wait(0.100, Ignore Condition);
		Call Subroutine(RespawnPlayer);
	}
}

disabled rule("Additional Features")
{
	event
	{
		Ongoing - Global;
	}
}

rule("R -> Quick Reset")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Reload) == True;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Ultimate + Interact -> Reset to Origin Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Ultimate) == True;
		Is Button Held(Event Player, Interact) == True;
		Has Spawned(Event Player) == True;
		"Don't allow this in free roam because otherwise the Doomfist Ultimate cancel bug will happen leaving residual stuff on player's HUD"
		Event Player.FreeRoamEnabled == False;
	}

	actions
	{
		Event Player.CurrentCP = 0;
		Event Player.CurrentLevel = 0;
		Stop Chasing Player Variable(Event Player, LevelTimer);
		Event Player.LevelTimer = 0;
		Call Subroutine(RespawnPlayer);
		Start Forcing Player To Be Hero(Event Player, Global.LevelHeros[0]);
	}
}

rule("Jump + Interact -> Skip Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Jump) == True;
		Is Button Held(Event Player, Interact) == True;
		Event Player.CurrentLevel > 0;
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		"To mitigate conflict with other button combos"
		Is Button Held(Event Player, Crouch) == False;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, LevelTimer);
		Event Player.LevelTimer = 0;
		Event Player.CurrentCP += 1;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Crouch + Interact -> Go Back A Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Crouch) == True;
		Is Button Held(Event Player, Interact) == True;
		Event Player.CurrentLevel > 0;
		Event Player.CurrentCP + 0 > 1;
		"To mitigate conflict with other button combos"
		Is Button Held(Event Player, Jump) == False;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		"To stop you from going back a checkpoint, and the \"Arrive At Next Checkpoint Rule\" from triggering while you are respawning"
		Event Player.BlockArriveAtNextPoint = True;
		Event Player.CurrentCP -= 1;
		Call Subroutine(RespawnPlayer);
		Wait(0.100, Ignore Condition);
		Event Player.BlockArriveAtNextPoint = False;
	}
}

rule("Left Click + Interact -> Camera To See Next Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Make sure next point exists"
		disabled Count Of(Global.CPLocations[Event Player.CurrentLevel]) > Event Player.CurrentCP + 1;
		Is Button Held(Event Player, Primary Fire) == True;
		Is Button Held(Event Player, Interact) == True;
		"Make sure next point exists"
		(Count Of(Global.CPLocations[Event Player.CurrentLevel]) > Event Player.CurrentCP + 1 || Event Player.CurrentLevel == 0) == True;
	}

	actions
	{
		Set Primary Fire Enabled(Event Player, False);
		If(Event Player.CurrentLevel > 0);
			Event Player.TempViewNextPointPosition = Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1];
		Else;
			Event Player.TempViewNextPointPosition = First Of(Sorted Array(Global.LevelOrigins, Angle Between Vectors(Facing Direction Of(
				Event Player), Direction Towards(Position Of(Event Player), Current Array Element))));
		End;
		Set Facing(Event Player, Vector(-10, -10, 0), To World);
		Start Camera(Event Player, Ray Cast Hit Position(Event Player.TempViewNextPointPosition,
			Event Player.TempViewNextPointPosition + Facing Direction Of(Event Player) * -15, All Players(All Teams), Event Player, True),
			Event Player.TempViewNextPointPosition, 30);
		While(Is Button Held(Event Player, Primary Fire) && Is Button Held(Event Player, Interact));
			Wait(0.033, Ignore Condition);
		End;
		Stop Camera(Event Player);
		Set Primary Fire Enabled(Event Player, True);
	}
}

rule("Need Healing Voiceline -> Spectate Other Players")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating(Event Player, Need Healing) == True;
		disabled Is Button Held(Event Player, Melee) == True;
		disabled Is Button Held(Event Player, Interact) == True;
	}

	actions
	{
		Enable Death Spectate Target HUD(All Players(All Teams));
		Enable Death Spectate All Players(All Players(All Teams));
		If(Is Dead(Event Player));
			Enable Built-In Game Mode Respawning(Event Player);
			Resurrect(Event Player);
			Wait(0.100, Ignore Condition);
			Call Subroutine(RespawnPlayer);
			Event Player.SpectateMode = False;
		Else;
			Big Message(Event Player, Custom String("Use \"Need Healing\" voiceline to exit Spectate Mode!"));
			Event Player.SpectateMode = True;
			Disable Built-In Game Mode Respawning(Event Player);
			Kill(Event Player, Null);
		End;
		Set Status(Event Player, Null, Phased Out, 9999);
	}
}

rule("Hello + Interact -> Free Roam")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating(Event Player, Hello) == True;
		Is Button Held(Event Player, Interact) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		If(Event Player.FreeRoamEnabled);
			"Respawn the player so they can't free roam into next checkpoint, then turn off free roam"
			Call Subroutine(RespawnPlayer);
			If(Event Player.LevelTimer > 0 && Event Player.CurrentCP + 1 == Count Of(Global.CPLocations[Event Player.CurrentLevel]));
				Chase Player Variable At Rate(Event Player, LevelTimer, 9999, 1, Destination and Rate);
			End;
			Event Player.FreeRoamEnabled = False;
			Small Message(Event Player, Custom String("Free Roam Disabled"));
		Else;
			Event Player.FreeRoamEnabled = True;
			Stop Chasing Player Variable(Event Player, LevelTimer);
			Small Message(Event Player, Custom String("Free Roam Enabled. Level Timer Paused."));
			"Give all abilities in free roam"
			Set Secondary Fire Enabled(Event Player, True);
			Set Ability 1 Enabled(Event Player, True);
			Set Ability 2 Enabled(Event Player, True);
			Set Ultimate Ability Enabled(Event Player, True);
			Set Ultimate Charge(Event Player, 100);
		End;
	}
}

rule("Ultimate Charge Always 100% In Free Roam")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.FreeRoamEnabled == True;
		Has Spawned(Event Player) == True;
		Ultimate Charge Percent(Event Player) < 100;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 100);
	}
}

rule("Ultimate Status + Interact -> Dev Mode (Host Only)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Interact) == True;
		Is Communicating(Event Player, Ultimate Status) == True;
		Event Player == Host Player;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Global.DevModeEngaged = !Global.DevModeEngaged;
	}
}

rule("Teleport Enabled with Melee + Left Click if done with level, free roam enabled, or dev mode engaged")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Primary Fire) == True;
		Is Button Held(Event Player, Melee) == True;
		disabled Event Player.CurrentLevel > 0;
		(Event Player.FreeRoamEnabled || Global.DevModeEngaged || Event Player.CurrentCP + 1 >= Count Of(
			Global.CPLocations[Event Player.CurrentLevel])) == True;
	}

	actions
	{
		Teleport(Event Player, Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 60 * Facing Direction Of(
			Event Player), All Players(All Teams), Event Player, True));
	}
}

disabled rule("Can Melee Cancel Slam")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		Is Button Held(Event Player, Melee) == True;
	}

	actions
	{
		Cancel Primary Action(Event Player);
		Small Message(Event Player, Custom String("Testing melee slam cancel"));
	}
}

disabled rule("Subroutines")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Subroutine 0: RespawnPlayer")
{
	event
	{
		Subroutine;
		RespawnPlayer;
	}

	actions
	{
		Cancel Primary Action(Event Player);
		"Sigma Barrier Reset"
		If(Hero Of(Event Player) == Hero(Sigma));
			If(Event Player.sigma_barrier_ready_to_destroy);
				Press Button(Event Player, Secondary Fire);
				Wait(0.100, Ignore Condition);
			End;
			Event Player.sigma_barrier_ON = False;
			Event Player.sigma_barrier_ready_to_destroy = False;
		End;
		Call Subroutine(CancelMomentum);
		Disallow Button(Event Player, Secondary Fire);
		Disallow Button(Event Player, Ultimate);
		Disallow Button(Event Player, Ability 1);
		Disallow Button(Event Player, Ability 2);
		Clear Status(Event Player, Phased Out);
		Set Status(Event Player, Null, Phased Out, 9999);
		"Safety check in case rules execute out of order, ie Reset to Origin (Q + Interact) pressed same time and get next level"
		If(Event Player.CurrentCP > 0 && Event Player.CurrentLevel == 0);
			Event Player.CurrentCP = 0;
		End;
		disabled Wait(0.100, Ignore Condition);
		"Set location and facing direction of player"
		Teleport(Event Player, Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP]);
		Set Facing(Event Player, Global.CPFacing[Event Player.CurrentLevel][Event Player.CurrentCP], To World);
		"set player abilities"
		Event Player.PunchUpperSlamUsed = Vector(0, 0, 0);
		If(X Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			If(Hero Of(Event Player) == Hero(Ana));
				Set Primary Fire Enabled(Event Player, False);
			Else;
				Set Secondary Fire Enabled(Event Player, False);
			End;
		Else;
			If(Hero Of(Event Player) == Hero(Ana));
				Set Primary Fire Enabled(Event Player, True);
			Else;
				Set Secondary Fire Enabled(Event Player, True);
			End;
		End;
		If(Y Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			Set Ability 1 Enabled(Event Player, False);
		Else;
			Set Ability 1 Enabled(Event Player, True);
		End;
		If(Z Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			Set Ability 2 Enabled(Event Player, False);
		Else;
			Set Ability 2 Enabled(Event Player, True);
		End;
		If(X Component Of(Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			Set Ultimate Ability Enabled(Event Player, False);
		Else;
			Set Ultimate Ability Enabled(Event Player, True);
		End;
		Set Ultimate Charge(Event Player, 100);
		Wait(0.100, Ignore Condition);
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		If(Event Player.CurrentCP == 0);
			Stop Chasing Player Variable(Event Player, LevelTimer);
			Event Player.LevelTimer = 0;
		End;
		"Redundant, but just in case"
		Event Player.PunchUpperSlamUsed = Vector(0, 0, 0);
		Event Player.Count360Slam125 = Vector(0, 0, 0);
		Allow Button(Event Player, Secondary Fire);
		Allow Button(Event Player, Ability 1);
		Allow Button(Event Player, Ability 2);
		Allow Button(Event Player, Ultimate);
		Set Facing(Event Player, Global.CPFacing[Event Player.CurrentLevel][Event Player.CurrentCP], To World);
		Event Player.WinstonBouncyBubbleCooldown = 0;
		Destroy Effect(Event Player.WinstonBubbleEffect);
		Event Player.WinstonBubbleLocation = Null;
		Set Move Speed(Event Player, 100);
	}
}

rule("Subroutine 1: AutogenerateMapVariables")
{
	event
	{
		Subroutine;
		AutogenerateMapVariables;
	}

	actions
	{
		"Set the checkpoint location to be the closest walkable position to the CPLocation position entered by player. This is so the map maker can use the Camera button to enter CP locations (which sets eye position instead of player position)"
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + 0, 1);
			Global.X = Global.CPLocations[Global.LevelIterator];
			For Global Variable(CPIterator, 0, Count Of(Global.CPLocations[Global.LevelIterator]) - 0, 1);
				Global.X[Global.CPIterator] = Ray Cast Hit Position(Global.X[Global.CPIterator] + Vector(0, 0.100, 0),
					Global.X[Global.CPIterator] + 2 * Down, All Players(All Teams), Event Player, True);
			End;
			Global.CPLocations[Global.LevelIterator] = Global.X;
			"Initialize TopScoreTimes using this For loop as well"
			Global.TopScoreTimes[Global.LevelIterator] = 10000;
		End;
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + -1, 1);
			Global.LevelOrigins[Global.LevelIterator] = Global.CPLocations[Global.LevelIterator + 1][1];
		End;
		"Autogenerate variable arrays"
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + 0, 1);
			"Set CPFacing array to all NULL. NULL means orient player towards direction of next point."
			Global.CPFacing[Global.LevelIterator] = Null;
			"Set CPFacing array to all NULL. NULL means orient player towards direction of next point."
			Global.CPTeleport[Global.LevelIterator] = Null;
			"Set CPRadii array to all DefaultCPRadius (set in \"Initialize Global Constants\" rule)"
			Global.CPRadii[Global.LevelIterator] = Global.DefaultCPRadius;
			"Set Ultimate and other special bindings array to all zeros, as most of the time, these will not be bound to a checkpoint."
			Global.CPUltimate360MaxSlamCounts[Global.LevelIterator] = Vector(0, 0, 0);
			For Global Variable(CPIterator, 1, Count Of(Global.CPLocations[Global.LevelIterator]) - 0, 1);
				Modify Global Variable At Index(CPFacing, Global.LevelIterator, Append To Array, Direction Towards(
					Global.CPLocations[Global.LevelIterator][Global.CPIterator], Global.CPLocations[Global.LevelIterator][Global.CPIterator + 1]));
				Modify Global Variable At Index(CPTeleport, Global.LevelIterator, Append To Array, Null);
				Modify Global Variable At Index(CPRadii, Global.LevelIterator, Append To Array, Global.DefaultCPRadius);
				Modify Global Variable At Index(CPUltimate360MaxSlamCounts, Global.LevelIterator, Append To Array, Vector(0, 0, 0));
			End;
		End;
		For Global Variable(LevelIterator, 1, Count Of(Global.CPLocations), 1);
			Global.LevelNames[Global.LevelIterator] = Custom String("{0} {1}", Hero Icon String(Global.LevelHeros[Global.LevelIterator]),
				Global.LevelNames[Global.LevelIterator]);
		End;
	}
}

rule("Subroutine 2: OverrideAutogenVariables")
{
	event
	{
		Subroutine;
		OverrideAutogenVariables;
	}

	actions
	{
		"OVERRIDING CHECKPOINT PARAMETERS INSTRUCTIONS\r\nStep 1: Copy/paste code block from \"If(Global.LevelIterator == 0)\" to next \"End\" statement\r\nStep 2: Change the 0 in If(Global.LevelIterator == 0) to the level\r\nStep 3: Add the modifiers for that level (see the"
		disabled Wait(0.250, Ignore Condition);
		"Need this whole structure because Workshop Editor doesn't let you index into array's of arrays"
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + 0, 1);
			Global.TempTeleport = Global.CPTeleport[Global.LevelIterator];
			Global.TempUltimate360MaxSlam = Global.CPUltimate360MaxSlamCounts[Global.LevelIterator];
			Global.TempRadii = Global.CPRadii[Global.LevelIterator];
			Global.TempFacing = Global.CPFacing[Global.LevelIterator];
			Call Subroutine(OverrideVariablesUserInput);
			Global.CPFacing[Global.LevelIterator] = Global.TempFacing;
			Global.CPRadii[Global.LevelIterator] = Global.TempRadii;
			Global.CPUltimate360MaxSlamCounts[Global.LevelIterator] = Global.TempUltimate360MaxSlam;
			Global.CPTeleport[Global.LevelIterator] = Global.TempTeleport;
		End;
	}
}

rule("Subroutine 3: Cancel Momentum")
{
	event
	{
		Subroutine;
		CancelMomentum;
	}

	actions
	{
		Apply Impulse(Event Player, Up, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Down, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Left, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Right, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Forward, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Backward, 0.001, To World, Cancel Contrary Motion);
	}
}

rule("Subroutine 5: UpdateTopScoreboard")
{
	event
	{
		Subroutine;
		UpdateTopScoreboard;
	}

	actions
	{
		"Create TOP Scoreboard String"
		Event Player.TopScoreboardString = Custom String("");
		For Player Variable(Event Player, X, Count Of(Global.TopScoreTimes) - 1, -1, -1);
			If(Global.TopScoreTimes[Event Player.X] < 9999);
				If(Event Player.TopScoreboardString == Custom String(""));
					Event Player.TopScoreboardString = Custom String("{0} - {1} {2}", Global.LevelNames[Event Player.X],
						Global.TopScorePlayer[Event Player.X + 0], Global.TopScoreTimes[Event Player.X + 0]);
				Else;
					Event Player.TopScoreboardString = Custom String("{0}\r\n{1}", Event Player.TopScoreboardString, Custom String("{0} - {1} {2}",
						Global.LevelNames[Event Player.X], Global.TopScorePlayer[Event Player.X + 0], Global.TopScoreTimes[Event Player.X + 0]));
				End;
			End;
		End;
		Global.TopScoreString = Event Player.TopScoreboardString;
		"Create All Scoreboard String"
		Event Player.AllScoreboardString = Custom String("");
		For Player Variable(Event Player, X, Count Of(Global.TopScoreTimes) - 1, -1, -1);
			For Player Variable(Event Player, Y, 0, Count Of(All Players(All Teams)), 1);
				If(All Players(All Teams)[Event Player.Y].TopPersonalScores[Event Player.X] < 9999);
					If(All Players(All Teams)[Event Player.Y].TopPersonalScores[Event Player.X] > 0);
						If(Event Player.AllScoreboardString == Custom String(""));
							Event Player.AllScoreboardString = Custom String("{0} - {1} {2}", Global.LevelNames[Event Player.X], All Players(All Teams)
								[Event Player.Y], All Players(All Teams)[Event Player.Y].TopPersonalScores[Event Player.X]);
						Else;
							Event Player.AllScoreboardString = Custom String("{0}\r\n{1}", Event Player.AllScoreboardString, Custom String("{0} - {1} {2}",
								Global.LevelNames[Event Player.X], All Players(All Teams)[Event Player.Y], All Players(All Teams)
								[Event Player.Y].TopPersonalScores[Event Player.X]));
						End;
					End;
				End;
			End;
		End;
		Global.AllScoreString = Event Player.AllScoreboardString;
	}
}

rule("Subroutine 6: GenerateHeroSelectMenuText")
{
	event
	{
		Subroutine;
		GenerateHeroSelectMenuText;
	}

	actions
	{
		Event Player.HeroSelectMenuString = Custom String("Press Melee To Cycle Through Heros");
		For Player Variable(Event Player, Z, 0, Count Of(Global.HeroHelpRoster), 1);
			If(Event Player.Z == Event Player.HeroSelectMenuIndex);
				Event Player.HeroSelectMenuString = Custom String("{0}\r\n{2}{1}", Event Player.HeroSelectMenuString,
					Global.HeroHelpRoster[Event Player.Z], Icon String(Arrow: Right));
			Else;
				Event Player.HeroSelectMenuString = Custom String("{0}\r\n   {1}", Event Player.HeroSelectMenuString,
					Global.HeroHelpRoster[Event Player.Z]);
			End;
		End;
	}
}

disabled rule("360 Code :D")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}
}

rule("Update 360 Array")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Array360[Round To Integer((Horizontal Facing Angle Of(Event Player) + 180) / 90.010, Down)] != True;
		Has Spawned(Event Player) == True;
		"Can't do 360 in starting checkpoint circle"
		Distance Between(Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP], Position Of(Event Player))
			> Global.DefaultCPRadius;
		"So most stalls dont let you 360 for free. Not using \"altitude of\" function because it doesn't work on many roof sides"
		Distance Between(Position Of(Event Player), Ray Cast Hit Position(Position Of(Event Player) + Vector(0, 0.100, 0), Position Of(
			Event Player) + Down * 10, All Players(All Teams), Event Player, True)) > 0.500;
		"So most stalls dont let you 360 for free"
		Altitude Of(Event Player) > 0.500;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		disabled Event Player.Array360[Round To Integer((Horizontal Facing Angle Of(Event Player) + 180) / (360 / Count Of(Event Player.Array360)),
			Down)] = True;
		Event Player.Array360[Round To Integer((Horizontal Facing Angle Of(Event Player) + 180) / 90.010, Down)] = True;
		"Start timer if player has started 360"
		If(Count Of(Filtered Array(Event Player.Array360, Current Array Element == True)) == 2);
			Event Player.Timer360 = 0;
			Chase Player Variable At Rate(Event Player, Timer360, 1, 1, Destination and Rate);
		End;
	}
}

rule("Reset 360 Array after 1 sec")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Timer360 >= 1;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		disabled For Player Variable(Event Player, I, 0, Count Of(Event Player.Array360), 1);
		disabled Event Player.Array360[Event Player.I] = False;
		disabled End;
		Event Player.Array360 = Array(False, False, False, False);
		Event Player.Timer360 = 0;
		Stop Chasing Player Variable(Event Player, Timer360);
	}
}

rule("Successful 360 Detected")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is True For All(Event Player.Array360, Current Array Element) == True;
		Has Spawned(Event Player) == True;
		"Can't do 360 in starting checkpoint circle"
		Distance Between(Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP], Position Of(Event Player))
			> Global.DefaultCPRadius;
		"So most stalls dont let you 360 for free"
		Altitude Of(Event Player) > 0.500;
		"So most stalls dont let you 360 for free. Not using \"altitude of\" function because it doesn't work on many roof sides"
		Distance Between(Position Of(Event Player), Ray Cast Hit Position(Position Of(Event Player) + Vector(0, 0.100, 0), Position Of(
			Event Player) + Down * 10, All Players(All Teams), Event Player, True)) > 0.500;
	}

	actions
	{
		Small Message(Event Player, Custom String("360"));
		Event Player.Count360Slam125 += Left;
		Play Effect(Event Player, Buff Impact Sound, White, Event Player, 60);
		Event Player.Array360 = Array(False, False, False, False);
	}
}

disabled rule("Ability Limits Stuff")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Used Secondary (Rocket Punch)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Left;
	}
}

rule("Used Ability 1 (Uppercut)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Up;
	}
}

rule("Used Ability 2 - Start Slam Timer")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Event Player.SlamTimer = 0;
		Chase Player Variable At Rate(Event Player, SlamTimer, 99, 1, Destination and Rate);
	}
}

rule("Stop slam timer when not using slam or on ground")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		(!Is Using Ability 2(Event Player) || (Is On Ground(Event Player) && Event Player.SlamTimer > 0.200)) == True;
		Has Spawned(Event Player) == True;
		"To stop this rule from double triggering"
		Event Player.SlamTimer > 0;
	}

	actions
	{
		Wait(0.050, Ignore Condition);
		Stop Chasing Player Variable(Event Player, SlamTimer);
		Event Player.SlamTimer = 0;
	}
}

rule("Increment Slam Counter")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		"Prevents invalid slam (where player presses slam button but can't slam) from being counted"
		disabled ((Is On Ground(Event Player) && Event Player.SlamTimer > 0.010 && Event Player.SlamTimer < 0.250) || (
			Event Player.SlamTimer > 0.250)) == True;
		Has Spawned(Event Player) == True;
		Is Using Ability 2(Event Player) == True;
		Event Player.SlamTimer > 0.250;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Forward;
		If(Is On Ground(Event Player));
			Stop Chasing Player Variable(Event Player, SlamTimer);
			Event Player.SlamTimer = 0;
		End;
	}
}

rule("125 Slam Detection")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		"Actual time is 1.53 for 125 slam + cancel, but removing cancel ~.3 sec"
		Event Player.SlamTimer >= 1.220;
		Is Using Ability 2(Event Player) == True;
		"To prevent player from just holding down slam at invalid slam angle to get a 125 slam"
		Is Button Held(Event Player, Ability 2) == False;
	}

	actions
	{
		Event Player.Count360Slam125 += Up;
		Small Message(Event Player, Custom String("125 Slam"));
		Play Effect(Event Player, Buff Impact Sound, White, Event Player, 60);
	}
}

rule("Limiter for Ability Counts")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Is in ability limited level"
		Index Of Array Value(Global.LevelsWithLimitedAbilityCounts, Event Player.CurrentLevel) > -1;
		"Is using an ability"
		(Is Using Ability 1(Event Player) || Is Using Ability 2(Event Player) || Is Firing Secondary(Event Player)) == True;
		"Inside a level, not in multilevel portion"
		Event Player.CurrentCP > 0;
		"Is NOT on last checkpoint of the level"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		"Disable this rule if Free Roam Mode enabled"
		Event Player.FreeRoamEnabled == False;
	}

	actions
	{
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
		If(Y Component Of(Event Player.PunchUpperSlamUsed) >= Y Component Of(
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			Set Ability 1 Enabled(Event Player, False);
		End;
		If(Z Component Of(Event Player.PunchUpperSlamUsed) >= Z Component Of(
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			Set Ability 2 Enabled(Event Player, False);
		End;
		If(X Component Of(Event Player.PunchUpperSlamUsed) >= X Component Of(
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			"Have to wait to disable punch because otherwise it would disable immediately after using preventing punch from working properly."
			Wait(0.400, Ignore Condition);
			"This is to fix interaction with the Quick Reset (R) right after using punch, so this doesn't disable punch after you respawn. Can have slight bug where player is punching through the start location, and doesn't set cooldown properly."
			Abort If(True && Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP])
				< Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP]);
			Set Secondary Fire Enabled(Event Player, False);
		End;
	}
}

disabled rule("Sigma Abilities")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Barrier {1}")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.sigma_barrier_ON = True;
		Event Player.sigma_barrier_init_position = Eye Position(Event Player) + Facing Direction Of(Event Player) * 3;
		Event Player.sigma_barrier_direction = Facing Direction Of(Event Player);
		Event Player.sigma_barrier_chase = 0;
		Chase Player Variable At Rate(Event Player, sigma_barrier_chase, Distance Between(Event Player.sigma_barrier_init_position,
			Ray Cast Hit Position(Event Player.sigma_barrier_init_position,
			Event Player.sigma_barrier_init_position + Event Player.sigma_barrier_direction * 200, Null, Event Player, False)), 16.500,
			Destination and Rate);
		"Updates barrier position"
		While(True);
			Event Player.sigma_barrier_position = Event Player.sigma_barrier_init_position + Event Player.sigma_barrier_direction * Event Player.sigma_barrier_chase;
			Wait(0.016, Ignore Condition);
			Abort If Condition Is False;
		End;
	}
}

rule("Barrier {2}")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == False;
		Event Player.sigma_barrier_ON == True;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, sigma_barrier_chase);
		Wait(0.192, Ignore Condition);
		Event Player.sigma_barrier_ready_to_destroy = True;
	}
}

rule("Barrier Launch")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Event Player.sigma_barrier_ON == True;
		Distance Between(Eye Position(Event Player), Event Player.sigma_barrier_position) < 3;
	}

	actions
	{
		"{Turns shield into a bouncepad instead when turned on}"
		disabled Event Player.sigma_barrier_direction = Vector(X Component Of(Event Player.sigma_barrier_direction), Absolute Value(Y Component Of(
			Event Player.sigma_barrier_direction)), Z Component Of(Event Player.sigma_barrier_direction));
		Apply Impulse(Event Player, Event Player.sigma_barrier_direction, 30, To World, Cancel Contrary Motion);
	}
}

rule("Remove Barrier")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Event Player.sigma_barrier_ready_to_destroy == True;
		Is Button Held(Event Player, Secondary Fire) == True;
	}

	actions
	{
		"Set barrier cooldown here"
		disabled Set Ability Cooldown(Event Player, Button(Secondary Fire), 2);
		Event Player.sigma_barrier_ON = False;
		Wait(0.016, Ignore Condition);
		Event Player.sigma_barrier_ready_to_destroy = False;
	}
}

rule("Destroy Pulse On Death")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dead(Event Player) == True;
	}

	actions
	{
		Event Player.sigma_barrier_ON = False;
		Event Player.sigma_barrier_ready_to_destroy = False;
	}
}

rule("Vortex Drag {By default, using vortex makes you glide across the ground without resetting during the animation}")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Set Gravity(Event Player, 0);
		Set Move Speed(Event Player, 0);
		Wait(2, Restart When True);
		Set Gravity(Event Player, 100);
		Set Move Speed(Event Player, 100);
	}
}

rule("Vortex Refresh")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dead(Event Player) == True;
	}

	actions
	{
		Set Move Speed(Event Player, 100);
		Set Gravity(Event Player, 100);
	}
}

rule("Rock Booster")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		"Rock can be used during the vortex animation"
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Wait(0.650, Ignore Condition);
		Apply Impulse(Event Player, Facing Direction Of(Event Player), -14, To World, Cancel Contrary Motion);
	}
}

disabled rule("WINSTON STUFF")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Initialize Winston")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	actions
	{
		Event Player.WinstonBubbleLocation = Null;
	}
}

rule("Create Bubble")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		"Place Bubble on ground below player. Easier for new players to figure out what's going on (compared to Ray Cast bubble position)."
		Event Player.WinstonBubbleLocation = Position Of(Event Player) + World Vector Of(Forward, Event Player, Rotation)
			* Horizontal Speed Of(Event Player) * 0.300 + Down * Altitude Of(Event Player);
		"Use Ray Cast to determine bubble position"
		disabled Event Player.WinstonBubbleLocation = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 160, All Players(All Teams), Event Player, False);
		If(Distance Between(Event Player.WinstonBubbleLocation, Position Of(Event Player)) > 100);
			Small Message(Event Player, Custom String("Barrier Cast Out Of Range (100m)"));
			Set Ability Cooldown(Event Player, Button(Ability 2), 0);
			Abort;
		End;
		Create Effect(Event Player, Sphere, Blue, Event Player.WinstonBubbleLocation, 5, Visible To Position and Radius);
		Event Player.WinstonBubbleEffect = Last Created Entity;
		Event Player.WinstonBouncyBubbleCooldown = 9;
		Chase Player Variable At Rate(Event Player, WinstonBouncyBubbleCooldown, 0, 1, Destination and Rate);
		While(Event Player.WinstonBouncyBubbleCooldown > 0 && !Is Dead(Event Player));
			Wait(0.100, Ignore Condition);
		End;
		Destroy Effect(Event Player.WinstonBubbleEffect);
		Event Player.WinstonBubbleLocation = Null;
	}
}

rule("Winston Bubble Physics Rule")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Event Player.WinstonBubbleLocation != Null;
		Distance Between(Position Of(Event Player), Event Player.WinstonBubbleLocation) <= 5;
	}

	actions
	{
		"Direct Impulse - Cancel's Player Motion, so physically inaccurate bounce"
		Apply Impulse(Event Player, Direction Towards(Event Player.WinstonBubbleLocation, Position Of(Event Player)), Speed Of(
			Event Player) * 1.300, To World, Cancel Contrary Motion);
	}
}

rule("Winston Wall Climb")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Button Held(Event Player, Jump) == True;
		"Make this so a player can't use wall climb multiple times in a row."
		Event Player.WinstonWallClimbEnabled == True;
	}

	actions
	{
		Event Player.WinstonWallClimbTimer = 4;
		"Set Wall Climb to have a max of 4 sec duration. This prevents you from wall climing against a roof/skybox for indefinite stall."
		Chase Player Variable Over Time(Event Player, WinstonWallClimbTimer, 0, 4, Destination and Duration);
		"Wall Climb while Jump is held, have been wall climbing less than 4 sec, are within 0.5m of wall"
		While(Is Button Held(Event Player, Jump) && Event Player.WinstonWallClimbTimer > 0 && Distance Between(Ray Cast Hit Position(
			Eye Position(Event Player), Eye Position(Event Player) + Direction From Angles(Horizontal Angle From Direction(
			Facing Direction Of(Event Player)), 0) * 10, All Players(All Teams), Event Player, True), Eye Position(Event Player)) < 3);
			Wait(0.033, Ignore Condition);
			Set Move Speed(Event Player, 0);
			Apply Impulse(Event Player, Up, 7, To World, Cancel Contrary Motion);
			Apply Impulse(Event Player, Forward, 1, To Player, Cancel Contrary Motion);
			Event Player.WinstonWallClimbEnabled = False;
		End;
		Set Move Speed(Event Player, 100);
		Wait(0.033, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Wall Climb Reset When On Ground")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
	}

	actions
	{
		Event Player.WinstonWallClimbEnabled = True;
	}
}

disabled rule("ANA MODIFIERS")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Ana Primary Impulse")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ana;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
		Has Status(Event Player, Rooted) == False;
		disabled Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Set Gravity(Event Player, 0);
		Apply Impulse(Event Player, Facing Direction Of(Event Player), 15, To World, Cancel Contrary Motion);
		Wait(0.060, Ignore Condition);
		Set Gravity(Event Player, 100);
	}
}

rule("Ana Sleep Dart Teleport")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ana;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Stop Camera(Event Player);
		"The duration before Ana fires sleep dart"
		Wait(0.300, Ignore Condition);
		Event Player.AnaSleepDartTeleLocation = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 180, All Players(All Teams), Event Player, True);
		"Shorten ray cast to avoid unintended tele through surfaces"
		Event Player.AnaSleepDartTeleLocation -= Direction Towards(Eye Position(Event Player), Event Player.AnaSleepDartTeleLocation)
			* 0.500;
		If(Y Component Of(Event Player.AnaSleepDartTeleLocation) > 24);
			Small Message(Event Player, Custom String("Teleport location elevation too high"));
			Cancel Primary Action(Event Player);
			Wait(0.100, Ignore Condition);
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
			Abort;
		End;
		"Sleep dart travel time"
		Wait(Distance Between(Eye Position(Event Player), Event Player.AnaSleepDartTeleLocation) / 60, Ignore Condition);
		Teleport(Event Player, Event Player.AnaSleepDartTeleLocation);
		Call Subroutine(CancelMomentum);
		disabled Small Message(Event Player, Custom String("{0} alt {1}", Event Player.AnaSleepDartTeleLocation, Altitude Of(Event Player)));
	}
}

rule("Heal = Impulse {must be damaged when spawning}")
{
	event
	{
		Player Dealt Healing;
		All;
		Ana;
	}

	conditions
	{
		Healee == Healer;
		Has Status(Event Player, Rooted) == False;
	}

	actions
	{
		Apply Impulse(Event Player, Facing Direction Of(Event Player), -15, To World, Cancel Contrary Motion);
		Wait(1, Ignore Condition);
	}
}

rule("Ana Health Managment")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ana;
	}

	conditions
	{
		Normalized Health(Event Player) >= 1;
		Is In Spawn Room(Event Player) != True;
	}

	actions
	{
		Clear Status(Event Player, Phased Out);
		Damage(Event Player, Event Player, 50);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
		Set Status(Event Player, Null, Phased Out, 9999);
	}
}

disabled rule("ROADHOG STUFF")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Change Hook to Grappling Hook")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		"Initial impulse to let you hook in midair without falling too far while hook is out"
		Apply Impulse(Event Player, Up, 3, To World, Cancel Contrary Motion);
		"Issue here is that we are using ray cast to determine hook impact, which isn't visually accurate, so the hook may impact a wall but not be deteted."
		Event Player.RoadhogHookPosition = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ 120 * Facing Direction Of(Event Player), All Players(All Teams), Event Player, True);
		"Abort if hook didn't connect with a wall within 25m. For reference, 20m is hook range for normal roadhog."
		If(Distance Between(Position Of(Event Player), Event Player.RoadhogHookPosition) > 25);
			Small Message(Event Player, Custom String("Out of hook range!"));
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
			Abort;
		End;
		"Wait for hook to \"hit\" something. Hook moves at 40m/s"
		Wait(Distance Between(Position Of(Event Player), Event Player.RoadhogHookPosition) / 40, Ignore Condition);
		"Impulse that increases with hook range. Hook impulse = Base Impulse + Hook Range x Range Multiplier."
		Apply Impulse(Event Player, Direction Towards(Position Of(Event Player), Event Player.RoadhogHookPosition), 20 + Distance Between(
			Event Player.RoadhogHookPosition, Position Of(Event Player)) * 0.800, To World, Cancel Contrary Motion);
		"Large Linear Impulse. Disabled while testing impulse that increases with range."
		disabled Apply Impulse(Event Player, Direction Towards(Position Of(Event Player), Event Player.RoadhogHookPosition), 40, To World,
			Cancel Contrary Motion);
	}
}

rule("Change Take A Breather to Bouncy Ball Hog")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		disabled Is On Ground(Event Player) == True;
		Altitude Of(Event Player) <= 1.500;
	}

	actions
	{
		Apply Impulse(Event Player, Up, Speed Of(Event Player) * 1.200, To World, Cancel Contrary Motion);
	}
}

rule("Add Knockback When Secondary Fire Used")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Apply Impulse(Event Player, Facing Direction Of(Event Player), -12, To World, Cancel Contrary Motion);
	}
}

rule("Roadhog Ultimate")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Small Message(Event Player, Custom String("Hold Melee to Cancel Ultimate"));
		While(Is Using Ultimate(Event Player) && !Is Button Held(Event Player, Melee));
			Wait(0.066, Ignore Condition);
			"Cause knockback on player"
			disabled Apply Impulse(Event Player, Facing Direction Of(Event Player), -10, To World, Cancel Contrary Motion);
			"Player Knockback"
			Apply Impulse(Event Player, Facing Direction Of(Event Player), -1.500, To World, Cancel Contrary Motion);
			"\"Drill\" Through Walls, Skyboxes, etc."
			Teleport(Event Player, Position Of(Event Player) + Facing Direction Of(Event Player) * -1.500);
		End;
		"For melee cancel on ult"
		Cancel Primary Action(Event Player);
	}
}

rule("Limit Roadhog Ultimate Duration")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		"Set Ult Duration to 3 sec, then cancel it"
		Wait(3, Ignore Condition);
		Cancel Primary Action(Event Player);
	}
}

disabled rule("MOIRA STUFF")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Camera follow orb position model")
{
	event
	{
		Ongoing - Each Player;
		All;
		Moira;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		(Is Button Held(Event Player, Primary Fire) || Is Button Held(Event Player, Secondary Fire)) == True;
	}

	actions
	{
		Small Message(Event Player, Custom String("Melee To Teleport"));
		Event Player.MoiraOrbPosition = Eye Position(Event Player);
		Event Player.MoiraOrbFacing = Facing Direction Of(Event Player);
		Start Camera(Event Player, Event Player.MoiraOrbPosition, Event Player.MoiraOrbPosition + Event Player.MoiraOrbFacing, 30);
		Event Player.MoiraOrbTimer = 7;
		Chase Player Variable At Rate(Event Player, MoiraOrbTimer, 0, 1, Destination and Rate);
		While(Event Player.MoiraOrbTimer > 0 && !Is Button Held(Event Player, Melee) && True);
			If(Distance Between(Event Player.MoiraOrbPosition, Ray Cast Hit Position(Event Player.MoiraOrbPosition,
				Event Player.MoiraOrbPosition + Event Player.MoiraOrbFacing, Null, Null, False)) < 0.750);
				"Bounce detected - set new direction of orb as r = d - 2(d dot n)n where d is current direction, n is normal vector, r is new vector"
				Event Player.MoiraOrbFacing = Event Player.MoiraOrbFacing - 2 * Dot Product(Event Player.MoiraOrbFacing, Ray Cast Hit Normal(
					Event Player.MoiraOrbPosition, Event Player.MoiraOrbPosition + Event Player.MoiraOrbFacing, Null, Null, False))
					* Ray Cast Hit Normal(Event Player.MoiraOrbPosition, Event Player.MoiraOrbPosition + Event Player.MoiraOrbFacing, Null, Null,
					False);
			Else;
				Event Player.MoiraOrbPosition += Event Player.MoiraOrbFacing * 0.320 * 0.660;
			End;
			Wait(0.016, Ignore Condition);
		End;
		Stop Camera(Event Player);
		Teleport(Event Player, Event Player.MoiraOrbPosition);
	}
}

rule("Right Click")
{
	event
	{
		Ongoing - Each Player;
		All;
		Moira;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == False;
		Is Button Held(Event Player, Secondary Fire) == True;
		Ability Resource(Event Player, Button(Primary Fire)) > 0;
		"Give right click a 20m range, same as in game range"
		Distance Between(Eye Position(Event Player), Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 30, Null, Null, False)) < 20;
	}

	actions
	{
		Set Ability Resource(Event Player, Button(Primary Fire), Ability Resource(Event Player, Button(Primary Fire)) - 1);
		Apply Impulse(Event Player, Facing Direction Of(Event Player), 4, To World, Incorporate Contrary Motion);
		Wait(0.100, Ignore Condition);
		Loop If Condition Is True;
	}
}