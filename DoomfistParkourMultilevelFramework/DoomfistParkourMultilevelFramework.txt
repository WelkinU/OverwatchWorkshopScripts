settings
{
	modes
	{
		Assault
		{
			enabled maps
			{
			}
		}

		Control
		{
			enabled maps
			{
				Nepal
			}
		}

		Escort
		{
			enabled maps
			{
			}
		}

		Hybrid
		{
			enabled maps
			{
			}
		}

		General
		{
			Hero Limit: Off
			Kill Cam: Off
			Kill Feed: Off
			Respawn Time Scalar: 10%
		}
	}

	heroes
	{
		General
		{
			enabled heroes
			{
				Doomfist
			}
		}
	}
}

variables
{
	global:
		0: CPLocations
		1: LevelDescriptions
		2: CPFacing
		3: CPPunchUpperSlamCounts
		4: CPUltimate360MaxSlamCounts
		5: CPTeleport
		6: CPRadii
		7: LevelsWithLimitedAbilityCounts
		8: CountPunchUpperSlam
		9: TopScoreTimes
		10: TopScorePlayer
		11: TopScoreString
		17: CPRadius
		19: TempTeleport
		20: TempUltimate
		21: TempRadii
		22: TempFacing
		24: CPIterator
		25: LevelIterator

	player:
		0: CurrentCP
		1: CurrentLevel
		3: LevelTimer
		4: PunchUpperSlamUsed
		14: SlamTimer
		22: ScoreboardString
		23: ScoreboardIterator
		34: Count360Slam125
}

subroutines
{
	0: RespawnPlayer
	1: AutogenerateMapVariables
	2: OverrideAutogenVariables
	3: CancelMomentum
	4: OverrideVariablesUserInput
	5: UpdateTopScoreboard
}

rule("UPDATE MAP CONSTANTS HERE - CHECKPOINTS, ABILITIES")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"MAP MAKING INSTRUCTIONS\r\nStep 1: level checkpoints and abilities below\r\nStep 2: CP facing/radii/teleports/ultimates are autogenerated - override using the rule below this one"
		disabled Wait(0.250, Ignore Condition);
		"Default Checkpoint Radius"
		Global.CPRadius = 2;
		"Add to this array the level numbers of levels you want to have ability limits on"
		Global.LevelsWithLimitedAbilityCounts = Array(2);
		"Set level descriptions here, make sure the level number matches the index (ie. make sure Level 1 is on index 1)"
		Global.LevelDescriptions = Array(Null, Custom String("Level 1 (Easy)"), Custom String("Level 2 (Medium)"));
		"Set the starting position when the player loads into the game"
		Global.CPLocations = Array(Array(Vector(-48.400, 9.800, -21.400)));
		"Set the starting position abilities when the player loads into the game"
		Global.CPPunchUpperSlamCounts = Array(Array(Vector(1, 1, 0)));
		"--------------Set Level 1 Parameters. Set CPLocations Index to level number--------------"
		Global.CPLocations[1] = Array(Vector(-49.996, 17.888, -34.854), Vector(-49.499, 20.473, -51.380), Vector(-32.470, 22.530, -51.041),
			Vector(-33.992, 20.454, -13.367), Vector(-187.388, -90.726, -71.649), Vector(-185.611, -81.306, -40.293));
		Global.CPPunchUpperSlamCounts[1] = Array(Vector(1, 1, 1), Vector(0, 1, 1), Vector(1, 1, 0), Vector(1, 1, 1), Vector(1, 1, 1),
			Vector(1, 1, 1));
		"--------------Set Level 2 Parameters. Set CPLocations Index to level number--------------"
		Global.CPLocations[2] = Array(Vector(-37.078, 14.583, -8.837), Vector(-33.992, 20.453, 23.297), Vector(-35.471, 22.495, 53.428));
		Global.CPPunchUpperSlamCounts[2] = Array(Vector(1, 1, 0), Vector(1, 1, 0), Vector(1, 1, 1), Vector(1, 1, 1));
		"Autogenerate checkpoint facing, radii, and other variables based on CPLocations"
		Call Subroutine(AutogenerateMapVariables);
		"Override autogenerated variables based on rule right below this one"
		Call Subroutine(OverrideAutogenVariables);
	}
}

rule("UPDATE MAP CONSTANTS HERE -  SET TELEPORTS, ULTIMATE ENABLE, OVERRIDE CP RADII / FACING HERE")
{
	event
	{
		Subroutine;
		OverrideVariablesUserInput;
	}

	actions
	{
		"OVERRIDING CHECKPOINT PARAMETERS INSTRUCTIONS\r\nStep 1: Copy/paste code block from \"If(Global.LevelIterator == 0)\" to next \"End\" statement\r\nStep 2: Change the 0 in If(Global.LevelIterator == 0) to the level\r\nStep 3: Add the modifiers for that level (see the"
		disabled Wait(0.250, Ignore Condition);
		"------------------Use this code block to set Level 0 modifiers------------------"
		If(Global.LevelIterator == 0);
			"Example: Use this code to override CP 0 radius to be 5m"
			Global.TempRadii[0] = 5;
			"Example: Code block to override Level 0 CP 0 facing direction (1,0,0)"
			Global.TempFacing[0] = Vector(1, 0, 0);
		End;
		"------------------Use this code block to set Level 1 modifiers------------------"
		If(Global.LevelIterator == 1);
			"Example: Use this code to override CP 3 to enable Ultimate"
			Global.TempUltimate[3] = Vector(1, 0, 0);
			"Example: Use this code to override CP 3 to enable Ultimate"
			Global.TempTeleport[4] = True;
		End;
	}
}

disabled rule("Initialize Player and Map")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Initialize Other Global Constants")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.TopScoreString = Custom String("");
	}
}

rule("Initialize Global HUD and Effects")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Wait for Map Checkpoints, radii, etc to get generated. Prevents this rule from running out of order with map generation rules."
		Wait(0.200, Ignore Condition);
		"Create Origin Point Ring"
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0), Ring, Purple, Global.CPLocations[0][0],
			Global.CPRadii[0][0], Visible To);
		For Global Variable(LevelIterator, 1, Count Of(Global.CPLocations), 1);
			"Create Level Entry Rings"
			Create Effect(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0), Ring, Purple,
				Global.CPLocations[Global.LevelIterator][1], Global.CPRadii[Global.LevelIterator][1], Visible To);
			Create In-World Text(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0), Custom String("{0}",
				Global.LevelDescriptions[Global.LevelIterator]), Global.CPLocations[Global.LevelIterator][1], 2, Do Not Clip, Visible To,
				Purple, Default Visibility);
			Create Icon(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0),
				Global.CPLocations[Global.LevelIterator][1], Flag, Visible To, Yellow, True);
		End;
		"Hide Game HUD"
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(
			" \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"),
			Top, 0, White, White, White, Visible To and String, Default Visibility);
		"Top Scores HUD"
		Create HUD Text(Filtered Array(All Players(All Teams), Global.TopScoreString != Custom String("")), Null, Null, Custom String(
			"-------------Top Scores-------------\r\n{0}\r\n-------------------------------------------------", Global.TopScoreString),
			Left, 0, White, White, White, Visible To and String, Default Visibility);
	}
}

rule("Initialize Player")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Event Player.CurrentCP = 0;
		Event Player.CurrentLevel = 0;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Initialize Player HUD and Effects")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Create HUD Text(Event Player, Null, Null, Custom String("Level {0} Checkpoint {1} - Time {2}", Event Player.CurrentLevel,
			Event Player.CurrentCP - 0, Event Player.LevelTimer), Top, -2, White, White, White, Visible To and String, Default Visibility);
		"Create Current Checkpoint Ring"
		Create Effect(Filtered Array(Event Player, Current Array Element.CurrentCP > 0), Ring, Purple,
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP],
			Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP], Visible To Position and Radius);
		"Create Current Checkpoint Ring"
		Create Effect(Filtered Array(Event Player, Current Array Element.CurrentCP > 0), Ring, Purple,
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1],
			Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 1], Visible To Position and Radius);
		"Create Current Checkpoint Ring"
		Create Icon(Filtered Array(Event Player, Current Array Element.CurrentCP > 0),
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1], Flag, Visible To and Position, Yellow, True);
	}
}

disabled rule("Map Building Convenience Features - UNCOMMENT THESE WHEN BUILDING MAP")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}
}

rule("Map Building HUD")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Create HUD Text(Event Player, Custom String("Position {0}\r\nFacing {1}", Position Of(Event Player), Facing Direction Of(
			Event Player)), Null, Null, Right, 0, White, White, White, Visible To and String, Default Visibility);
	}
}

rule("Teleport Enabled with Melee + Left Click")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Primary Fire) == True;
		Is Button Held(Event Player, Melee) == True;
	}

	actions
	{
		Teleport(Event Player, Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 60 * Facing Direction Of(
			Event Player), All Players(All Teams), Event Player, True));
	}
}

disabled rule("Subroutines")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Subroutine 0: RespawnPlayer")
{
	event
	{
		Subroutine;
		RespawnPlayer;
	}

	actions
	{
		Call Subroutine(CancelMomentum);
		Clear Status(Event Player, Phased Out);
		Set Status(Event Player, Null, Phased Out, 9999);
		Cancel Primary Action(Event Player);
		"Set location and facing direction of player"
		Teleport(Event Player, Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP]);
		Set Facing(Event Player, Global.CPFacing[Event Player.CurrentLevel][Event Player.CurrentCP], To World);
		"set player abilities"
		Event Player.PunchUpperSlamUsed = Vector(0, 0, 0);
		If(X Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			Set Secondary Fire Enabled(Event Player, False);
		Else;
			Set Secondary Fire Enabled(Event Player, True);
		End;
		If(Y Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			Set Ability 1 Enabled(Event Player, False);
		Else;
			Set Ability 1 Enabled(Event Player, True);
		End;
		If(Z Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			Set Ability 2 Enabled(Event Player, False);
		Else;
			Set Ability 2 Enabled(Event Player, True);
		End;
		If(X Component Of(Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			Set Ultimate Ability Enabled(Event Player, False);
		Else;
			Set Ultimate Ability Enabled(Event Player, True);
		End;
		Set Ultimate Charge(Event Player, 100);
		Wait(0.100, Ignore Condition);
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		If(Event Player.CurrentCP == 0);
			Stop Chasing Player Variable(Event Player, LevelTimer);
			Event Player.LevelTimer = 0;
		End;
	}
}

rule("Subroutine 1: AutogenerateMapVariables")
{
	event
	{
		Subroutine;
		AutogenerateMapVariables;
	}

	actions
	{
		"Set the checkpoint location to be the closest walkable position to the CPLocation position entered by player. This is so the map maker can use the Camera button to enter CP locations (which sets eye position instead of player position)"
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + 0, 1);
			Global.X = Global.CPLocations[Global.LevelIterator];
			For Global Variable(CPIterator, 0, Count Of(Global.CPLocations[Global.LevelIterator]) - 0, 1);
				Global.X[Global.CPIterator] = Ray Cast Hit Position(Global.X[Global.CPIterator] + Vector(0, 0.100, 0),
					Global.X[Global.CPIterator] + 2 * Down, All Players(All Teams), Event Player, True);
			End;
			Global.CPLocations[Global.LevelIterator] = Global.X;
			"Initialize TopScoreTimes using this For loop as well"
			Global.TopScoreTimes[Global.LevelIterator] = 10000;
		End;
		"Add origin point to beginning of each level's CP locations so we can index conveniently into CPLocations"
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + 0, 1);
			Global.CPLocations[Global.LevelIterator] = Append To Array(Array(Global.CPLocations[0][0]),
				Global.CPLocations[Global.LevelIterator]);
			Global.CPPunchUpperSlamCounts[Global.LevelIterator] = Append To Array(Array(Global.CPPunchUpperSlamCounts[0][0]),
				Global.CPPunchUpperSlamCounts[Global.LevelIterator]);
		End;
		"Add origin point to beginning of each level's CP locations so we can index conveniently into CPLocations"
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + 0, 1);
			"Set CPFacing array to all NULL. NULL means orient player towards direction of next point."
			Global.CPFacing[Global.LevelIterator] = Null;
			"Set CPFacing array to all NULL. NULL means orient player towards direction of next point."
			Global.CPTeleport[Global.LevelIterator] = Null;
			"Set CPRadii array to all DefaultCPRadius (set in \"Initialize Global Constants\" rule)"
			Global.CPRadii[Global.LevelIterator] = Global.CPRadius;
			"Set Ultimate and other special bindings array to all zeros, as most of the time, these will not be bound to a checkpoint."
			Global.CPUltimate360MaxSlamCounts[Global.LevelIterator] = Vector(0, 0, 0);
			For Global Variable(CPIterator, 1, Count Of(Global.CPLocations[Global.LevelIterator]) - 0, 1);
				Modify Global Variable At Index(CPFacing, Global.LevelIterator, Append To Array, Direction Towards(
					Global.CPLocations[Global.LevelIterator][Global.CPIterator], Global.CPLocations[Global.LevelIterator][Global.CPIterator + 1]));
				Modify Global Variable At Index(CPTeleport, Global.LevelIterator, Append To Array, Null);
				Modify Global Variable At Index(CPRadii, Global.LevelIterator, Append To Array, Global.CPRadius);
				Modify Global Variable At Index(CPUltimate360MaxSlamCounts, Global.LevelIterator, Append To Array, Vector(0, 0, 0));
			End;
		End;
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + -1, 1);
			Global.CountPunchUpperSlam[Global.LevelIterator] = Global.CPLocations[Global.LevelIterator + 1][1];
		End;
	}
}

rule("Subroutine 2: OverrideAutogenVariables")
{
	event
	{
		Subroutine;
		OverrideAutogenVariables;
	}

	actions
	{
		"OVERRIDING CHECKPOINT PARAMETERS INSTRUCTIONS\r\nStep 1: Copy/paste code block from \"If(Global.LevelIterator == 0)\" to next \"End\" statement\r\nStep 2: Change the 0 in If(Global.LevelIterator == 0) to the level\r\nStep 3: Add the modifiers for that level (see the"
		disabled Wait(0.250, Ignore Condition);
		"Need this whole structure because Workshop Editor doesn't let you index into array's of arrays"
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + 0, 1);
			Global.TempTeleport = Global.CPTeleport[Global.LevelIterator];
			Global.TempUltimate = Global.CPUltimate360MaxSlamCounts[Global.LevelIterator];
			Global.TempRadii = Global.CPRadii[Global.LevelIterator];
			Global.TempFacing = Global.CPFacing[Global.LevelIterator];
			Call Subroutine(OverrideVariablesUserInput);
			Global.CPFacing[Global.LevelIterator] = Global.TempFacing;
			Global.CPRadii[Global.LevelIterator] = Global.TempRadii;
			Global.CPUltimate360MaxSlamCounts[Global.LevelIterator] = Global.TempUltimate;
			Global.CPTeleport[Global.LevelIterator] = Global.TempTeleport;
		End;
	}
}

rule("Subroutine 3: Cancel Momentum")
{
	event
	{
		Subroutine;
		CancelMomentum;
	}

	actions
	{
		Apply Impulse(Event Player, Up, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Down, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Left, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Right, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Forward, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Backward, 0.001, To World, Cancel Contrary Motion);
	}
}

rule("Subroutine 5: UpdateTopScoreboard")
{
	event
	{
		Subroutine;
		UpdateTopScoreboard;
	}

	actions
	{
		Event Player.ScoreboardString = Custom String("");
		For Player Variable(Event Player, ScoreboardIterator, Count Of(Global.TopScoreTimes) - 1, -1, -1);
			If(Global.TopScoreTimes[Event Player.ScoreboardIterator] < 10000);
				If(Event Player.ScoreboardString == Custom String(""));
					Event Player.ScoreboardString = Custom String("Level {0} - {1} {2}", Event Player.ScoreboardIterator + 0,
						Global.TopScorePlayer[Event Player.ScoreboardIterator + 0], Global.TopScoreTimes[Event Player.ScoreboardIterator + 0]);
				Else;
					Event Player.ScoreboardString = Custom String("{0}\r\n{1}", Event Player.ScoreboardString, Custom String("Level {0} - {1} {2}",
						Event Player.ScoreboardIterator + 0, Global.TopScorePlayer[Event Player.ScoreboardIterator + 0],
						Global.TopScoreTimes[Event Player.ScoreboardIterator + 0]));
				End;
			End;
		End;
		Global.TopScoreString = Event Player.ScoreboardString;
	}
}

disabled rule("Multi-Level Framework")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Enter Into Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Count Of(Filtered Array(Global.CountPunchUpperSlam, Distance Between(Current Array Element, Position Of(Event Player)) < 2)) > 0;
		Is On Ground(Event Player) == True;
		Event Player.CurrentCP == 0;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Play Effect(Event Player, Buff Explosion Sound, White, Event Player, 60);
		Event Player.CurrentCP = 1;
		Event Player.CurrentLevel = Index Of Array Value(Global.CountPunchUpperSlam, First Of(Filtered Array(Global.CountPunchUpperSlam,
			Distance Between(Position Of(Event Player), Current Array Element) < 2))) + 1;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Touched ground without entering level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Count Of(Filtered Array(Global.CountPunchUpperSlam, Distance Between(Current Array Element, Position Of(Event Player)) < 2)) == 0;
		Is On Ground(Event Player) == True;
		Event Player.CurrentCP == 0;
		Has Spawned(Event Player) == True;
		"Not on current checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 0])
			> Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 0];
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Start Timer When Player Leaves Origin Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Distance Between(Position Of(Event Player), Global.CPLocations[0][0]) > Global.CPRadii[0][0];
		Event Player.CurrentCP <= 0;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		"To prevent this rule from triggering before the rule that tele's player to start point"
		Wait(0.250, Abort When False);
		Event Player.LevelTimer = 0;
		Chase Player Variable At Rate(Event Player, LevelTimer, 99999, 1, Destination and Rate);
	}
}

rule("Arrived At Next Checkpoint")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Within range of next checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1])
			< Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 1];
		"Player has selected a level"
		Event Player.CurrentCP > 0;
		Is On Ground(Event Player) == True;
		"Is not on last checkpoint in level"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		Event Player.CurrentLevel > 0;
	}

	actions
	{
		Event Player.CurrentCP += 1;
		Play Effect(Event Player, Buff Explosion Sound, White, Event Player, 60);
		If(Global.CPTeleport[Event Player.CurrentLevel][Event Player.CurrentCP] != Null);
			Event Player.CurrentCP += 1;
		End;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Respawn If Touched Ground Not On Checkpoints")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Not on current checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 0])
			> Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 0];
		"Not within range of next checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1])
			> Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 1];
		"Player has selected a level"
		Event Player.CurrentCP > 0;
		Is On Ground(Event Player) == True;
		"Is not on last checkpoint in level"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Finished Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Is on last checkpoint in level"
		Event Player.CurrentCP + 1 == Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		Event Player.CurrentCP > 0;
		Event Player.CurrentLevel > 0;
		Event Player.LevelTimer > 0;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, LevelTimer);
		Big Message(All Players(All Teams), Custom String("{0} Finished Level {1} in {2}sec", Event Player, Event Player.CurrentLevel,
			Event Player.LevelTimer));
		"If player got top score, update top scores"
		If(Event Player.LevelTimer < Global.TopScoreTimes[Event Player.CurrentLevel]);
			Global.TopScoreTimes[Event Player.CurrentLevel] = Event Player.LevelTimer;
			Global.TopScorePlayer[Event Player.CurrentLevel] = Event Player;
		End;
		Call Subroutine(UpdateTopScoreboard);
	}
}

disabled rule("Additional Features")
{
	event
	{
		Ongoing - Global;
	}
}

rule("R -> Quick Reset")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Reload) == True;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Ultimate + Interact -> Reset to Origin Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Ultimate) == True;
		Is Button Held(Event Player, Interact) == True;
	}

	actions
	{
		Event Player.CurrentCP = 0;
		Event Player.CurrentLevel = 0;
		Stop Chasing Player Variable(Event Player, LevelTimer);
		Event Player.LevelTimer = 0;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Jump + Interact -> Skip Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Jump) == True;
		Is Button Held(Event Player, Interact) == True;
		Event Player.CurrentLevel > 0;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, LevelTimer);
		Event Player.LevelTimer = 0;
		Event Player.CurrentCP += 1;
		Call Subroutine(RespawnPlayer);
	}
}

disabled rule("Ability Limits Stuff")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Used Secondary (Rocket Punch)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Left;
	}
}

rule("Used Ability 1 (Uppercut)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Up;
	}
}

rule("Used Ability 2 - Start Slam Timer")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Event Player.SlamTimer = 0;
		Chase Player Variable At Rate(Event Player, SlamTimer, 99, 1, Destination and Rate);
	}
}

rule("Used Ability 2 + 125 Slam Detector")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == False;
		Has Spawned(Event Player) == True;
		"To stop this rule from double triggering"
		Event Player.SlamTimer > 0;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, SlamTimer);
		"Prevent invalid slam (where press slam button but you are not allowed to slam) from counting as a slam. Matters for ability count limits."
		disabled If(Is On Ground(Event Player) || Event Player.SlamTimer >= 0.250);
		disabled Event Player.PunchUpperSlamUsed += Forward;
		disabled End;
		"Detect 125 slam. Formula is Slam Damage = 100 * (Slam Time) - 28, so 125 slam requires at least 1.53 sec of slam time."
		disabled If(Event Player.SlamTimer >= 1.520);
		disabled Event Player.Count360Slam125 += Up;
		disabled Small Message(Event Player, Custom String("125 Slam"));
		disabled Play Effect(Event Player, Buff Impact Sound, White, Event Player, 60);
		disabled End;
		Event Player.SlamTimer = 0;
	}
}

rule("Increment Slam Counter")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		"Prevents invalid slam (where player presses slam button but can't slam) from being counted"
		((Is On Ground(Event Player) && Event Player.SlamTimer > 0.040 && Event Player.SlamTimer < 0.250) || (
			Event Player.SlamTimer > 0.250)) == True;
		Has Spawned(Event Player) == True;
		Is Using Ability 2(Event Player) == True;
		disabled Event Player.SlamTimer > 0.250;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Forward;
		If(Is On Ground(Event Player));
			Stop Chasing Player Variable(Event Player, SlamTimer);
			Event Player.SlamTimer = 0;
		End;
	}
}

rule("125 Slam Detection")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		"Actual time is 1.53 for 125 slam + cancel, but removing cancel ~.3 sec"
		Event Player.SlamTimer >= 1.220;
		Is Using Ability 2(Event Player) == True;
		"To prevent player from just holding down slam at invalid slam angle to get a 125 slam"
		Is Button Held(Event Player, Ability 2) == False;
	}

	actions
	{
		Event Player.Count360Slam125 += Up;
		Small Message(Event Player, Custom String("125 Slam"));
		Play Effect(Event Player, Buff Impact Sound, White, Event Player, 60);
	}
}

rule("Limiter for Ability Counts")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Is in ability limited level"
		Index Of Array Value(Global.LevelsWithLimitedAbilityCounts, Event Player.CurrentLevel) > -1;
		"Is using an ability"
		(Is Using Ability 1(Event Player) || Is Using Ability 2(Event Player) || Is Firing Secondary(Event Player)) == True;
		"Inside a level, not in multilevel portion"
		Event Player.CurrentCP > 0;
		"Is NOT on last checkpoint of the level"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
	}

	actions
	{
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
		If(Y Component Of(Event Player.PunchUpperSlamUsed) >= Y Component Of(
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			Set Ability 1 Enabled(Event Player, False);
		End;
		If(Z Component Of(Event Player.PunchUpperSlamUsed) >= Z Component Of(
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			Set Ability 2 Enabled(Event Player, False);
		End;
		If(X Component Of(Event Player.PunchUpperSlamUsed) >= X Component Of(
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			"Have to wait to disable punch because otherwise it would disable immediately after using preventing punch from working properly."
			Wait(0.400, Ignore Condition);
			"This is to fix interaction with the Quick Reset (R) right after using punch, so this doesn't disable punch after you respawn. Can have slight bug where player is punching through the start location, and doesn't set cooldown properly."
			Abort If(True && Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP])
				< Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP]);
			Set Secondary Fire Enabled(Event Player, False);
		End;
	}
}