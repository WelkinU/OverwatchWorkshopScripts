settings
{
	main
	{
		Description: "Doomfist Parkour Illios! MultiLevel Framework with meteor strike, view next point ability, spectate mode, ability limit levels, 360's and max slam detectors by WelkinTern. Make a Pull Request on the code repository: https://github.com/WelkinU/OverwatchWorkshopScripts/tree/master/DoomfistParkourMultilevelFramework"
	}

	modes
	{
		Assault
		{
			enabled maps
			{
			}
		}

		Control
		{
			enabled maps
			{
				Ilios
			}
		}

		Escort
		{
			enabled maps
			{
			}
		}

		Hybrid
		{
			enabled maps
			{
			}
		}

		General
		{
			Hero Limit: Off
			Kill Cam: Off
			Kill Feed: Off
			Respawn Time Scalar: 10%
		}
	}

	heroes
	{
		General
		{
			enabled heroes
			{
				Doomfist
			}
		}
	}
}

variables
{
	global:
		0: CPLocations
		1: LevelNames
		2: CPFacing
		3: CPPunchUpperSlamCounts
		4: CPUltimate360MaxSlamCounts
		5: CPTeleport
		6: CPRadii
		7: LevelsWithLimitedAbilityCounts
		8: LevelOrigins
		9: TopScoreTimes
		10: TopScorePlayer
		11: TopScoreString
		12: AllScoreString
		14: LevelDescriptions
		15: DevModeEngaged
		17: CPRadius
		19: TempTeleport
		20: TempUltimate360MaxSlam
		21: TempRadii
		22: TempFacing
		24: CPIterator
		25: LevelIterator

	player:
		0: CurrentCP
		1: CurrentLevel
		3: LevelTimer
		4: PunchUpperSlamUsed
		7: TopPersonalScores
		9: SpectateMode
		14: SlamTimer
		15: BlockArriveAtNextPoint
		21: AllScoreboardString
		22: TopScoreboardString
		32: Array360
		33: Timer360
		34: Count360Slam125
		35: TempViewNextPointPosition
}

subroutines
{
	0: RespawnPlayer
	1: AutogenerateMapVariables
	2: OverrideAutogenVariables
	3: CancelMomentum
	4: OverrideVariablesUserInput
	5: UpdateTopScoreboard
}

rule("UPDATE MAP CONSTANTS HERE - CHECKPOINTS, ABILITIES")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"MAP MAKING INSTRUCTIONS\r\nStep 1: level checkpoints and abilities below\r\nStep 2: CP facing/radii/teleports/ultimates are autogenerated - override using the rule below this one"
		disabled Wait(0.250, Ignore Condition);
		"Default Checkpoint Radius"
		Global.CPRadius = 2;
		"Set level descriptions here, make sure the level number matches the index (ie. make sure Level 1 is on index 1)"
		Global.LevelNames = Array(Null, Custom String("Level 1"), Custom String("Level 2"), Custom String("Level 2.5"), Custom String(
			"Level 3"), Custom String("Level 3.5"), Custom String("Level 4"), Custom String("Level 5"), Custom String("Level 6"),
			Custom String("Level 7"), Custom String("Slam Only"), Custom String("Slam Only XL"));
		Global.LevelDescriptions = Array(Null, Custom String("Easy"), Custom String("Easy"), Custom String("Gimmicky"), Custom String(
			"Medium"), Custom String("Hard"), Custom String("Harder"), Custom String("Very Hard"), Custom String("Very Hard"),
			Custom String("Extreme"), Custom String("Increasing Difficulty"), Custom String("Professional"));
		"Add to this array the level numbers of levels you want to have ability limits on"
		Global.LevelsWithLimitedAbilityCounts = Array(7);
		"Set the starting position when the player loads into the game"
		Global.CPLocations = Array(Array(Vector(323.245, -4.861, -36.960)));
		"Set the starting position abilities when the player loads into the game"
		Global.CPPunchUpperSlamCounts = Array(Array(Vector(0, 1, 1)));
		"--------------Set Level 1 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[1] = Array(Null, Vector(330.406, -13.468, -59.449), Vector(320.344, -19.130, -67.381), Vector(340.852, -17.142,
			-31.094), Vector(374.400, -25.456, -0.206), Vector(349.785, -24.119, 22.751), Vector(332.640, -19.241, 11.032), Vector(325.261,
			-23.196, -4.375));
		Global.CPPunchUpperSlamCounts[1] = Array(Null, Vector(0, 1, 0), Vector(1, 1, 1), Vector(1, 1, 1), Vector(1, 1, 0), Vector(1, 0, 1),
			Vector(0, 1, 1), Vector(1, 1, 1));
		"--------------Set Level 2 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[2] = Array(Null, Vector(327.667, -13.280, -44.683), Vector(300.220, -16.160, -44.800), Vector(331.404, -17.101,
			-17.060), Vector(355.572, -14.360, -50.583), Vector(371.751, -25.259, -42.809), Vector(324.158, -16.155, -29.186), Vector(
			108.809, 65.914, -157.408), Vector(55.674, 65.983, -177.915), Vector(36.449, 61.963, -180.084), Vector(50.750, 64.552,
			-180.257), Vector(64.893, 62.456, -174.049), Vector(90.732, 65.802, -173.650), Vector(90.560, 62.199, -148.144), Vector(87.982,
			70.017, -150.597));
		Global.CPPunchUpperSlamCounts[2] = Array(Null, Vector(0, 1, 1), Vector(1, 1, 1), Vector(1, 0, 1), Vector(1, 0, 0), Vector(1, 0, 1),
			Vector(1, 1, 1), Vector(1, 1, 1), Vector(0, 0, 1), Vector(0, 1, 0), Vector(0, 0, 1), Vector(1, 1, 0), Vector(0, 1, 1), Vector(
			0, 1, 1), Vector(1, 1, 1));
		"--------------Set Level 3 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[3] = Array(Null, Vector(331.607, -13.287, -34.746), Vector(331.609, -26.142, -91.090), Vector(335.351, -17.040,
			-66.158), Vector(345.633, -15.886, -33.301), Vector(336.399, -23.090, 22.588), Vector(83.242, 69.155, -179.695), Vector(41.308,
			70.190, -163.804), Vector(45.372, 63.504, -138.720), Vector(82.911, 70.018, -150.488), Vector(51.009, 64.537, -179.986),
			Vector(-23.132, 70.016, -162.907), Vector(-237.544, 6.502, -4.081), Vector(-205.048, 11.394, -5.569), Vector(-197.438, 11.394,
			-12.641), Vector(-188.604, 8.475, -7.597), Vector(-189.043, 0.144, -59.483), Vector(-180.276, -2.854, -56.593));
		Global.CPPunchUpperSlamCounts[3] = Array(Null, Vector(1, 1, 1), Vector(1, 1, 1), Vector(1, 0, 1), Vector(0, 0, 0), Vector(1, 1, 1),
			Vector(1, 0, 1), Vector(0, 1, 1), Vector(1, 1, 1), Vector(1, 0, 1), Vector(0, 1, 1), Vector(1, 1, 1), Vector(1, 0, 1), Vector(
			0, 0, 0), Vector(0, 0, 0), Vector(1, 1, 0), Vector(0, 0, 1), Vector(1, 1, 1));
		"--------------Set Level 4 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[4] = Array(Null, Vector(314.299, -14.664, -15.197), Vector(345.726, -17.142, -31.810), Vector(326.962, -13.295,
			-44.830), Vector(321.150, -14.115, -71.738), Vector(319.440, -11.806, -91.189), Vector(341.432, -16.874, -31.356), Vector(
			331.122, -13.996, 11.535), Vector(308.087, -15.371, 21.628), Vector(-23.986, 69.570, -162.413), Vector(2.023, 71.447,
			-168.535), Vector(58.597, 65.710, -146.448), Vector(120.117, 62.982, -142.868), Vector(70.122, 70.870, -169.245));
		Global.CPPunchUpperSlamCounts[4] = Array(Null, Vector(0, 1, 1), Vector(1, 0, 0), Vector(1, 0, 1), Vector(1, 0, 1), Vector(1, 1, 1),
			Vector(1, 1, 0), Vector(1, 0, 0), Vector(1, 1, 1), Vector(1, 0, 0), Vector(1, 1, 1), Vector(1, 1, 0), Vector(1, 1, 0), Vector(
			1, 1, 1));
		"--------------Set Level 5 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[5] = Array(Null, Vector(336.346, -15.976, -29.949), Vector(333.117, -18.303, 1.333), Vector(324.066, -16.809,
			-14.840), Vector(311.877, -14.663, -12.878), Vector(328.313, -16.156, -30.450), Vector(320.772, -16.153, -44.979), Vector(
			272.118, -15.368, -69.859), Vector(122.060, 66.888, -181.204), Vector(108.435, 65.901, -156.266), Vector(51.059, 61.868,
			-184.116), Vector(55.289, 69.014, -180.609), Vector(117.838, 66.890, -184.260), Vector(-188.181, 6.275, -55.192), Vector(
			-214.413, 14.483, -24.926), Vector(-216.686, 14.486, -22.235));
		Global.CPPunchUpperSlamCounts[5] = Array(Null, Vector(0, 1, 1), Vector(0, 1, 0), Vector(0, 0, 1), Vector(0, 0, 1), Vector(1, 0, 0),
			Vector(1, 0, 0), Vector(1, 1, 1), Vector(0, 1, 1), Vector(1, 1, 0), Vector(1, 0, 0), Vector(1, 1, 0), Vector(1, 1, 0), Vector(
			1, 1, 0), Vector(0, 0, 0), Vector(1, 1, 1));
		"--------------Set Level 6 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[6] = Array(Null, Vector(306.392, -16.486, -56.065), Vector(298.461, -23.139, -71.977), Vector(300.889, -13.361,
			-47.271), Vector(285.959, -23.181, -67.560), Vector(307.709, -15.369, 21.944), Vector(314.646, -23.364, 28.089), Vector(
			308.101, -15.371, 22.075), Vector(352.889, -23.277, 14.902), Vector(-253.258, 3.732, 31.956), Vector(-232.771, 4.596, 1.684),
			Vector(-284.524, 1.291, 17.438), Vector(-254.510, -1.344, -1.441), Vector(-248.804, 5.594, -2.947), Vector(-214.139, 8.812,
			-3.143), Vector(-152.671, 5.974, -69.185), Vector(-185.966, 6.530, -43.245), Vector(-214.429, 14.483, -24.941));
		Global.CPPunchUpperSlamCounts[6] = Array(Null, Vector(0, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1), Vector(1, 1, 0), Vector(0, 0, 1),
			Vector(1, 0, 0), Vector(0, 1, 0), Vector(1, 1, 1), Vector(0, 1, 0), Vector(1, 0, 0), Vector(0, 1, 0), Vector(1, 0, 0), Vector(
			0, 1, 0), Vector(1, 0, 1), Vector(0, 1, 0), Vector(1, 0, 0), Vector(1, 1, 1));
		"--------------Set Level 7 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[7] = Array(Null, Vector(336.064, -17.101, -19.398), Vector(-226.141, 2.480, 5.311), Vector(-204.924, 11.394,
			-5.697), Vector(-190.440, 8.475, -9.372), Vector(-212.322, 2.073, -20.388), Vector(-214.544, 14.486, -25.074), Vector(-221.773,
			0.499, -35.841), Vector(-149.654, 6.208, -74.717), Vector(-178.640, 1.020, -92.485), Vector(-150.761, 1.501, -61.405), Vector(
			-212.938, 7.817, -40.903), Vector(121.914, 66.887, -180.446), Vector(-66.488, 67.144, -181.960), Vector(-20.098, 62.178,
			-145.664), Vector(40.727, 60.469, -178.147), Vector(17.651, 60.478, -178.577), Vector(99.017, 67.062, -156.598));
		Global.CPPunchUpperSlamCounts[7] = Array(Null, Vector(1, 1, 1), Vector(2, 0, 0), Vector(0, 0, 0), Vector(0, 2, 0), Vector(0, 2, 0),
			Vector(0, 2, 0), Vector(4, 4, 1), Vector(0, 1, 1), Vector(3, 0, 0), Vector(2, 0, 1), Vector(1, 1, 1), Vector(4, 4, 1), Vector(
			1, 2, 1), Vector(2, 0, 1), Vector(1, 0, 0), Vector(3, 2, 0), Vector(1, 1, 1));
		"--------------Set Level 8 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[8] = Array(Null, Vector(327.809, -21.159, -82.919), Vector(319.522, -11.903, -91.279), Vector(344.082, -13.467,
			-26.242), Vector(358.103, -26.040, -11.642), Vector(359.245, -12.046, 4.478), Vector(323.884, -14.113, 10.843), Vector(312.983,
			-20.854, 20.273), Vector(301.402, -24.120, -97.703), Vector(285.771, -23.181, -67.996), Vector(-189.520, 8.476, -8.393),
			Vector(-203.836, 8.476, 0.057), Vector(-147.060, 6.208, -77.454), Vector(-186.057, -3.551, -68.908), Vector(-278.290, 1.570,
			14.807), Vector(-213.687, 11.514, -25.612));
		Global.CPPunchUpperSlamCounts[8] = Array(Null, Vector(1, 0, 0), Vector(1, 0, 0), Vector(0, 1, 0), Vector(1, 1, 0), Vector(0, 1, 0),
			Vector(0, 0, 0), Vector(1, 1, 0), Vector(0, 1, 1), Vector(1, 1, 1), Vector(1, 0, 0), Vector(1, 0, 0), Vector(0, 1, 0), Vector(
			1, 1, 0), Vector(1, 0, 0), Vector(1, 1, 1));
		"--------------Set Level 9 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[9] = Array(Null, Vector(273.496, -15.318, -69.191), Vector(359.251, -11.945, 4.686), Vector(306.878, -15.257,
			27.713), Vector(-170.564, 6.772, -21.254), Vector(-223.864, 0.667, -39.254), Vector(-217.213, 14.483, -22.713), Vector(
			-230.224, 6.746, 23.753), Vector(-269.437, 1.939, 45.408));
		Global.CPPunchUpperSlamCounts[9] = Array(Null, Vector(1, 0, 0), Vector(0, 1, 0), Vector(1, 1, 1), Vector(0, 1, 0), Vector(1, 1, 0),
			Vector(0, 1, 0), Vector(0, 1, 0), Vector(1, 1, 1));
		"--------------Set Level 10 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[10] = Array(Null, Vector(353.919, -16.350, -46.602), Vector(-67.062, 62.025, -185.971), Vector(-50.359, 64.089,
			-184.973), Vector(-42.550, 64.964, -169.314), Vector(-33.997, 65.806, -173.412), Vector(-42.519, 68.096, -181.078), Vector(
			-26.152, 69.123, -179.399), Vector(-15.802, 70.017, -163.041), Vector(0.103, 64.535, -138.187), Vector(-15.243, 66.152,
			-148.459), Vector(-8.359, 66.679, -166.110), Vector(1.556, 70.382, -172.798), Vector(-2.800, 63.343, -170.604), Vector(
			-243.991, 6.241, 27.766), Vector(-236.797, 6.530, 5.539), Vector(-237.958, 6.498, -9.132), Vector(-230.537, 7.136, -30.163),
			Vector(-212.782, 7.819, -40.789), Vector(-194.725, 3.516, -24.870), Vector(-190.065, 6.509, -20.782), Vector(-197.918, 11.396,
			-12.766), Vector(-217.666, 11.511, -21.803), Vector(-223.211, 8.814, -3.046), Vector(-205.288, 6.728, 6.108), Vector(-219.032,
			8.554, -20.907), Vector(-207.322, 3.389, -34.487), Vector(-224.327, 0.498, -38.405));
		Global.CPPunchUpperSlamCounts[10] = Array(Null, Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0,
			1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1),
			Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(
			0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(1, 1,
			1));
		"--------------Set Level 11 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[11] = Array(Null, Vector(299.553, -14.662, -79.697), Vector(321.381, -14.027, -71.815), Vector(353.301, -16.272,
			-45.255), Vector(345.334, -15.669, -33.485), Vector(337.592, -14.762, 6.170), Vector(323.747, -16.156, -28.352), Vector(
			330.308, -13.373, -22.886), Vector(324.120, -14.159, 11.015), Vector(346.194, -16.493, 25.449));
		Global.CPPunchUpperSlamCounts[11] = Array(Null, Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0,
			1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(0, 0, 1), Vector(1, 1, 1));
		"Autogenerate checkpoint facing, radii, and other variables based on CPLocations"
		Call Subroutine(AutogenerateMapVariables);
		"Override autogenerated variables based on rule right below this one"
		Call Subroutine(OverrideAutogenVariables);
	}
}

rule("OVERRIDE AUTO-GENERATED CP RADII / FACING, SET TELEPORTS, ULTIMATE ENABLE")
{
	event
	{
		Subroutine;
		OverrideVariablesUserInput;
	}

	actions
	{
		"OVERRIDING CHECKPOINT PARAMETERS INSTRUCTIONS\r\nStep 1: Copy/paste code block from \"If(Global.LevelIterator == 0)\" to next \"End\" statement\r\nStep 2: Change the 0 in If(Global.LevelIterator == 0) to the level\r\nStep 3: Add the modifiers for that level (see the"
		disabled Wait(0.250, Ignore Condition);
		"------------------Use this code block to set Level 0 modifiers------------------"
		If(Global.LevelIterator == 0);
			"Example: Use this code to override CP 0 radius to be 3m"
			Global.TempRadii[0] = 3;
			"Example: Code block to override Level 0 CP 0 facing direction (1,0,0)"
			Global.TempFacing[0] = Vector(0.620, -0.250, -0.720);
		End;
		"------------------Use this code block to set Level 1 modifiers------------------"
		If(Global.LevelIterator == 1);
			"Use this code to make them do a 360 max-slam on CP 6"
			Global.TempUltimate360MaxSlam[6] = Vector(0, 1, 1);
			disabled Global.TempUltimate360MaxSlam[13] = Vector(0, 1, 0);
		End;
		"------------------Use this code block to set Level 2 modifiers------------------"
		If(Global.LevelIterator == 2);
			"Example: Use this code to override CP 3 radius to be 3.5m"
			Global.TempRadii[5] = 3.500;
			"Example: Use this code to override CP 5 to set it to teleport to the next checkpoint"
			Global.TempTeleport[6] = True;
			Global.TempRadii[9] = 1.500;
			"Example: Use this code to override CP 11 to enable require a 125 Slam to complete checkpoint"
			Global.TempUltimate360MaxSlam[12] = Vector(0, 0, 1);
			"Example: Use this code to override CP12 to enable require a 360 to complete the point"
			Global.TempUltimate360MaxSlam[13] = Vector(0, 1, 0);
			"Example: Use this code to override CP 3 to enable Ultimate"
			disabled Global.TempUltimate360MaxSlam[3] = Vector(1, 0, 0);
		End;
		"------------------Use this code block to set Level 3 modifiers------------------"
		If(Global.LevelIterator == 3);
			Global.TempUltimate360MaxSlam[1] = Vector(0, 0, 1);
			Global.TempUltimate360MaxSlam[4] = Vector(1, 0, 0);
			Global.TempTeleport[5] = True;
			"Example: Use this code to override CP 3 to enable Ultimate"
			Global.TempUltimate360MaxSlam[10] = Vector(1, 0, 0);
			Global.TempTeleport[11] = True;
			Global.TempUltimate360MaxSlam[16] = Vector(0, 0, 1);
		End;
		"------------------Use this code block to set Level 4 modifiers------------------"
		If(Global.LevelIterator == 4);
			Global.TempTeleport[8] = True;
		End;
		"------------------Use this code block to set Level 5 modifiers------------------"
		If(Global.LevelIterator == 5);
			Global.TempFacing[1] = Vector(0.420, -0.080, 0.900);
			Global.TempRadii[3] = 1;
			Global.TempTeleport[7] = True;
			Global.TempTeleport[12] = True;
			Global.TempRadii[14] = 1.300;
			Global.TempRadii[15] = 1.300;
		End;
		"------------------Use this code block to set Level 6 modifiers------------------"
		If(Global.LevelIterator == 6);
			Global.TempFacing[4] = Vector(0.920, 0, -0.400);
			Global.TempTeleport[8] = True;
		End;
		"------------------Use this code block to set Level 7 modifiers------------------"
		If(Global.LevelIterator == 7);
			Global.TempTeleport[1] = True;
			Global.TempFacing[2] = Vector(-0.730, 0, -0.690);
			Global.TempFacing[5] = Vector(-0.710, 0, -0.700);
			Global.TempFacing[9] = Vector(-0.300, 0, -0.950);
			Global.TempTeleport[11] = True;
			Global.TempUltimate360MaxSlam[12] = Vector(1, 0, 0);
			Global.TempUltimate360MaxSlam[13] = Vector(0, 0, 1);
			Global.TempRadii[15] = 3.500;
		End;
		"------------------Use this code block to set Level 8 modifiers------------------"
		If(Global.LevelIterator == 8);
			Global.TempFacing[4] = Vector(0.980, 0, 0.200);
			Global.TempFacing[7] = Vector(0.650, 0.340, 0.680);
			Global.TempFacing[8] = Vector(-0.910, 0.090, 0.410);
			Global.TempTeleport[9] = True;
			Global.TempFacing[11] = Vector(-1, 0, 0);
		End;
		"------------------Use this code block to set Level 9 modifiers------------------"
		If(Global.LevelIterator == 9);
			disabled Global.TempUltimate360MaxSlam[1] = Vector(0, 0, 1);
			Global.TempTeleport[3] = True;
		End;
		"------------------Use this code block to set Level 10 modifiers------------------"
		If(Global.LevelIterator == 10);
			Global.TempTeleport[1] = True;
			Global.TempRadii[11] = 3.500;
			Global.TempTeleport[13] = True;
			Global.TempRadii[13] = 1;
			Global.TempRadii[17] = 2.700;
			Global.TempFacing[24] = Vector(-0.700, -0.040, -0.710);
			Global.TempRadii[24] = 1.500;
			Global.TempFacing[26] = Vector(-0.710, -0.040, -0.700);
		End;
	}
}

disabled rule("Initialize Player and Map")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Initialize Other Global Constants")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.TopScoreString = Custom String("");
		Enable Death Spectate Target HUD(All Players(All Teams));
		Set Match Time(3599);
		Pause Match Time;
		Global.DevModeEngaged = False;
	}
}

rule("Initialize Global HUD and Effects")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Wait for Map Checkpoints, radii, etc to get generated. Prevents this rule from running out of order with map generation rules."
		Wait(0.200, Ignore Condition);
		"Create Origin Point Ring"
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0), Ring, Purple, Global.CPLocations[0][0],
			Global.CPRadii[0][0], Visible To);
		For Global Variable(LevelIterator, 1, Count Of(Global.CPLocations), 1);
			"Create Level Entry Rings"
			Create Effect(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0), Ring, Purple,
				Global.CPLocations[Global.LevelIterator][1], Global.CPRadii[Global.LevelIterator][1], Visible To);
			"Put checkpoint numbers under level description (looked bad)"
			disabled Create In-World Text(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0), Custom String(
				"{0}\r\nCheckpoints: {1}", Global.LevelNames[Global.LevelIterator], Count Of(Global.CPLocations[Global.LevelIterator])),
				Global.CPLocations[Global.LevelIterator][1], 1.500, Do Not Clip, Visible To, Yellow, Default Visibility);
			Create In-World Text(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0), Custom String("{0} ({1})",
				Global.LevelNames[Global.LevelIterator], Global.LevelDescriptions[Global.LevelIterator]),
				Global.CPLocations[Global.LevelIterator][1], 1.500, Do Not Clip, Visible To, Yellow, Default Visibility);
			Create Icon(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0),
				Global.CPLocations[Global.LevelIterator][1], Flag, Visible To, Yellow, True);
		End;
		"Hide Game HUD"
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(
			" \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"),
			Top, 0, White, White, White, Visible To and String, Default Visibility);
		"Controls HUD"
		Create HUD Text(All Players(All Teams), Custom String("Controls"), Null, Null, Left, -2, White, White, White,
			Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(
			"Quick Reset - R\r\nSkip Checkpoint - Jump + Interact\r\n{0}\r\n{1}", Custom String(
			"Previous Checkpoint - Crouch + Interact\r\nChoose New Level - Ultimate + Interact"), Custom String(
			"View Next Checkpoint - Left Click + Interact\r\nSpectate - Need Healing Voiceline")), Left, 0, White, White, White,
			Visible To and String, Default Visibility);
		"Top Scores HUD"
		Create HUD Text(Filtered Array(All Players(All Teams), Global.TopScoreString != Custom String("")), Custom String("Top Scores"),
			Null, Null, Left, 1, White, White, Purple, Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Global.TopScoreString != Custom String("")), Null, Null, Custom String(
			"{0}", Global.TopScoreString), Left, 2, White, White, Purple, Visible To and String, Default Visibility);
		"All Scores HUD"
		Create HUD Text(Filtered Array(All Players(All Teams), Global.AllScoreString != Custom String("")), Custom String("All Scores"),
			Null, Null, Right, 2, White, White, White, Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Global.AllScoreString != Custom String("")), Null, Null, Custom String(
			"{0}", Global.AllScoreString), Right, 3, White, White, White, Visible To and String, Default Visibility);
		"Workshop Code HUD"
		Create HUD Text(All Players(All Teams), Custom String("Workshop Code: 7RDMK"), Null, Null, Right, -9, Green, White, White,
			Visible To, Default Visibility);
	}
}

rule("Initialize Player Variables")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Event Player.CurrentCP = 0;
		Event Player.CurrentLevel = 0;
		Call Subroutine(RespawnPlayer);
		Event Player.BlockArriveAtNextPoint = False;
		For Player Variable(Event Player, Z, 0, Count Of(Global.CPLocations), 1);
			Event Player.TopPersonalScores[Event Player.Z] = 9999;
		End;
	}
}

rule("Initialize Player HUD and Effects")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Create HUD Text(Event Player, Null, Null, Custom String("{0} Checkpoint {1} - Time {2}",
			Global.LevelNames[Event Player.CurrentLevel], Custom String("{0}/{1}", Event Player.CurrentCP, Count Of(
			Global.CPLocations[Event Player.CurrentLevel]) - 1), Event Player.LevelTimer), Top, -2, White, White, White,
			Visible To and String, Default Visibility);
		"Create Current Checkpoint Ring"
		Create Effect(Filtered Array(Event Player, Event Player.CurrentCP > 0 && Event Player.CurrentCP + 1 < Count Of(
			Global.CPLocations[Event Player.CurrentLevel])), Ring, Purple,
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP],
			Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP], Visible To Position and Radius);
		"Next Checkpoint Ring"
		Create Effect(Filtered Array(Event Player, Current Array Element.CurrentCP > 0), Ring, Purple,
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1],
			Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 1], Visible To Position and Radius);
		"Create Next Checkpoint Text"
		Create In-World Text(Filtered Array(Event Player, Event Player.CurrentCP > 0 && Event Player.CurrentCP + 1 < Count Of(
			Global.CPLocations[Event Player.CurrentLevel])), Custom String("Come Here!"),
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1], 1.300, Do Not Clip, Visible To Position and String,
			Yellow, Default Visibility);
		"Create Next Checkpoint Icon"
		Create Icon(Filtered Array(Event Player, Event Player.CurrentCP > 0 && Event Player.CurrentCP + 1 < Count Of(
			Global.CPLocations[Event Player.CurrentLevel])), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1],
			Flag, Visible To and Position, Yellow, True);
		"Level 3 HUD: Ability Limits "
		Create HUD Text(Filtered Array(Event Player, Index Of Array Value(Global.LevelsWithLimitedAbilityCounts, Event Player.CurrentLevel)
			>= 0 && Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel])), Custom String(
			"Checkpoint Abilty Limits\r\n{0} {1} {2}", Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(
			Secondary Fire)), X Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])
			- X Component Of(Event Player.PunchUpperSlamUsed)), Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(
			Ability 1)), Y Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) - Y Component Of(
			Event Player.PunchUpperSlamUsed)), Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Ability 2)),
			Z Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) - Z Component Of(
			Event Player.PunchUpperSlamUsed))), Null, Null, Top, -1.400, Blue, White, White, Visible To and String, Default Visibility);
		"360 Required HUD"
		Create HUD Text(Filtered Array(Event Player, Y Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) > 0), Custom String(
			"360's Required: {0}", Y Component Of(Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])),
			Null, Null, Top, -1, Red, White, White, Visible To and String, Default Visibility);
		"125Slam Required HUD"
		Create HUD Text(Filtered Array(Event Player, Z Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) > 0), Custom String(
			"125 Charge Slams Required: {0}", Z Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])), Null, Null, Top, -1, Red, White, White,
			Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(Event Player, Global.DevModeEngaged), Null, Null, Custom String(
			"--------------Player Variables------------------\r\n{0}\r\n--------------Checkpoint Variables--------------\r\n{1}\r\n{2}\r\n-------------",
			Custom String("Position: {0}\r\nFacing: {1}", Position Of(Event Player), Facing Direction Of(Event Player)), Custom String(
			"Checkpoint Position: {0}\r\nCheckpoint Abilities {1}\r\n{2}",
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP],
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP], Custom String(
			"Checkpoint Facing: {0}\r\nCheckpoint Radius: {1}", Global.CPFacing[Event Player.CurrentLevel][Event Player.CurrentCP],
			Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP])), Custom String(
			"Checkpoint Ultimate Enabled: {0}\r\nCheckpoint 360 Req'd: {1}\r\nCheckpoint 125 Slam Req'd: {2}", X Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]), Y Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]), Z Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]))), Left, 9, White, White, White,
			Visible To and String, Default Visibility);
	}
}

disabled rule("Map Building Convenience Features - COMMENT THESE WHEN DEPLOYING MAP")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}
}

disabled rule("Map Building HUD")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Create HUD Text(Event Player, Custom String("Position {0}\r\nFacing {1}\r\nAltitude {2}", Position Of(Event Player),
			Facing Direction Of(Event Player), Altitude Of(Event Player)), Null, Null, Right, 0, White, White, White,
			Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Custom String("RayCastAltitude: {0}", Distance Between(Position Of(Event Player),
			Ray Cast Hit Position(Position Of(Event Player) + Vector(0, 0.100, 0), Position Of(Event Player) + Vector(0, -10, 0),
			All Players(All Teams), Event Player, True))), Null, Null, Right, 1, White, White, White, Visible To and String,
			Default Visibility);
	}
}

disabled rule("Subroutines")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Subroutine 0: RespawnPlayer")
{
	event
	{
		Subroutine;
		RespawnPlayer;
	}

	actions
	{
		Disallow Button(Event Player, Secondary Fire);
		Disallow Button(Event Player, Ultimate);
		Disallow Button(Event Player, Ability 1);
		Disallow Button(Event Player, Ability 2);
		Call Subroutine(CancelMomentum);
		Clear Status(Event Player, Phased Out);
		Set Status(Event Player, Null, Phased Out, 9999);
		Cancel Primary Action(Event Player);
		"Safety check in case rules execute out of order, ie Reset to Origin (Q + Interact) pressed same time and get next level"
		If(Event Player.CurrentCP > 0 && Event Player.CurrentLevel == 0);
			Event Player.CurrentCP = 0;
		End;
		"Set location and facing direction of player"
		Teleport(Event Player, Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP]);
		Set Facing(Event Player, Global.CPFacing[Event Player.CurrentLevel][Event Player.CurrentCP], To World);
		"set player abilities"
		Event Player.PunchUpperSlamUsed = Vector(0, 0, 0);
		If(X Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			Set Secondary Fire Enabled(Event Player, False);
		Else;
			Set Secondary Fire Enabled(Event Player, True);
		End;
		If(Y Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			Set Ability 1 Enabled(Event Player, False);
		Else;
			Set Ability 1 Enabled(Event Player, True);
		End;
		If(Z Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			Set Ability 2 Enabled(Event Player, False);
		Else;
			Set Ability 2 Enabled(Event Player, True);
		End;
		If(X Component Of(Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			Set Ultimate Ability Enabled(Event Player, False);
		Else;
			Set Ultimate Ability Enabled(Event Player, True);
		End;
		Set Ultimate Charge(Event Player, 100);
		Wait(0.100, Ignore Condition);
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		If(Event Player.CurrentCP == 0);
			Stop Chasing Player Variable(Event Player, LevelTimer);
			Event Player.LevelTimer = 0;
		End;
		"Redundant, but just in case"
		Event Player.PunchUpperSlamUsed = Vector(0, 0, 0);
		Event Player.Count360Slam125 = Vector(0, 0, 0);
		Allow Button(Event Player, Secondary Fire);
		Allow Button(Event Player, Ability 1);
		Allow Button(Event Player, Ability 2);
		Allow Button(Event Player, Ultimate);
	}
}

rule("Subroutine 1: AutogenerateMapVariables")
{
	event
	{
		Subroutine;
		AutogenerateMapVariables;
	}

	actions
	{
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + -1, 1);
			Global.LevelOrigins[Global.LevelIterator] = Global.CPLocations[Global.LevelIterator + 1][1];
		End;
		"Set the checkpoint location to be the closest walkable position to the CPLocation position entered by player. This is so the map maker can use the Camera button to enter CP locations (which sets eye position instead of player position)"
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + 0, 1);
			Global.X = Global.CPLocations[Global.LevelIterator];
			For Global Variable(CPIterator, 0, Count Of(Global.CPLocations[Global.LevelIterator]) - 0, 1);
				Global.X[Global.CPIterator] = Ray Cast Hit Position(Global.X[Global.CPIterator] + Vector(0, 0.100, 0),
					Global.X[Global.CPIterator] + 2 * Down, All Players(All Teams), Event Player, True);
			End;
			Global.CPLocations[Global.LevelIterator] = Global.X;
			"Initialize TopScoreTimes using this For loop as well"
			Global.TopScoreTimes[Global.LevelIterator] = 10000;
		End;
		"Autogenerate variable arrays"
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + 0, 1);
			"Set CPFacing array to all NULL. NULL means orient player towards direction of next point."
			Global.CPFacing[Global.LevelIterator] = Null;
			"Set CPFacing array to all NULL. NULL means orient player towards direction of next point."
			Global.CPTeleport[Global.LevelIterator] = Null;
			"Set CPRadii array to all DefaultCPRadius (set in \"Initialize Global Constants\" rule)"
			Global.CPRadii[Global.LevelIterator] = Global.CPRadius;
			"Set Ultimate and other special bindings array to all zeros, as most of the time, these will not be bound to a checkpoint."
			Global.CPUltimate360MaxSlamCounts[Global.LevelIterator] = Vector(0, 0, 0);
			For Global Variable(CPIterator, 1, Count Of(Global.CPLocations[Global.LevelIterator]) - 0, 1);
				Modify Global Variable At Index(CPFacing, Global.LevelIterator, Append To Array, Direction Towards(
					Global.CPLocations[Global.LevelIterator][Global.CPIterator], Global.CPLocations[Global.LevelIterator][Global.CPIterator + 1]));
				Modify Global Variable At Index(CPTeleport, Global.LevelIterator, Append To Array, Null);
				Modify Global Variable At Index(CPRadii, Global.LevelIterator, Append To Array, Global.CPRadius);
				Modify Global Variable At Index(CPUltimate360MaxSlamCounts, Global.LevelIterator, Append To Array, Vector(0, 0, 0));
			End;
		End;
	}
}

rule("Subroutine 2: OverrideAutogenVariables")
{
	event
	{
		Subroutine;
		OverrideAutogenVariables;
	}

	actions
	{
		"OVERRIDING CHECKPOINT PARAMETERS INSTRUCTIONS\r\nStep 1: Copy/paste code block from \"If(Global.LevelIterator == 0)\" to next \"End\" statement\r\nStep 2: Change the 0 in If(Global.LevelIterator == 0) to the level\r\nStep 3: Add the modifiers for that level (see the"
		disabled Wait(0.250, Ignore Condition);
		"Need this whole structure because Workshop Editor doesn't let you index into array's of arrays"
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + 0, 1);
			Global.TempTeleport = Global.CPTeleport[Global.LevelIterator];
			Global.TempUltimate360MaxSlam = Global.CPUltimate360MaxSlamCounts[Global.LevelIterator];
			Global.TempRadii = Global.CPRadii[Global.LevelIterator];
			Global.TempFacing = Global.CPFacing[Global.LevelIterator];
			Call Subroutine(OverrideVariablesUserInput);
			Global.CPFacing[Global.LevelIterator] = Global.TempFacing;
			Global.CPRadii[Global.LevelIterator] = Global.TempRadii;
			Global.CPUltimate360MaxSlamCounts[Global.LevelIterator] = Global.TempUltimate360MaxSlam;
			Global.CPTeleport[Global.LevelIterator] = Global.TempTeleport;
		End;
	}
}

rule("Subroutine 3: Cancel Momentum")
{
	event
	{
		Subroutine;
		CancelMomentum;
	}

	actions
	{
		Apply Impulse(Event Player, Up, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Down, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Left, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Right, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Forward, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Backward, 0.001, To World, Cancel Contrary Motion);
	}
}

rule("Subroutine 5: UpdateTopScoreboard")
{
	event
	{
		Subroutine;
		UpdateTopScoreboard;
	}

	actions
	{
		"Create TOP Scoreboard String"
		Event Player.TopScoreboardString = Custom String("");
		For Player Variable(Event Player, X, Count Of(Global.TopScoreTimes) - 1, -1, -1);
			If(Global.TopScoreTimes[Event Player.X] < 9999);
				If(Event Player.TopScoreboardString == Custom String(""));
					Event Player.TopScoreboardString = Custom String("{0} - {1} {2}", Global.LevelNames[Event Player.X],
						Global.TopScorePlayer[Event Player.X + 0], Global.TopScoreTimes[Event Player.X + 0]);
				Else;
					Event Player.TopScoreboardString = Custom String("{0}\r\n{1}", Event Player.TopScoreboardString, Custom String("{0} - {1} {2}",
						Global.LevelNames[Event Player.X], Global.TopScorePlayer[Event Player.X + 0], Global.TopScoreTimes[Event Player.X + 0]));
				End;
			End;
		End;
		Global.TopScoreString = Event Player.TopScoreboardString;
		"Create All Scoreboard String"
		Event Player.AllScoreboardString = Custom String("");
		For Player Variable(Event Player, X, Count Of(Global.TopScoreTimes) - 1, -1, -1);
			For Player Variable(Event Player, Y, 0, Count Of(All Players(All Teams)), 1);
				If(All Players(All Teams)[Event Player.Y].TopPersonalScores[Event Player.X] < 9999);
					If(All Players(All Teams)[Event Player.Y].TopPersonalScores[Event Player.X] > 0);
						If(Event Player.AllScoreboardString == Custom String(""));
							Event Player.AllScoreboardString = Custom String("{0} - {1} {2}", Global.LevelNames[Event Player.X], All Players(All Teams)
								[Event Player.Y], All Players(All Teams)[Event Player.Y].TopPersonalScores[Event Player.X]);
						Else;
							Event Player.AllScoreboardString = Custom String("{0}\r\n{1}", Event Player.AllScoreboardString, Custom String("{0} - {1} {2}",
								Global.LevelNames[Event Player.X], All Players(All Teams)[Event Player.Y], All Players(All Teams)
								[Event Player.Y].TopPersonalScores[Event Player.X]));
						End;
					End;
				End;
			End;
		End;
		Global.AllScoreString = Event Player.AllScoreboardString;
	}
}

disabled rule("Multi-Level Framework")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Enter Into Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Count Of(Filtered Array(Global.LevelOrigins, Distance Between(Current Array Element, Position Of(Event Player)) < 2)) > 0;
		Is On Ground(Event Player) == True;
		Event Player.CurrentCP == 0;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Play Effect(Event Player, Buff Explosion Sound, White, Event Player, 60);
		Event Player.CurrentCP = 1;
		Event Player.CurrentLevel = Index Of Array Value(Global.LevelOrigins, First Of(Filtered Array(Global.LevelOrigins,
			Distance Between(Position Of(Event Player), Current Array Element) < 2))) + 1;
		If(Global.CPTeleport[Event Player.CurrentLevel][Event Player.CurrentCP] != Null);
			Event Player.CurrentCP += 1;
		End;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Touched ground without entering level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Count Of(Filtered Array(Global.LevelOrigins, Distance Between(Current Array Element, Position Of(Event Player)) < 2)) == 0;
		Is On Ground(Event Player) == True;
		Event Player.CurrentCP == 0;
		Has Spawned(Event Player) == True;
		"Not on current checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 0])
			> Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 0];
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Start Timer When Player Leaves Origin Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Distance Between(Position Of(Event Player), Global.CPLocations[0][0]) > Global.CPRadii[0][0];
		Event Player.CurrentCP <= 0;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		"To prevent this rule from triggering before the rule that tele's player to start point"
		Wait(0.250, Abort When False);
		Event Player.LevelTimer = 0;
		Chase Player Variable At Rate(Event Player, LevelTimer, 99999, 1, Destination and Rate);
	}
}

rule("Arrived At Next Checkpoint")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Within range of next checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1])
			< Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 1];
		"Player has selected a level"
		Event Player.CurrentCP > 0;
		Is On Ground(Event Player) == True;
		"Is not on last checkpoint in level"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		Event Player.CurrentLevel > 0;
		Event Player.BlockArriveAtNextPoint != True;
	}

	actions
	{
		If(Y Component Of(Event Player.Count360Slam125) < Z Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			"Grace period"
			Wait(0.050, Ignore Condition);
			If(Y Component Of(Event Player.Count360Slam125) < Z Component Of(
				Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
				Small Message(Event Player, Custom String("Checkpoint Requires 125 charge slam", Z Component Of(
					Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])));
				Call Subroutine(RespawnPlayer);
				Abort;
			End;
		End;
		If(X Component Of(Event Player.Count360Slam125) < Y Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			Small Message(Event Player, Custom String("Checkpoint Requires {0} 360's. Spin Around!", Y Component Of(
				Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])));
			Call Subroutine(RespawnPlayer);
			Abort;
		End;
		Event Player.CurrentCP += 1;
		Play Effect(Event Player, Buff Explosion Sound, White, Event Player, 60);
		If(Global.CPTeleport[Event Player.CurrentLevel][Event Player.CurrentCP] != Null);
			Event Player.CurrentCP += 1;
		End;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Respawn If Touched Ground Not On Checkpoints")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Not on current checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 0])
			> Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 0];
		"Not within range of next checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1])
			> Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 1];
		"Player has selected a level"
		Event Player.CurrentCP > 0;
		Is On Ground(Event Player) == True;
		"Is not on last checkpoint in level"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
	}

	actions
	{
		"Is using ultimate and is has other abilities available. Disabling this because it triggers on valid meteor strikes because this rule triggers in middle of RespawnPlayer subroutine before the teleport happens."
		disabled If(Is Using Ultimate(Event Player) && 0 < Dot Product(Vector(1, 1, 1),
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
		disabled Small Message(Event Player, Custom String("Meteor Strike on non-ground point to keep using abilities!"));
		disabled End;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Level End Boss Notification (for fun)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.CurrentLevel > 0;
		Event Player.CurrentCP + 2 == Count Of(Global.CPLocations[Event Player.CurrentLevel]);
	}

	actions
	{
		Big Message(Event Player, Custom String("Level End Boss!"));
	}
}

rule("Finished Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Is on last checkpoint in level"
		Event Player.CurrentCP + 1 == Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		Event Player.CurrentCP > 0;
		Event Player.CurrentLevel > 0;
		Event Player.LevelTimer > 0;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, LevelTimer);
		Big Message(All Players(All Teams), Custom String("{0} Finished {1} in {2}sec", Event Player,
			Global.LevelNames[Event Player.CurrentLevel], Event Player.LevelTimer));
		"If player got top score, update top scores"
		If(Event Player.LevelTimer < Global.TopScoreTimes[Event Player.CurrentLevel]);
			Global.TopScoreTimes[Event Player.CurrentLevel] = Event Player.LevelTimer;
			"Making it save player name as a string, so it works even after they leave the game"
			Global.TopScorePlayer[Event Player.CurrentLevel] = Custom String("{0}", Event Player);
		End;
		"If player got best personal score, update personal scores"
		If(Event Player.LevelTimer < Event Player.TopPersonalScores[Event Player.CurrentLevel]);
			Event Player.TopPersonalScores[Event Player.CurrentLevel] = Event Player.LevelTimer;
		End;
		Call Subroutine(UpdateTopScoreboard);
		Small Message(Event Player, Custom String("Use Ultimate + Interact To Restart"));
	}
}

rule("Respawn Player If They Die")
{
	event
	{
		Player Died;
		All;
		All;
	}

	conditions
	{
		Event Player.SpectateMode == False;
	}

	actions
	{
		Respawn(Event Player);
		Wait(0.100, Ignore Condition);
		Call Subroutine(RespawnPlayer);
	}
}

disabled rule("Additional Features")
{
	event
	{
		Ongoing - Global;
	}
}

rule("R -> Quick Reset")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Reload) == True;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Ultimate + Interact -> Reset to Origin Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Ultimate) == True;
		Is Button Held(Event Player, Interact) == True;
	}

	actions
	{
		Event Player.CurrentCP = 0;
		Event Player.CurrentLevel = 0;
		Stop Chasing Player Variable(Event Player, LevelTimer);
		Event Player.LevelTimer = 0;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Jump + Interact -> Skip Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Jump) == True;
		Is Button Held(Event Player, Interact) == True;
		Event Player.CurrentLevel > 0;
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, LevelTimer);
		Event Player.LevelTimer = 0;
		Event Player.CurrentCP += 1;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Crouch + Interact -> Go Back A Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Crouch) == True;
		Is Button Held(Event Player, Interact) == True;
		Event Player.CurrentLevel > 0;
		Event Player.CurrentCP + 0 > 1;
	}

	actions
	{
		"To stop you from going back a checkpoint, and the \"Arrive At Next Checkpoint Rule\" from triggering while you are respawning"
		Event Player.BlockArriveAtNextPoint = True;
		Event Player.CurrentCP -= 1;
		Call Subroutine(RespawnPlayer);
		Event Player.BlockArriveAtNextPoint = False;
	}
}

rule("Left Click + Interact -> Camera To See Next Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Make sure next point exists"
		Count Of(Global.CPLocations[Event Player.CurrentLevel]) > Event Player.CurrentCP + 1;
		Is Button Held(Event Player, Primary Fire) == True;
		Is Button Held(Event Player, Interact) == True;
	}

	actions
	{
		Set Primary Fire Enabled(Event Player, False);
		Event Player.TempViewNextPointPosition = Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1];
		Set Facing(Event Player, Vector(-10, -10, 0), To World);
		Start Camera(Event Player, Ray Cast Hit Position(Event Player.TempViewNextPointPosition,
			Event Player.TempViewNextPointPosition + Facing Direction Of(Event Player) * -15, All Players(All Teams), Event Player, True),
			Event Player.TempViewNextPointPosition, 30);
		While(Is Button Held(Event Player, Primary Fire) && Is Button Held(Event Player, Interact));
			Wait(0.033, Ignore Condition);
		End;
		Stop Camera(Event Player);
		Set Primary Fire Enabled(Event Player, True);
	}
}

rule("Need Healing Voiceline -> Spectate Other Players")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating(Event Player, Need Healing) == True;
		disabled Is Button Held(Event Player, Melee) == True;
		disabled Is Button Held(Event Player, Interact) == True;
	}

	actions
	{
		Enable Death Spectate Target HUD(All Players(All Teams));
		Enable Death Spectate All Players(All Players(All Teams));
		If(Is Dead(Event Player));
			Enable Built-In Game Mode Respawning(Event Player);
			Resurrect(Event Player);
			Wait(0.100, Ignore Condition);
			Call Subroutine(RespawnPlayer);
			Event Player.SpectateMode = False;
		Else;
			Big Message(Event Player, Custom String("Use \"Need Healing\" voiceline to exit Spectate Mode!"));
			Event Player.SpectateMode = True;
			Disable Built-In Game Mode Respawning(Event Player);
			Kill(Event Player, Null);
		End;
		Set Status(Event Player, Null, Phased Out, 9999);
	}
}

rule("Ultimate Status + Interact -> Dev Mode (Host Only)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Interact) == True;
		Is Communicating(Event Player, Ultimate Status) == True;
		Event Player == Host Player;
	}

	actions
	{
		Global.DevModeEngaged = !Global.DevModeEngaged;
	}
}

rule("Teleport Enabled with Melee + Left Click if done with level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Primary Fire) == True;
		Is Button Held(Event Player, Melee) == True;
		disabled Event Player.CurrentLevel > 0;
		Event Player.CurrentCP + 1 >= Count Of(Global.CPLocations[Event Player.CurrentLevel]);
	}

	actions
	{
		Teleport(Event Player, Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 60 * Facing Direction Of(
			Event Player), All Players(All Teams), Event Player, True));
	}
}

disabled rule("Can Melee Cancel Slam")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		Is Button Held(Event Player, Melee) == True;
	}

	actions
	{
		Cancel Primary Action(Event Player);
		Small Message(Event Player, Custom String("Testing melee slam cancel"));
	}
}

disabled rule("360 Code :D")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}
}

rule("Update 360 Array")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Array360[Round To Integer((Horizontal Facing Angle Of(Event Player) + 180) / 90.010, Down)] != True;
		Has Spawned(Event Player) == True;
		"Can't do 360 in starting checkpoint circle"
		Distance Between(Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP], Position Of(Event Player))
			> Global.CPRadius;
		"So most stalls dont let you 360 for free. Not using \"altitude of\" function because it doesn't work on many roof sides"
		Distance Between(Position Of(Event Player), Ray Cast Hit Position(Position Of(Event Player) + Vector(0, 0.100, 0), Position Of(
			Event Player) + Down * 10, All Players(All Teams), Event Player, True)) > 0.500;
		"So most stalls dont let you 360 for free"
		Altitude Of(Event Player) > 0.500;
	}

	actions
	{
		disabled Event Player.Array360[Round To Integer((Horizontal Facing Angle Of(Event Player) + 180) / (360 / Count Of(Event Player.Array360)),
			Down)] = True;
		Event Player.Array360[Round To Integer((Horizontal Facing Angle Of(Event Player) + 180) / 90.010, Down)] = True;
		"Start timer if player has started 360"
		If(Count Of(Filtered Array(Event Player.Array360, Current Array Element == True)) == 2);
			Event Player.Timer360 = 0;
			Chase Player Variable At Rate(Event Player, Timer360, 1, 1, Destination and Rate);
		End;
	}
}

rule("Reset 360 Array after 1 sec")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Timer360 >= 1;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		disabled For Player Variable(Event Player, I, 0, Count Of(Event Player.Array360), 1);
		disabled Event Player.Array360[Event Player.I] = False;
		disabled End;
		Event Player.Array360 = Array(False, False, False, False);
		Event Player.Timer360 = 0;
		Stop Chasing Player Variable(Event Player, Timer360);
	}
}

rule("Successful 360 Detected")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is True For All(Event Player.Array360, Current Array Element) == True;
		Has Spawned(Event Player) == True;
		"Can't do 360 in starting checkpoint circle"
		Distance Between(Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP], Position Of(Event Player))
			> Global.CPRadius;
		"So most stalls dont let you 360 for free"
		Altitude Of(Event Player) > 0.500;
		"So most stalls dont let you 360 for free. Not using \"altitude of\" function because it doesn't work on many roof sides"
		Distance Between(Position Of(Event Player), Ray Cast Hit Position(Position Of(Event Player) + Vector(0, 0.100, 0), Position Of(
			Event Player) + Down * 10, All Players(All Teams), Event Player, True)) > 0.500;
	}

	actions
	{
		Small Message(Event Player, Custom String("360"));
		Event Player.Count360Slam125 += Left;
		Play Effect(Event Player, Buff Impact Sound, White, Event Player, 60);
		Event Player.Array360 = Array(False, False, False, False);
	}
}

disabled rule("Ability Limits Stuff")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Used Secondary (Rocket Punch)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Left;
	}
}

rule("Used Ability 1 (Uppercut)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Up;
	}
}

rule("Used Ability 2 - Start Slam Timer")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Event Player.SlamTimer = 0;
		Chase Player Variable At Rate(Event Player, SlamTimer, 99, 1, Destination and Rate);
	}
}

rule("Stop slam timer when not using slam or on ground")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		(!Is Using Ability 2(Event Player) || (Is On Ground(Event Player) && Event Player.SlamTimer > 0.200)) == True;
		Has Spawned(Event Player) == True;
		"To stop this rule from double triggering"
		Event Player.SlamTimer > 0;
	}

	actions
	{
		Wait(0.050, Ignore Condition);
		Stop Chasing Player Variable(Event Player, SlamTimer);
		Event Player.SlamTimer = 0;
	}
}

rule("Increment Slam Counter")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		"Prevents invalid slam (where player presses slam button but can't slam) from being counted"
		disabled ((Is On Ground(Event Player) && Event Player.SlamTimer > 0.010 && Event Player.SlamTimer < 0.250) || (
			Event Player.SlamTimer > 0.250)) == True;
		Has Spawned(Event Player) == True;
		Is Using Ability 2(Event Player) == True;
		Event Player.SlamTimer > 0.250;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Forward;
		If(Is On Ground(Event Player));
			Stop Chasing Player Variable(Event Player, SlamTimer);
			Event Player.SlamTimer = 0;
		End;
	}
}

rule("125 Slam Detection")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		"Actual time is 1.53 for 125 slam + cancel, but removing cancel ~.3 sec"
		Event Player.SlamTimer >= 1.220;
		Is Using Ability 2(Event Player) == True;
		"To prevent player from just holding down slam at invalid slam angle to get a 125 slam"
		Is Button Held(Event Player, Ability 2) == False;
	}

	actions
	{
		Event Player.Count360Slam125 += Up;
		Small Message(Event Player, Custom String("125 Slam"));
		Play Effect(Event Player, Buff Impact Sound, White, Event Player, 60);
	}
}

rule("Limiter for Ability Counts")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Is in ability limited level"
		Index Of Array Value(Global.LevelsWithLimitedAbilityCounts, Event Player.CurrentLevel) > -1;
		"Is using an ability"
		(Is Using Ability 1(Event Player) || Is Using Ability 2(Event Player) || Is Firing Secondary(Event Player)) == True;
		"Inside a level, not in multilevel portion"
		Event Player.CurrentCP > 0;
		"Is NOT on last checkpoint of the level"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
	}

	actions
	{
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
		If(Y Component Of(Event Player.PunchUpperSlamUsed) >= Y Component Of(
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			Set Ability 1 Enabled(Event Player, False);
		End;
		If(Z Component Of(Event Player.PunchUpperSlamUsed) >= Z Component Of(
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			Set Ability 2 Enabled(Event Player, False);
		End;
		If(X Component Of(Event Player.PunchUpperSlamUsed) >= X Component Of(
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			"Have to wait to disable punch because otherwise it would disable immediately after using preventing punch from working properly."
			Wait(0.400, Ignore Condition);
			"This is to fix interaction with the Quick Reset (R) right after using punch, so this doesn't disable punch after you respawn. Can have slight bug where player is punching through the start location, and doesn't set cooldown properly."
			Abort If(True && Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP])
				< Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP]);
			Set Secondary Fire Enabled(Event Player, False);
		End;
	}
}