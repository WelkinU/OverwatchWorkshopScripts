settings
{
	main
	{
		Description: "Doomfist Parkour MultiLevel Framework. Source control here: https://github.com/WelkinU/OverwatchWorkshopScripts/tree/master/DoomfistParkourMultilevelFramework"
	}

	modes
	{
		Assault
		{
			enabled maps
			{
			}
		}

		Control
		{
			enabled maps
			{
				Ilios
			}
		}

		Escort
		{
			enabled maps
			{
			}
		}

		Hybrid
		{
			enabled maps
			{
			}
		}

		General
		{
			Hero Limit: Off
			Kill Cam: Off
			Kill Feed: Off
			Respawn Time Scalar: 10%
		}
	}

	heroes
	{
		General
		{
			enabled heroes
			{
				Doomfist
			}
		}
	}
}

variables
{
	global:
		0: CPLocations
		1: LevelDescriptions
		2: CPFacing
		3: CPPunchUpperSlamCounts
		4: CPUltimate360MaxSlamCounts
		5: CPTeleport
		6: CPRadii
		7: LevelsWithLimitedAbilityCounts
		8: LevelOrigins
		9: TopScoreTimes
		10: TopScorePlayer
		11: TopScoreString
		17: CPRadius
		19: TempTeleport
		20: TempUltimate360MaxSlam
		21: TempRadii
		22: TempFacing
		24: CPIterator
		25: LevelIterator

	player:
		0: CurrentCP
		1: CurrentLevel
		3: LevelTimer
		4: PunchUpperSlamUsed
		9: SpectateMode
		14: SlamTimer
		22: ScoreboardString
		23: CancelPointTimer
		32: Array360
		33: Timer360
		34: Count360Slam125
		35: TempViewNextPointPosition
}

subroutines
{
	0: RespawnPlayer
	1: AutogenerateMapVariables
	2: OverrideAutogenVariables
	3: CancelMomentum
	4: OverrideVariablesUserInput
	5: UpdateTopScoreboard
}

rule("UPDATE MAP CONSTANTS HERE - CHECKPOINTS, ABILITIES")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"MAP MAKING INSTRUCTIONS\r\nStep 1: level checkpoints and abilities below\r\nStep 2: CP facing/radii/teleports/ultimates are autogenerated - override using the rule below this one"
		disabled Wait(0.250, Ignore Condition);
		"Default Checkpoint Radius"
		Global.CPRadius = 2;
		"Add to this array the level numbers of levels you want to have ability limits on"
		Global.LevelsWithLimitedAbilityCounts = Array(2);
		"Set level descriptions here, make sure the level number matches the index (ie. make sure Level 1 is on index 1)"
		Global.LevelDescriptions = Array(Null, Custom String("Level 1 (Easy)"), Custom String("Level 2 (Easy)"), Custom String(
			"Level 3 (Medium)"));
		"Set the starting position when the player loads into the game"
		Global.CPLocations = Array(Array(Vector(300, 4, -28.200)));
		"Set the starting position abilities when the player loads into the game"
		Global.CPPunchUpperSlamCounts = Array(Array(Vector(0, 1, 1)));
		"--------------Set Level 1 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[1] = Array(Null, Vector(300.220, -16.160, -44.800), Vector(331.828, -17.104, -16.814), Vector(355.572, -14.360,
			-50.583), Vector(372.154, -25.252, -43.771), Vector(324.158, -16.155, -29.186), Vector(108.809, 65.914, -157.408), Vector(
			55.674, 65.983, -177.915), Vector(36.449, 61.963, -180.084), Vector(50.750, 64.552, -180.257), Vector(64.893, 62.456,
			-174.049), Vector(90.732, 65.802, -173.650), Vector(90.560, 62.199, -148.144), Vector(87.982, 70.017, -150.597));
		Global.CPPunchUpperSlamCounts[1] = Array(Null, Vector(1, 1, 1), Vector(1, 0, 1), Vector(1, 0, 0), Vector(1, 0, 1), Vector(1, 1, 1),
			Vector(1, 1, 1), Vector(0, 0, 1), Vector(0, 1, 0), Vector(0, 0, 1), Vector(1, 1, 0), Vector(0, 1, 1), Vector(0, 1, 1), Vector(
			1, 1, 1));
		"--------------Set Level 2 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[2] = Array(Null, Vector(-37.078, 14.583, -8.837), Vector(-33.992, 20.453, 23.297), Vector(-35.471, 22.495,
			53.428), Vector(-39, 35, -90), Vector(-27.811, 37.938, -53.011), Vector(-18.069, 4.308, -82.686), Vector(-27.811, 37.938,
			-53.011), Vector(-72.856, 20.837, -0.563));
		Global.CPPunchUpperSlamCounts[2] = Array(Null, Vector(1, 1, 0), Vector(1, 1, 1), Vector(1, 1, 1), Vector(3, 3, 1), Vector(0, 2, 1),
			Vector(4, 4, 1), Vector(1, 2, 1), Vector(1, 1, 0), Vector(1, 1, 1));
		"--------------Set Level 3 Parameters. Set CPLocations Index to level number--------------\r\n                               Set all first array elements to NULL"
		Global.CPLocations[3] = Array(Null, Vector(306.392, -16.486, -56.065), Vector(298.880, -23.139, -71.135), Vector(300.889, -13.361,
			-47.271), Vector(285.959, -23.181, -67.560), Vector(307.709, -15.369, 21.944), Vector(314.646, -23.364, 28.089), Vector(
			308.101, -15.371, 22.075), Vector(352.889, -23.277, 14.902), Vector(-253.258, 3.732, 31.956), Vector(-232.771, 4.596, 1.684),
			Vector(-284.524, 1.291, 17.438), Vector(-247.105, 1.001, -7.805));
		Global.CPPunchUpperSlamCounts[3] = Array(Null, Vector(0, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1), Vector(1, 1, 0), Vector(0, 0, 1),
			Vector(1, 0, 0), Vector(0, 1, 0), Vector(1, 1, 1), Vector(0, 1, 0), Vector(1, 0, 0), Vector(0, 1, 1), Vector(1, 1, 1));
		"Autogenerate checkpoint facing, radii, and other variables based on CPLocations"
		Call Subroutine(AutogenerateMapVariables);
		"Override autogenerated variables based on rule right below this one"
		Call Subroutine(OverrideAutogenVariables);
	}
}

rule("OVERRIDE AUTO-GENERATED CP RADII / FACING, SET TELEPORTS, ULTIMATE ENABLE")
{
	event
	{
		Subroutine;
		OverrideVariablesUserInput;
	}

	actions
	{
		"OVERRIDING CHECKPOINT PARAMETERS INSTRUCTIONS\r\nStep 1: Copy/paste code block from \"If(Global.LevelIterator == 0)\" to next \"End\" statement\r\nStep 2: Change the 0 in If(Global.LevelIterator == 0) to the level\r\nStep 3: Add the modifiers for that level (see the"
		disabled Wait(0.250, Ignore Condition);
		"------------------Use this code block to set Level 0 modifiers------------------"
		If(Global.LevelIterator == 0);
			"Example: Use this code to override CP 0 radius to be 3m"
			Global.TempRadii[0] = 3;
			"Example: Code block to override Level 0 CP 0 facing direction (1,0,0)"
			Global.TempFacing[0] = Vector(0.620, -0.250, -0.720);
		End;
		"------------------Use this code block to set Level 1 modifiers------------------"
		If(Global.LevelIterator == 1);
			"Example: Use this code to override CP 3 radius to be 3.5m"
			Global.TempRadii[4] = 3.500;
			"Example: Use this code to override CP 5 to set it to teleport to the next checkpoint"
			Global.TempTeleport[5] = True;
			Global.TempRadii[8] = 1.500;
			"Example: Use this code to override CP 11 to enable require a 125 Slam to complete checkpoint"
			Global.TempUltimate360MaxSlam[11] = Vector(0, 0, 1);
			"Example: Use this code to override CP12 to enable require a 360 to complete the point"
			Global.TempUltimate360MaxSlam[12] = Vector(0, 1, 0);
			"Example: Use this code to override CP 3 to enable Ultimate"
			disabled Global.TempUltimate360MaxSlam[3] = Vector(1, 0, 0);
		End;
		"------------------Use this code block to set Level 2 modifiers------------------"
		If(Global.LevelIterator == 2);
			Global.TempTeleport[3] = True;
		End;
		"------------------Use this code block to set Level 2 modifiers------------------"
		If(Global.LevelIterator == 3);
			Global.TempTeleport[8] = True;
		End;
	}
}

disabled rule("Initialize Player and Map")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Initialize Other Global Constants")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.TopScoreString = Custom String("");
		Enable Death Spectate Target HUD(All Players(All Teams));
	}
}

rule("Initialize Global HUD and Effects")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Wait for Map Checkpoints, radii, etc to get generated. Prevents this rule from running out of order with map generation rules."
		Wait(0.200, Ignore Condition);
		"Create Origin Point Ring"
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0), Ring, Purple, Global.CPLocations[0][0],
			Global.CPRadii[0][0], Visible To);
		For Global Variable(LevelIterator, 1, Count Of(Global.CPLocations), 1);
			"Create Level Entry Rings"
			Create Effect(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0), Ring, Purple,
				Global.CPLocations[Global.LevelIterator][1], Global.CPRadii[Global.LevelIterator][1], Visible To);
			Create In-World Text(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0), Custom String("{0}",
				Global.LevelDescriptions[Global.LevelIterator]), Global.CPLocations[Global.LevelIterator][1], 2, Do Not Clip, Visible To,
				Purple, Default Visibility);
			Create Icon(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0),
				Global.CPLocations[Global.LevelIterator][1], Flag, Visible To, Yellow, True);
		End;
		"Hide Game HUD"
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(
			" \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"),
			Top, 0, White, White, White, Visible To and String, Default Visibility);
		"Controls HUD"
		Create HUD Text(All Players(All Teams), Custom String("Controls"), Null, Null, Left, -2, White, White, White,
			Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("Quick Reset - R\r\nSkip Checkpoint - Jump + Interact\r\n{0}",
			Custom String(
			"Choose New Level - Ultimate + Interact\r\nView Next Checkpoint - Ultimate Status Voiceline\r\nSpectate - Need Healing Voiceline")),
			Left, 0, White, White, White, Visible To and String, Default Visibility);
		"Top Scores HUD"
		Create HUD Text(All Players(All Teams), Custom String("Top Scores"), Null, Null, Left, 1, White, White, Purple,
			Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Global.TopScoreString != Custom String("")), Null, Null, Custom String(
			"{0}", Global.TopScoreString), Left, 2, White, White, Purple, Visible To and String, Default Visibility);
		"Workshop Code HUD"
		Create HUD Text(All Players(All Teams), Custom String("Workshop Code: 7RDMK"), Null, Null, Right, -9, Green, White, White,
			Visible To, Default Visibility);
	}
}

rule("Initialize Player")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Event Player.CurrentCP = 0;
		Event Player.CurrentLevel = 0;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Initialize Player HUD and Effects")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Create HUD Text(Event Player, Null, Null, Custom String("Level {0} Checkpoint {1} - Time {2}", Event Player.CurrentLevel,
			Custom String("{0}/{1}", Event Player.CurrentCP, Count Of(Global.CPLocations[Event Player.CurrentLevel]) - 1),
			Event Player.LevelTimer), Top, -2, White, White, White, Visible To and String, Default Visibility);
		"Create Current Checkpoint Ring"
		Create Effect(Filtered Array(Event Player, Event Player.CurrentCP > 0 && Event Player.CurrentCP + 1 < Count Of(
			Global.CPLocations[Event Player.CurrentLevel])), Ring, Purple,
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP],
			Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP], Visible To Position and Radius);
		"Next Checkpoint Ring"
		Create Effect(Filtered Array(Event Player, Current Array Element.CurrentCP > 0), Ring, Purple,
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1],
			Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 1], Visible To Position and Radius);
		"Create Next Checkpoint Text"
		Create In-World Text(Filtered Array(Event Player, Event Player.CurrentCP > 0 && Event Player.CurrentCP + 1 < Count Of(
			Global.CPLocations[Event Player.CurrentLevel])), Custom String("Come Here!"),
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1], 2, Do Not Clip, Visible To Position and String,
			Purple, Default Visibility);
		"Create Next Checkpoint Icon"
		Create Icon(Filtered Array(Event Player, Event Player.CurrentCP > 0 && Event Player.CurrentCP + 1 < Count Of(
			Global.CPLocations[Event Player.CurrentLevel])), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1],
			Flag, Visible To and Position, Yellow, True);
		"Level 3 HUD: Ability Limits "
		Create HUD Text(Filtered Array(Event Player, Index Of Array Value(Global.LevelsWithLimitedAbilityCounts, Event Player.CurrentLevel)
			>= 0 && Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel])), Custom String(
			"Checkpoint Abilty Limits\r\n{0} {1} {2}", Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(
			Secondary Fire)), X Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])
			- X Component Of(Event Player.PunchUpperSlamUsed)), Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(
			Ability 1)), Y Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) - Y Component Of(
			Event Player.PunchUpperSlamUsed)), Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Ability 2)),
			Z Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) - Z Component Of(
			Event Player.PunchUpperSlamUsed))), Null, Null, Top, -1.400, Blue, White, White, Visible To and String, Default Visibility);
		"360 Required HUD"
		Create HUD Text(Filtered Array(Event Player, Y Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) > 0), Custom String(
			"360's Required: {0}", Y Component Of(Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])),
			Null, Null, Top, -1, Red, White, White, Visible To and String, Default Visibility);
		"125Slam Required HUD"
		Create HUD Text(Filtered Array(Event Player, Z Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) > 0), Custom String(
			"125 Charge Slams Required: {0}", Z Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])), Null, Null, Top, -1, Red, White, White,
			Visible To and String, Default Visibility);
	}
}

disabled rule("Map Building Convenience Features - UNCOMMENT THESE WHEN BUILDING MAP")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}
}

rule("Map Building HUD")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Create HUD Text(Event Player, Custom String("Position {0}\r\nFacing {1}", Position Of(Event Player), Facing Direction Of(
			Event Player)), Null, Null, Right, 0, White, White, White, Visible To and String, Default Visibility);
	}
}

rule("Teleport Enabled with Melee + Left Click")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Primary Fire) == True;
		Is Button Held(Event Player, Melee) == True;
	}

	actions
	{
		Teleport(Event Player, Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 60 * Facing Direction Of(
			Event Player), All Players(All Teams), Event Player, True));
	}
}

disabled rule("Subroutines")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Subroutine 0: RespawnPlayer")
{
	event
	{
		Subroutine;
		RespawnPlayer;
	}

	actions
	{
		Stop Holding Button(Event Player, Ability 1);
		Stop Holding Button(Event Player, Ability 2);
		Stop Holding Button(Event Player, Secondary Fire);
		Stop Holding Button(Event Player, Ultimate);
		Call Subroutine(CancelMomentum);
		Clear Status(Event Player, Phased Out);
		Set Status(Event Player, Null, Phased Out, 9999);
		Cancel Primary Action(Event Player);
		"Safety check in case rules execute out of order, ie Reset to Origin (Q + Interact) pressed same time and get next level"
		If(Event Player.CurrentCP > 0 && Event Player.CurrentLevel == 0);
			Event Player.CurrentCP = 0;
		End;
		"Set location and facing direction of player"
		Teleport(Event Player, Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP]);
		Set Facing(Event Player, Global.CPFacing[Event Player.CurrentLevel][Event Player.CurrentCP], To World);
		"set player abilities"
		Event Player.PunchUpperSlamUsed = Vector(0, 0, 0);
		If(X Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			Set Secondary Fire Enabled(Event Player, False);
		Else;
			Set Secondary Fire Enabled(Event Player, True);
		End;
		If(Y Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			Set Ability 1 Enabled(Event Player, False);
		Else;
			Set Ability 1 Enabled(Event Player, True);
		End;
		If(Z Component Of(Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			Set Ability 2 Enabled(Event Player, False);
		Else;
			Set Ability 2 Enabled(Event Player, True);
		End;
		If(X Component Of(Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
			Set Ultimate Ability Enabled(Event Player, False);
		Else;
			Set Ultimate Ability Enabled(Event Player, True);
		End;
		Set Ultimate Charge(Event Player, 100);
		Wait(0.100, Ignore Condition);
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		If(Event Player.CurrentCP == 0);
			Stop Chasing Player Variable(Event Player, LevelTimer);
			Event Player.LevelTimer = 0;
		End;
		"Redundant, but just in case"
		Event Player.PunchUpperSlamUsed = Vector(0, 0, 0);
		Event Player.Count360Slam125 = Vector(0, 0, 0);
	}
}

rule("Subroutine 1: AutogenerateMapVariables")
{
	event
	{
		Subroutine;
		AutogenerateMapVariables;
	}

	actions
	{
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + -1, 1);
			Global.LevelOrigins[Global.LevelIterator] = Global.CPLocations[Global.LevelIterator + 1][1];
		End;
		"Set the checkpoint location to be the closest walkable position to the CPLocation position entered by player. This is so the map maker can use the Camera button to enter CP locations (which sets eye position instead of player position)"
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + 0, 1);
			Global.X = Global.CPLocations[Global.LevelIterator];
			For Global Variable(CPIterator, 0, Count Of(Global.CPLocations[Global.LevelIterator]) - 0, 1);
				Global.X[Global.CPIterator] = Ray Cast Hit Position(Global.X[Global.CPIterator] + Vector(0, 0.100, 0),
					Global.X[Global.CPIterator] + 2 * Down, All Players(All Teams), Event Player, True);
			End;
			Global.CPLocations[Global.LevelIterator] = Global.X;
			"Initialize TopScoreTimes using this For loop as well"
			Global.TopScoreTimes[Global.LevelIterator] = 10000;
		End;
		"Autogenerate variable arrays"
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + 0, 1);
			"Set CPFacing array to all NULL. NULL means orient player towards direction of next point."
			Global.CPFacing[Global.LevelIterator] = Null;
			"Set CPFacing array to all NULL. NULL means orient player towards direction of next point."
			Global.CPTeleport[Global.LevelIterator] = Null;
			"Set CPRadii array to all DefaultCPRadius (set in \"Initialize Global Constants\" rule)"
			Global.CPRadii[Global.LevelIterator] = Global.CPRadius;
			"Set Ultimate and other special bindings array to all zeros, as most of the time, these will not be bound to a checkpoint."
			Global.CPUltimate360MaxSlamCounts[Global.LevelIterator] = Vector(0, 0, 0);
			For Global Variable(CPIterator, 1, Count Of(Global.CPLocations[Global.LevelIterator]) - 0, 1);
				Modify Global Variable At Index(CPFacing, Global.LevelIterator, Append To Array, Direction Towards(
					Global.CPLocations[Global.LevelIterator][Global.CPIterator], Global.CPLocations[Global.LevelIterator][Global.CPIterator + 1]));
				Modify Global Variable At Index(CPTeleport, Global.LevelIterator, Append To Array, Null);
				Modify Global Variable At Index(CPRadii, Global.LevelIterator, Append To Array, Global.CPRadius);
				Modify Global Variable At Index(CPUltimate360MaxSlamCounts, Global.LevelIterator, Append To Array, Vector(0, 0, 0));
			End;
		End;
	}
}

rule("Subroutine 2: OverrideAutogenVariables")
{
	event
	{
		Subroutine;
		OverrideAutogenVariables;
	}

	actions
	{
		"OVERRIDING CHECKPOINT PARAMETERS INSTRUCTIONS\r\nStep 1: Copy/paste code block from \"If(Global.LevelIterator == 0)\" to next \"End\" statement\r\nStep 2: Change the 0 in If(Global.LevelIterator == 0) to the level\r\nStep 3: Add the modifiers for that level (see the"
		disabled Wait(0.250, Ignore Condition);
		"Need this whole structure because Workshop Editor doesn't let you index into array's of arrays"
		For Global Variable(LevelIterator, 0, Count Of(Global.CPLocations) + 0, 1);
			Global.TempTeleport = Global.CPTeleport[Global.LevelIterator];
			Global.TempUltimate360MaxSlam = Global.CPUltimate360MaxSlamCounts[Global.LevelIterator];
			Global.TempRadii = Global.CPRadii[Global.LevelIterator];
			Global.TempFacing = Global.CPFacing[Global.LevelIterator];
			Call Subroutine(OverrideVariablesUserInput);
			Global.CPFacing[Global.LevelIterator] = Global.TempFacing;
			Global.CPRadii[Global.LevelIterator] = Global.TempRadii;
			Global.CPUltimate360MaxSlamCounts[Global.LevelIterator] = Global.TempUltimate360MaxSlam;
			Global.CPTeleport[Global.LevelIterator] = Global.TempTeleport;
		End;
	}
}

rule("Subroutine 3: Cancel Momentum")
{
	event
	{
		Subroutine;
		CancelMomentum;
	}

	actions
	{
		Apply Impulse(Event Player, Up, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Down, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Left, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Right, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Forward, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Backward, 0.001, To World, Cancel Contrary Motion);
	}
}

rule("Subroutine 5: UpdateTopScoreboard")
{
	event
	{
		Subroutine;
		UpdateTopScoreboard;
	}

	actions
	{
		Event Player.ScoreboardString = Custom String("");
		For Player Variable(Event Player, CancelPointTimer, Count Of(Global.TopScoreTimes) - 1, -1, -1);
			If(Global.TopScoreTimes[Event Player.CancelPointTimer] < 10000);
				If(Event Player.ScoreboardString == Custom String(""));
					Event Player.ScoreboardString = Custom String("Level {0} - {1} {2}", Event Player.CancelPointTimer + 0,
						Global.TopScorePlayer[Event Player.CancelPointTimer + 0], Global.TopScoreTimes[Event Player.CancelPointTimer + 0]);
				Else;
					Event Player.ScoreboardString = Custom String("{0}\r\n{1}", Event Player.ScoreboardString, Custom String("Level {0} - {1} {2}",
						Event Player.CancelPointTimer + 0, Global.TopScorePlayer[Event Player.CancelPointTimer + 0],
						Global.TopScoreTimes[Event Player.CancelPointTimer + 0]));
				End;
			End;
		End;
		Global.TopScoreString = Event Player.ScoreboardString;
	}
}

disabled rule("Multi-Level Framework")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Enter Into Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Count Of(Filtered Array(Global.LevelOrigins, Distance Between(Current Array Element, Position Of(Event Player)) < 2)) > 0;
		Is On Ground(Event Player) == True;
		Event Player.CurrentCP == 0;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Play Effect(Event Player, Buff Explosion Sound, White, Event Player, 60);
		Event Player.CurrentCP = 1;
		Event Player.CurrentLevel = Index Of Array Value(Global.LevelOrigins, First Of(Filtered Array(Global.LevelOrigins,
			Distance Between(Position Of(Event Player), Current Array Element) < 2))) + 1;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Touched ground without entering level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Count Of(Filtered Array(Global.LevelOrigins, Distance Between(Current Array Element, Position Of(Event Player)) < 2)) == 0;
		Is On Ground(Event Player) == True;
		Event Player.CurrentCP == 0;
		Has Spawned(Event Player) == True;
		"Not on current checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 0])
			> Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 0];
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Start Timer When Player Leaves Origin Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Distance Between(Position Of(Event Player), Global.CPLocations[0][0]) > Global.CPRadii[0][0];
		Event Player.CurrentCP <= 0;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		"To prevent this rule from triggering before the rule that tele's player to start point"
		Wait(0.250, Abort When False);
		Event Player.LevelTimer = 0;
		Chase Player Variable At Rate(Event Player, LevelTimer, 99999, 1, Destination and Rate);
	}
}

rule("Arrived At Next Checkpoint")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Within range of next checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1])
			< Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 1];
		"Player has selected a level"
		Event Player.CurrentCP > 0;
		Is On Ground(Event Player) == True;
		"Is not on last checkpoint in level"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		Event Player.CurrentLevel > 0;
	}

	actions
	{
		If(Y Component Of(Event Player.Count360Slam125) < Z Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			Small Message(Event Player, Custom String("Checkpoint Requires 125 charge slam", Z Component Of(
				Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])));
			Call Subroutine(RespawnPlayer);
			Abort;
		End;
		If(X Component Of(Event Player.Count360Slam125) < Y Component Of(
			Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			Small Message(Event Player, Custom String("Checkpoint Requires {0} 360's. Spin Around!", Y Component Of(
				Global.CPUltimate360MaxSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP])));
			Call Subroutine(RespawnPlayer);
			Abort;
		End;
		Event Player.CurrentCP += 1;
		Play Effect(Event Player, Buff Explosion Sound, White, Event Player, 60);
		If(Global.CPTeleport[Event Player.CurrentLevel][Event Player.CurrentCP] != Null);
			Event Player.CurrentCP += 1;
		End;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Respawn If Touched Ground Not On Checkpoints")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Not on current checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 0])
			> Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 0];
		"Not within range of next checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1])
			> Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP + 1];
		"Player has selected a level"
		Event Player.CurrentCP > 0;
		Is On Ground(Event Player) == True;
		"Is not on last checkpoint in level"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Finished Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Is on last checkpoint in level"
		Event Player.CurrentCP + 1 == Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		Event Player.CurrentCP > 0;
		Event Player.CurrentLevel > 0;
		Event Player.LevelTimer > 0;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, LevelTimer);
		Big Message(All Players(All Teams), Custom String("{0} Finished Level {1} in {2}sec", Event Player, Event Player.CurrentLevel,
			Event Player.LevelTimer));
		"If player got top score, update top scores"
		If(Event Player.LevelTimer < Global.TopScoreTimes[Event Player.CurrentLevel]);
			Global.TopScoreTimes[Event Player.CurrentLevel] = Event Player.LevelTimer;
			Global.TopScorePlayer[Event Player.CurrentLevel] = Event Player;
		End;
		Call Subroutine(UpdateTopScoreboard);
		Small Message(Event Player, Custom String("Use Ultimate + Interact To Restart"));
	}
}

rule("Respawn Player If They Die")
{
	event
	{
		Player Died;
		All;
		All;
	}

	conditions
	{
		Event Player.SpectateMode == False;
	}

	actions
	{
		Respawn(Event Player);
		Wait(0.100, Ignore Condition);
		Call Subroutine(RespawnPlayer);
	}
}

disabled rule("Additional Features")
{
	event
	{
		Ongoing - Global;
	}
}

rule("R -> Quick Reset")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Reload) == True;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Ultimate + Interact -> Reset to Origin Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Ultimate) == True;
		Is Button Held(Event Player, Interact) == True;
	}

	actions
	{
		Event Player.CurrentCP = 0;
		Event Player.CurrentLevel = 0;
		Stop Chasing Player Variable(Event Player, LevelTimer);
		Event Player.LevelTimer = 0;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Jump + Interact -> Skip Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Jump) == True;
		Is Button Held(Event Player, Interact) == True;
		Event Player.CurrentLevel > 0;
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, LevelTimer);
		Event Player.LevelTimer = 0;
		Event Player.CurrentCP += 1;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Crouch + Interact -> Go Back A Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Crouch) == True;
		Is Button Held(Event Player, Interact) == True;
		Event Player.CurrentLevel > 0;
		Event Player.CurrentCP + 0 > 1;
	}

	actions
	{
		Event Player.CurrentCP -= 1;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Can Melee Cancel Slam")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		Is Button Held(Event Player, Melee) == True;
	}

	actions
	{
		Cancel Primary Action(Event Player);
		Small Message(Event Player, Custom String("Testing melee slam cancel"));
	}
}

rule("Ultimate Status Voiceline: Camera To See Next Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating(Event Player, Ultimate Status) == True;
		"Make sure next point exists"
		Count Of(Global.CPLocations[Event Player.CurrentLevel]) > Event Player.CurrentCP + 1;
	}

	actions
	{
		Event Player.TempViewNextPointPosition = Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1];
		Set Facing(Event Player, Vector(-10, -10, 0), To World);
		Start Camera(Event Player, Ray Cast Hit Position(Event Player.TempViewNextPointPosition,
			Event Player.TempViewNextPointPosition + Facing Direction Of(Event Player) * -15, All Players(All Teams), Event Player, True),
			Event Player.TempViewNextPointPosition, 30);
		Wait(3, Ignore Condition);
		Stop Camera(Event Player);
	}
}

rule("Need Healing Voiceline: Spectate Other Players")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating(Event Player, Need Healing) == True;
	}

	actions
	{
		Enable Death Spectate All Players(All Players(All Teams));
		If(Is Dead(Event Player));
			Enable Built-In Game Mode Respawning(Event Player);
			Resurrect(Event Player);
			Wait(0.100, Ignore Condition);
			Call Subroutine(RespawnPlayer);
			Event Player.SpectateMode = False;
		Else;
			Big Message(Event Player, Custom String("Use \"Need Healing\" voiceline to exit Spectate Mode!"));
			Event Player.SpectateMode = True;
			Disable Built-In Game Mode Respawning(Event Player);
			Kill(Event Player, Null);
		End;
		Set Status(Event Player, Null, Phased Out, 9999);
	}
}

disabled rule("360 Code :D")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}
}

rule("Update 360 Array")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Array360[Round To Integer((Horizontal Facing Angle Of(Event Player) + 180) / 90.010, Down)] != True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		disabled Event Player.Array360[Round To Integer((Horizontal Facing Angle Of(Event Player) + 180) / (360 / Count Of(Event Player.Array360)),
			Down)] = True;
		Event Player.Array360[Round To Integer((Horizontal Facing Angle Of(Event Player) + 180) / 90.010, Down)] = True;
		"Start timer if player has started 360"
		If(Count Of(Filtered Array(Event Player.Array360, Current Array Element == True)) == 2);
			Event Player.Timer360 = 0;
			Chase Player Variable At Rate(Event Player, Timer360, 1, 1, Destination and Rate);
		End;
	}
}

rule("Reset 360 Array after 1 sec")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Timer360 >= 1;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		For Player Variable(Event Player, I, 0, Count Of(Event Player.Array360), 1);
			Event Player.Array360[Event Player.I] = False;
		End;
		disabled Event Player.Array360 = Array(False, False, False, False);
		Event Player.Timer360 = 0;
		Stop Chasing Player Variable(Event Player, Timer360);
	}
}

rule("Successful 360")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is True For All(Event Player.Array360, Current Array Element) == True;
		Has Spawned(Event Player) == True;
		"Can't do 360 in starting checkpoint circle"
		Distance Between(Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP], Position Of(Event Player))
			> Global.CPRadius;
		"So most stalls dont let you 360 for free"
		Altitude Of(Event Player) > 0.500;
	}

	actions
	{
		Small Message(Event Player, Custom String("360"));
		Event Player.Count360Slam125 += Left;
		Play Effect(Event Player, Buff Impact Sound, White, Event Player, 60);
	}
}

disabled rule("Ability Limits Stuff")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Used Secondary (Rocket Punch)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Left;
	}
}

rule("Used Ability 1 (Uppercut)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Up;
	}
}

rule("Used Ability 2 - Start Slam Timer")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Event Player.SlamTimer = 0;
		Chase Player Variable At Rate(Event Player, SlamTimer, 99, 1, Destination and Rate);
	}
}

rule("Used Ability 2 + 125 Slam Detector")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == False;
		Has Spawned(Event Player) == True;
		"To stop this rule from double triggering"
		Event Player.SlamTimer > 0;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, SlamTimer);
		"Prevent invalid slam (where press slam button but you are not allowed to slam) from counting as a slam. Matters for ability count limits."
		disabled If(Is On Ground(Event Player) || Event Player.SlamTimer >= 0.250);
		disabled Event Player.PunchUpperSlamUsed += Forward;
		disabled End;
		"Detect 125 slam. Formula is Slam Damage = 100 * (Slam Time) - 28, so 125 slam requires at least 1.53 sec of slam time."
		disabled If(Event Player.SlamTimer >= 1.520);
		disabled Event Player.Count360Slam125 += Up;
		disabled Small Message(Event Player, Custom String("125 Slam"));
		disabled Play Effect(Event Player, Buff Impact Sound, White, Event Player, 60);
		disabled End;
		Event Player.SlamTimer = 0;
	}
}

rule("Increment Slam Counter")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		"Prevents invalid slam (where player presses slam button but can't slam) from being counted"
		((Is On Ground(Event Player) && Event Player.SlamTimer > 0.040 && Event Player.SlamTimer < 0.250) || (
			Event Player.SlamTimer > 0.250)) == True;
		Has Spawned(Event Player) == True;
		Is Using Ability 2(Event Player) == True;
		disabled Event Player.SlamTimer > 0.250;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Forward;
		If(Is On Ground(Event Player));
			Stop Chasing Player Variable(Event Player, SlamTimer);
			Event Player.SlamTimer = 0;
		End;
	}
}

rule("125 Slam Detection")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		"Actual time is 1.53 for 125 slam + cancel, but removing cancel ~.3 sec"
		Event Player.SlamTimer >= 1.220;
		Is Using Ability 2(Event Player) == True;
		"To prevent player from just holding down slam at invalid slam angle to get a 125 slam"
		Is Button Held(Event Player, Ability 2) == False;
	}

	actions
	{
		Event Player.Count360Slam125 += Up;
		Small Message(Event Player, Custom String("125 Slam"));
		Play Effect(Event Player, Buff Impact Sound, White, Event Player, 60);
	}
}

rule("Limiter for Ability Counts")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Is in ability limited level"
		Index Of Array Value(Global.LevelsWithLimitedAbilityCounts, Event Player.CurrentLevel) > -1;
		"Is using an ability"
		(Is Using Ability 1(Event Player) || Is Using Ability 2(Event Player) || Is Firing Secondary(Event Player)) == True;
		"Inside a level, not in multilevel portion"
		Event Player.CurrentCP > 0;
		"Is NOT on last checkpoint of the level"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
	}

	actions
	{
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
		If(Y Component Of(Event Player.PunchUpperSlamUsed) >= Y Component Of(
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			Set Ability 1 Enabled(Event Player, False);
		End;
		If(Z Component Of(Event Player.PunchUpperSlamUsed) >= Z Component Of(
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			Set Ability 2 Enabled(Event Player, False);
		End;
		If(X Component Of(Event Player.PunchUpperSlamUsed) >= X Component Of(
			Global.CPPunchUpperSlamCounts[Event Player.CurrentLevel][Event Player.CurrentCP]));
			"Have to wait to disable punch because otherwise it would disable immediately after using preventing punch from working properly."
			Wait(0.400, Ignore Condition);
			"This is to fix interaction with the Quick Reset (R) right after using punch, so this doesn't disable punch after you respawn. Can have slight bug where player is punching through the start location, and doesn't set cooldown properly."
			Abort If(True && Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP])
				< Global.CPRadii[Event Player.CurrentLevel][Event Player.CurrentCP]);
			Set Secondary Fire Enabled(Event Player, False);
		End;
	}
}