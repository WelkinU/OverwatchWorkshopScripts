settings
{
	main
	{
		Description: "Doomfist Pioneering Parkour - MultiLevel Edition v1.0! Have multiple Pioneer Parkour Levels running, each with different rules. Supports multi-hero levels, with Sigma (by ReZero), Ana, Winston, Roadhog, and more! Made by WelkinTern.   Level 1: Pioneer Timer  Level 2: No Restriction  Level 3: Ability Restrictions  Source Control: https://github.com/WelkinU/OverwatchWorkshopScripts"
	}

	modes
	{
		Capture the Flag
		{
			enabled maps
			{
				Ayutthaya
				Busan Downtown Lunar New Year
			}
		}

		Deathmatch
		{
			enabled maps
			{
				Château Guillard
				Petra
			}
		}

		Skirmish
		{
			disabled maps
			{
				Blizzard World
				Hanamura Winter
				Hollywood Halloween
				King's Row
				Lijiang Tower Lunar New Year
				Workshop Chamber
				Workshop Expanse
				Workshop Expanse Night
				Workshop Island
				Workshop Island Night
			}
		}

		General
		{
			Hero Limit: Off
			Kill Feed: Off
		}
	}

	heroes
	{
		Team 1
		{
			Genji
			{
				Ammunition Clip Size Scalar: 25%
				Swift Strike Cooldown Time: 75%
				Ultimate Duration: 34%
			}
		}

		Team 2
		{
			Genji
			{
				Ammunition Clip Size Scalar: 25%
				Swift Strike Cooldown Time: 75%
				Ultimate Duration: 34%
			}
		}

		Team FFA
		{
			Genji
			{
				Swift Strike Cooldown Time: 75%
				Ultimate Duration: 34%
			}
		}

		General
		{
			Ana
			{
				Ammunition Clip Size Scalar: 25%
				Biotic Grenade Cooldown Time: 60%
				Sleep Dart Cooldown Time: 75%
			}

			Baptiste
			{
				Immortality Field Cooldown Time: 70%
				Regenerative Burst Cooldown Time: 70%
			}

			Roadhog
			{
				Ammunition Clip Size Scalar: 25%
				Chain Hook Cooldown Time: 75%
				Take a Breather Cooldown Time: 75%
			}

			Sigma
			{
				Kinetic Grasp Cooldown Time: 20%
			}

			Widowmaker
			{
				Grappling Hook Cooldown Time: 0%
			}

			Winston
			{
				No Ammunition Requirement: On
				Ultimate Duration: 60%
			}

			enabled heroes
			{
				Doomfist
			}
		}
	}
}

variables
{
	global:
		0: CPLocations
		3: LevelDescriptions
		4: CurrentPioneer
		5: PlayerLeaderboard
		6: GameStarted
		7: HeroUseArrayofArrays
		8: CountPunchUpperSlam
		9: CountMeteorTeleportPrimary
		11: MinPioneerDistanceConstant
		12: PioneerTimeLimitConstant
		13: HeroList
		14: HeroHelp
		15: PrimaryFireUsefulForTheseHeros
		17: CPRadius
		18: SinglePlayerModeEnabled
		19: TextLevelCreateMenu
		20: IndexLevelCreateMenu
		22: TempPlayerLeftIterator
		23: LeaderboardString
		24: TempLeaderboardIterator

	player:
		0: CurrentCP
		1: CurrentLevel
		2: LevelMaxUnlockedCPArray
		3: CheckpointTimer
		4: PunchUpperSlamUsed
		5: CountUltimateTeleportPrimary
		6: TotalTimeSpentOnLastCP
		7: TeleportEnabled
		9: SpectateMode
		10: ForceRespawn
		11: LevelCreationEnabled
		12: JumpInteractTimer
		15: IsPioneer
		16: AnaSleepDartTeleLocation
		17: WinstonWallClimbEnabled
		18: WinstonBubbleLocation
		19: WinstonBouncyBubbleCooldown
		21: WinstonBubbleEffect
		23: CancelPointTimer
		25: EnterIntoLevelIterator
		26: sigma_barrier_ready_to_destroy
		27: sigma_barrier_ON
		28: sigma_barrier_direction
		29: sigma_barrier_init_position
		30: sigma_barrier_chase
		31: sigma_barrier_position
}

subroutines
{
	0: RespawnPlayer
	1: MakeMenuText
	2: CancelMomentum
}

disabled rule("Initialization")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Initialize Global Variables")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Set this variable to TRUE if you want to enable a player to be pioneer multiple checkpoints in a row"
		Global.SinglePlayerModeEnabled = False;
		"The amount of time a pioneer has to make a point"
		Global.PioneerTimeLimitConstant = 180;
		"Minimum distance between checkpoints that pioneer can make - don't make this less than 4m"
		Global.MinPioneerDistanceConstant = 8;
		Disable Inspector Recording;
		Enable Death Spectate All Players(All Players(All Teams));
		Disable Built-In Game Mode Completion;
		"If you want to add an extra level type to the game mode, just add a description here and that's it!"
		Global.LevelDescriptions = Array(Custom String("Free Roam"), Custom String("Level 1: Easy"), Custom String("Level 2: Medium"),
			Custom String("Level 3: Expert"), Custom String("Level 4: Multi-Hero"), Custom String("Level 5: Sigma Parkour"));
		Global.PrimaryFireUsefulForTheseHeros = Array(Hero(Ana));
		"Global constant for checkpoint circle radius"
		Global.CPRadius = 2;
		"Set to False, if pioneer has not set Multi-Level Origin point"
		Global.GameStarted = False;
		"Initialization to array of NULL not actually necessary, but for future coders to see the global variable structure, this is here"
		For Global Variable(Z, 0, Count Of(Global.LevelDescriptions) + 1, 1);
			Global.CPLocations[Global.Z] = Null;
			Global.CurrentPioneer[Global.Z] = Array(Host Player);
			Global.CountPunchUpperSlam[Global.Z] = Array(Vector(9, 9, 9));
			Global.CountMeteorTeleportPrimary[Global.Z] = Array(Vector(9, 9, 9));
			Global.HeroUseArrayofArrays[Global.Z] = Array(Hero(Doomfist));
		End;
		"Set the hero rotation for multi-hero level"
		Global.HeroList = Array(Hero(Doomfist), Hero(Sigma), Hero(Ana), Hero(Winston), Hero(Roadhog), Hero(Lúcio), Hero(Genji), Hero(
			Baptiste));
		"Set a custom \"player help string\" for each hero. Make sure the help text order is same as hero order above."
		Global.HeroHelp = Array(Custom String("Doomfist\r\nUltimate Move Speed Slowed"), Custom String(
			"Sigma\r\nBarrier - Functions as bouncepad\r\nKinetic Grasp - Sets gravity to 0 for ability duration\r\nRock - Launches you in opporect"),
			Custom String(
			"Ana\r\nPrimary Fire - Impulse in Direction\r\nSleep Dart - Teleport\r\nBiotic Nade - Impulse in Direction\r\nNano - Doesn't Do Anything "),
			Custom String("Winston\r\nUse Bubble Shield creates sphere that you can bounce on\r\nNew passive ability: Wall Climb"),
			Custom String("Roadhog\r\n{0}\r\n{1}", Custom String(
			"Chain Hook now functions like Widowmaker hook\r\nTake a Breather makes you bounce - faster fall = higher bounce"),
			Custom String("Right Click is like Ashe Coach Gun\r\nWhole Hog knocks you back - even through walls")), Custom String(
			"Lucio\r\nUltimate prevents you from dying while touching ground"), Custom String("Genji\r\nUltimate Duration Lowered"),
			Custom String("Baptiste\r\nAbility 1 is now slide\r\nUltimate doesn't do anything right now"), Custom String(
			"Zenyatta\r\n{0}\r\n{1}\r\n{2}", Custom String(
			"Right Click - Hover. Combine with melee cancel for more height/distance\r\nAttractor Orb - Attracts you when active"),
			Custom String("Repeller Orb - Repels you when active"), Custom String(
			"Hold Ability 1/2 to place orbs. Crouch to activate/deactivate orb\r\nUltimate - Hover 1m above ground for ult duration")));
	}
}

rule("Initialize Global HUD")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Move Game HUD Offscreen"
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(
			"\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"),
			Top, -1, White, White, White, Visible To and String, Default Visibility);
		"If first checkpoint has not been placed, show HUD prompting pioneer (Host Player) to press R to start the map."
		Create HUD Text(Filtered Array(All Players(All Teams), !Global.GameStarted), Custom String(
			"{0} leave the spawn and press R\r\nto create the origin point!", Host Player), Null, Null, Top, -3, Green, White, White,
			Visible To and String, Default Visibility);
		"Controls HUD"
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(
			"Quick Reset: Reload\r\nGo back a CP: Jump + Interact\r\n{0}\r\n{1}\r\n{2}", Custom String(
			"Change Level: Hold Jump + Interact 2 Sec\r\nTeleport (Use Sparingly): Melee + Left Click\r\nView Next CP Location: Ultimate Status"),
			Custom String(
			"Spectate Mode: Need Healing Voiceline\r\nSkip Level (after 5 min): Interact + Melee\r\nEnable Level Creation: Interact + Crouchch"),
			Custom String("Switch Hero (Multi-Hero Level Only): Emote")), Left, 1, White, White, White, Visible To and String,
			Default Visibility);
		Create HUD Text(All Players(All Teams), Custom String("Controls"), Null, Null, Left, 0, White, White, White, Visible To and String,
			Default Visibility);
		"Player level/CP leaderboard HUD"
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0}", Global.LeaderboardString), Right, 0, White, White, White,
			Visible To and String, Default Visibility);
		"Workshop Code HUD"
		Create HUD Text(All Players(All Teams), Custom String("Workshop Code: KN199P"), Null, Null, Right, -2, White, White, White,
			Visible To and String, Default Visibility);
	}
}

rule("Initialize Player Variables and HUD")
{
	event
	{
		Player Joined Match;
		All;
		All;
	}

	actions
	{
		Enable Death Spectate Target HUD(Event Player);
		Event Player.CurrentCP = 0;
		Event Player.CurrentLevel = 0;
		If(Event Player == Host Player);
			Event Player.LevelCreationEnabled = True;
		End;
		Set Status(Event Player, Null, Phased Out, 9999);
		Event Player.TeleportEnabled = True;
		"Initialize Total Spent Time On CP (used for level skip option)"
		Event Player.TotalTimeSpentOnLastCP = 0;
		Chase Player Variable At Rate(Event Player, TotalTimeSpentOnLastCP, 9999, 1, Destination and Rate);
		"Rings and Pioneer Text HUD"
		Create Effect(Filtered Array(Event Player, Event Player.CurrentCP > 0), Ring, Purple,
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP], Global.CPRadius, Visible To Position and Radius);
		Create Effect(Filtered Array(Event Player, Event Player.CurrentCP > 0 && Event Player.CurrentCP + 1 < Count Of(
			Global.CPLocations[Event Player.CurrentLevel])), Ring, Purple,
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1], Global.CPRadius, Visible To Position and Radius);
		Create In-World Text(Filtered Array(Event Player, Event Player.CurrentCP > 0 && Event Player.CurrentCP + 1 < Count Of(
			Global.CPLocations[Event Player.CurrentLevel])), Custom String("Next Checkpoint\r\nPioneer {0}",
			Global.CurrentPioneer[Event Player.CurrentLevel][Event Player.CurrentCP + 0]),
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1], 2, Do Not Clip, Visible To Position and String,
			Purple, Default Visibility);
		"Player Current Level and Checkpoint HUD text"
		Create HUD Text(Event Player, Custom String("Level {0} CP {1}/{2}", Event Player.CurrentLevel, Event Player.CurrentCP, Count Of(
			Global.CPLocations[Event Player.CurrentLevel]) - 1), Null, Null, Top, -2, White, White, White, Visible To and String,
			Default Visibility);
		"Checkpoint Timer HUD - Used on Level 1"
		Create HUD Text(Filtered Array(Event Player, Current Array Element.CheckpointTimer > 0), Custom String("Time Remaining: {0}sec",
			Event Player.CheckpointTimer), Null, Null, Top, -1, White, White, White, Visible To and String, Default Visibility);
		"Hero Help HUD"
		Create HUD Text(Event Player, Null, Null, Global.HeroHelp[Index Of Array Value(Global.HeroList, Hero Of(Event Player))], Left, 5,
			White, White, Green, Visible To and String, Default Visibility);
		Create HUD Text(Event Player, Custom String("{0} Modifiers", Hero Of(Event Player)), Null, Null, Left, 4, White, White, White,
			Visible To and String, Default Visibility);
		"Pioneer Timer"
		disabled Create HUD Text(Filtered Array(Event Player, Event Player.IsPioneer == True), Custom String("Pioneer Timer: {0}/{1}",
			Event Player.TotalTimeSpentOnLastCP, Global.PioneerTimeLimitConstant), Null, Null, Right, -0.100, White, White, White,
			Visible To and String, Default Visibility);
		"HUD indicating player is waiting for pioneer to make next point"
		Create HUD Text(Filtered Array(Event Player, Count Of(Global.CPLocations[Event Player.CurrentLevel]) > Count Of(
			Global.CurrentPioneer[Event Player.CurrentLevel])), Custom String("{0} - Waiting for next pioneer",
			Global.LevelDescriptions[Event Player.CurrentLevel]), Null, Null, Top, -1.500, Green, White, White, Visible To and String,
			Default Visibility);
		"HUD indicating player is waiting for pioneer to make next point"
		Create HUD Text(Filtered Array(Event Player, Count Of(Global.CPLocations[Event Player.CurrentLevel]) == Count Of(
			Global.CurrentPioneer[Event Player.CurrentLevel])), Custom String("Pioneer: {0} {1}/{2}sec", Last Of(
			Global.CurrentPioneer[Event Player.CurrentLevel]), Last Of(Global.CurrentPioneer[Event Player.CurrentLevel])
			.TotalTimeSpentOnLastCP, Global.PioneerTimeLimitConstant), Null, Null, Top, -1.500, Green, White, White, Visible To and String,
			Default Visibility);
		"Level 3 HUD: Ability Limits "
		Create HUD Text(Filtered Array(Event Player, Event Player.CurrentLevel == 3 && Event Player.CurrentCP + 1 < Count Of(
			Global.CPLocations[Event Player.CurrentLevel])), Custom String("Checkpoint Abilty Limits\r\n{0} {1} {2}", Custom String(
			"{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Secondary Fire)), X Component Of(
			Global.CountPunchUpperSlam[Event Player.CurrentLevel][Event Player.CurrentCP]) - X Component Of(
			Event Player.PunchUpperSlamUsed)), Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Ability 1)),
			Y Component Of(Global.CountPunchUpperSlam[Event Player.CurrentLevel][Event Player.CurrentCP]) - Y Component Of(
			Event Player.PunchUpperSlamUsed)), Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Ability 2)),
			Z Component Of(Global.CountPunchUpperSlam[Event Player.CurrentLevel][Event Player.CurrentCP]) - Z Component Of(
			Event Player.PunchUpperSlamUsed))), Null, Null, Top, -1.400, Blue, White, White, Visible To and String, Default Visibility);
	}
}

rule("Player Leaderboard Computation & String Generation [POSSIBLE TO REMOVE LOOP HERE USING EVENT DRIVEN ARCHITECTURE]")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Wait(0.250, Ignore Condition);
		Global.PlayerLeaderboard = Sorted Array(All Players(All Teams),
			Current Array Element.CurrentLevel * -1000 + Current Array Element.CurrentCP * -1);
		For Global Variable(TempLeaderboardIterator, 0, Count Of(Global.PlayerLeaderboard), 1);
			If(Global.TempLeaderboardIterator == 0);
				Global.LeaderboardString = Custom String("{1}", Global.LeaderboardString, Custom String("{0} Level {1} CP {2}",
					Global.PlayerLeaderboard[Global.TempLeaderboardIterator],
					Global.PlayerLeaderboard[Global.TempLeaderboardIterator].CurrentLevel,
					Global.PlayerLeaderboard[Global.TempLeaderboardIterator].CurrentCP));
			Else;
				Global.LeaderboardString = Custom String("{0}\r\n{1}", Global.LeaderboardString, Custom String("{0} Level {1} CP {2}",
					Global.PlayerLeaderboard[Global.TempLeaderboardIterator],
					Global.PlayerLeaderboard[Global.TempLeaderboardIterator].CurrentLevel,
					Global.PlayerLeaderboard[Global.TempLeaderboardIterator].CurrentCP));
			End;
		End;
		Loop;
	}
}

rule("If player joins after origin point created, start them at origin point")
{
	event
	{
		Player Joined Match;
		All;
		All;
	}

	conditions
	{
		Global.GameStarted == True;
	}

	actions
	{
		Wait(0.100, Ignore Condition);
		Loop If(!Has Spawned(Event Player));
		Wait(0.100, Ignore Condition);
		Call Subroutine(RespawnPlayer);
	}
}

disabled rule("Debug HUD")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		disabled Create HUD Text(Event Player, Custom String("Current Level Pioneer: {0}", Last Of(
			Global.CurrentPioneer[Event Player.CurrentLevel])), Null, Null, Left, 9, White, White, White, Visible To and String,
			Default Visibility);
		Create HUD Text(Event Player, Custom String("Time spent on CP: {0}", Event Player.TotalTimeSpentOnLastCP), Null, Null, Right, 9,
			White, White, White, Visible To and String, Default Visibility);
		Create HUD Text(Event Player, Custom String("{0} {1} {2}", Custom String("{0} {1}", Ability Icon String(Hero(Doomfist), Button(
			Secondary Fire)), X Component Of(Event Player.PunchUpperSlamUsed)), Custom String("{0} {1}", Ability Icon String(Hero(
			Doomfist), Button(Ability 1)), Y Component Of(Event Player.PunchUpperSlamUsed)), Custom String("{0} {1}", Ability Icon String(
			Hero(Doomfist), Button(Ability 2)), Z Component Of(Event Player.PunchUpperSlamUsed))), Null, Null, Left, 2, White, White,
			White, Visible To and String, Default Visibility);
		Create HUD Text(Event Player, Custom String("is using abilty {0} {1}", Is Firing Secondary(Event Player), Is Using Ability 2(
			Event Player)), Null, Null, Left, 0, White, White, White, Visible To and String, Default Visibility);
	}
}

disabled rule("Multi-Level Architecture")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Host Create Multilevel Origin Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.GameStarted == False;
		Is Button Held(Host Player, Reload) == True;
		Event Player == Host Player;
		Has Spawned(Event Player) == True;
		Is On Ground(Event Player) == True;
	}

	actions
	{
		Small Message(All Players(All Teams), Custom String("Creating origin point"));
		For Player Variable(Event Player, EnterIntoLevelIterator, 0, Count Of(Global.LevelDescriptions), 1);
			Global.CPLocations[Event Player.EnterIntoLevelIterator] = Array(Position Of(Event Player));
		End;
		"Create origin ring - visible to all players on Level 0 (level selection part)."
		Create Effect(Filtered Array(All Players(All Teams), Global.GameStarted && Current Array Element.CurrentCP == 0), Ring, Purple,
			Global.CPLocations[0][0], Global.CPRadius, Visible To Position and Radius);
		Global.GameStarted = True;
		"Menu is not zero indexed, using 1 as base index"
		Global.IndexLevelCreateMenu = 1;
		Call Subroutine(MakeMenuText);
		"Create Level Type Creation Menu"
		Create HUD Text(Filtered Array(All Players(All Teams),
			Current Array Element.CurrentCP == 0 && Current Array Element.LevelCreationEnabled == True), Global.TextLevelCreateMenu, Null,
			Null, Top, -2, White, White, White, Visible To and String, Default Visibility);
		Call Subroutine(RespawnPlayer);
		"Respawn other players"
		Filtered Array(All Players(All Teams),
			Current Array Element.CurrentLevel == Event Player.CurrentLevel && Current Array Element.CurrentCP == Event Player.CurrentCP)
			.ForceRespawn = True;
	}
}

rule("Interact + Crouch On CP 0 To Enable Level Creation")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.CurrentCP == 0;
		Is Button Held(Event Player, Interact) == True;
		Is Button Held(Event Player, Crouch) == True;
	}

	actions
	{
		If(Event Player.LevelCreationEnabled);
			Event Player.LevelCreationEnabled = False;
			Small Message(All Players(All Teams), Custom String("Level Creation Disabled"));
		Else;
			Event Player.LevelCreationEnabled = True;
			Small Message(All Players(All Teams), Custom String("Level Creation Enabled"));
		End;
	}
}

rule("Create New Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Distance Between(Global.CPLocations[0][0], Position Of(Event Player)) > Global.MinPioneerDistanceConstant;
		Event Player.CurrentCP == 0;
		"Make sure level hasn't already been created"
		Count Of(Global.CPLocations[Global.IndexLevelCreateMenu]) < 2;
		Is On Ground(Event Player) == True;
		Is In Spawn Room(Event Player) != True;
		Event Player.LevelCreationEnabled == True;
		Has Spawned(Event Player) == True;
		"Not in free roam mode"
		Global.IndexLevelCreateMenu > 0;
	}

	actions
	{
		Event Player.CancelPointTimer = 3;
		Wait(0.100, Abort When False);
		Big Message(Event Player, Custom String("Press R within 3 sec to cancel point!"));
		Chase Player Variable At Rate(Event Player, CancelPointTimer, 0, 1, Destination and Rate);
		While(Event Player.CancelPointTimer > 0);
			Wait(0.033, Ignore Condition);
			Call Subroutine(CancelMomentum);
			If(Is Button Held(Event Player, Reload));
				Call Subroutine(RespawnPlayer);
				Abort;
			End;
		End;
		Abort If Condition Is False;
		Small Message(All Players(All Teams), Custom String("Created {0}", Global.LevelDescriptions[Event Player.CurrentLevel]));
		Event Player.CurrentLevel = Global.IndexLevelCreateMenu;
		Modify Global Variable At Index(CPLocations, Event Player.CurrentLevel, Append To Array, Position Of(Event Player));
		"Create level entry ring - visible to all players on Level 0 (level selection part)."
		Create Effect(Filtered Array(All Players(All Teams), True && Current Array Element.CurrentCP < 1), Ring, Purple,
			Global.CPLocations[Event Player.CurrentLevel][1], Global.CPRadius, Visible To);
		Create In-World Text(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0), Custom String("{0}",
			Global.LevelDescriptions[Global.IndexLevelCreateMenu]), Global.CPLocations[Event Player.CurrentLevel][1], 2, Do Not Clip,
			Visible To, Purple, Default Visibility);
		Create Icon(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0),
			Global.CPLocations[Event Player.CurrentLevel][1], Flag, Visible To, Yellow, True);
		Call Subroutine(RespawnPlayer);
	}
}

rule("Enter Into Level - Runs continuously on Checkpoint 0 [POSSIBLE TO MAKE NOT CONTINUOUS LOOP]")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.CurrentCP == 0;
		Is On Ground(Event Player) == True;
		"Redundant"
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		For Player Variable(Event Player, EnterIntoLevelIterator, 1, Count Of(Global.CPLocations), 1);
			If(Count Of(Global.CPLocations[Event Player.EnterIntoLevelIterator]) > 1);
				If(Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.EnterIntoLevelIterator][1]) < Global.CPRadius);
					Event Player.CurrentCP = 1;
					Event Player.CurrentLevel = Event Player.EnterIntoLevelIterator;
					Event Player.TotalTimeSpentOnLastCP = 0;
					"If no pioneer for the current level and player is on last checkpoint of the level, set them as pioneer"
					If(Count Of(Global.CurrentPioneer[Event Player.CurrentLevel]) == 1 && True);
						Big Message(Event Player, Custom String("You Are Pioneer! Use your skills to create the next point!"));
						Modify Global Variable At Index(CurrentPioneer, Event Player.CurrentLevel, Append To Array, Event Player);
					End;
					Call Subroutine(RespawnPlayer);
					Abort;
				End;
			End;
		End;
		Wait(0.033, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Melee to Select Level in Level Creation Menu If On Checkpoint 0")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.CurrentCP == 0;
		Event Player.LevelCreationEnabled == True;
		Global.GameStarted == True;
		Is Button Held(Event Player, Melee) == True;
	}

	actions
	{
		Global.IndexLevelCreateMenu = (Global.IndexLevelCreateMenu + 1) % (Count Of(Global.LevelDescriptions) - 0) + 0;
		Call Subroutine(MakeMenuText);
	}
}

disabled rule("Doom Parkour Pioneer Architecture - Individual Level")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Touch Ground = Respawn")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
		"Is not Pioneer"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		"Is not at the current checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 0])
			> Global.CPRadius;
		"Is not at the next checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1])
			> Global.CPRadius;
		"Origin Point Exists"
		Global.GameStarted == True;
		"Give Doomfist ability to get a jump after using Seismic Slam"
		disabled (Hero Of(Event Player) == Hero(Doomfist) && Is Using Ability 2(Event Player)) == False;
		"Baptiste doesn't die when in Immortality Field "
		(Hero Of(Event Player) == Hero(Baptiste) && (Has Status(Event Player, Knocked Down) || Has Status(Event Player, Unkillable)))
			== False;
		"Ignore This On CP 0"
		Event Player.CurrentCP > 0;
	}

	actions
	{
		"Added this if statement to stop this rule from conflicting with the \"Create New Level\" rule."
		disabled If(Event Player.CurrentCP == 0 && Event Player.LevelCreationEnabled);
		disabled Wait(0.100, Ignore Condition);
		disabled Abort If(Event Player.CancelPointTimer > 0);
		disabled End;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Pioneer - Create New Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
		"Inside a level, not in multilevel portion"
		Event Player.CurrentCP > 0;
		"Redundant, but putting this here just to be safe"
		Event Player.CurrentLevel > 0;
		Distance Between(Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP], Position Of(Event Player))
			> Global.MinPioneerDistanceConstant;
		"Doesn't always work, as there are locations that are inaccessable for a certain team but not in spawn room"
		Is In Spawn Room(Event Player) != True;
		"event player = pioneer for this level / CP"
		Event Player == Last Of(Global.CurrentPioneer[Event Player.CurrentLevel]);
		"Is on last checkpoint of the level"
		Event Player.CurrentCP + 1 == Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		"Baptiste doesn't die when in Immortality Field "
		(Hero Of(Event Player) == Hero(Baptiste) && (Has Status(Event Player, Knocked Down) || Has Status(Event Player, Unkillable)))
			== False;
		Has Spawned(Event Player) == True;
		Event Player.IsPioneer == True;
		"Give Doomfist ability to get a jump after using Seismic Slam"
		disabled (Hero Of(Event Player) == Hero(Doomfist) && Is Using Ability 2(Event Player)) == False;
	}

	actions
	{
		Event Player.W = Position Of(Event Player);
		Call Subroutine(CancelMomentum);
		Set Status(Event Player, Null, Rooted, 1);
		"Stops this rule from executing out of order with the player respawn when dead rule. This stops player from pioneering in spawn by jumping off map."
		Wait(0.250, Abort When False);
		Event Player.CancelPointTimer = 3;
		Chase Player Variable At Rate(Event Player, CancelPointTimer, 0, 1, Destination and Rate);
		Big Message(Event Player, Custom String("Press R within 3 sec to cancel point!"));
		Clear Status(Event Player, Rooted);
		While(Event Player.CancelPointTimer > 0);
			Wait(0.033, Ignore Condition);
			Call Subroutine(CancelMomentum);
			If(Is Button Held(Event Player, Reload));
				Call Subroutine(RespawnPlayer);
				Abort;
			End;
		End;
		"Abort if player is in spawn room - this can happen if they die within 3 sec after making a point"
		Abort If(Is In Spawn Room(Event Player));
		Small Message(Event Player, Custom String("Created Point! {0}", Event Player.PunchUpperSlamUsed));
		Modify Global Variable At Index(CountPunchUpperSlam, Event Player.CurrentLevel, Append To Array, Event Player.PunchUpperSlamUsed);
		Modify Global Variable At Index(CountMeteorTeleportPrimary, Event Player.CurrentLevel, Append To Array,
			Event Player.CountUltimateTeleportPrimary);
		Modify Global Variable At Index(HeroUseArrayofArrays, Event Player.CurrentLevel, Append To Array, Hero Of(Event Player));
		Modify Global Variable At Index(CPLocations, Event Player.CurrentLevel, Append To Array, Event Player.W);
		Event Player.TotalTimeSpentOnLastCP = 0;
		"Respawn other players"
		Filtered Array(All Players(All Teams),
			Current Array Element.CurrentLevel == Event Player.CurrentLevel && Current Array Element.CurrentCP == Event Player.CurrentCP)
			.ForceRespawn = True;
	}
}

rule("Pioneered less than distance threshold")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
		"Inside a level, not in multilevel portion"
		Event Player.CurrentCP > 0;
		Distance Between(Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP], Position Of(Event Player))
			< Global.MinPioneerDistanceConstant;
		Distance Between(Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP], Position Of(Event Player))
			> Global.CPRadius;
		"event player = pioneer for this level / CP"
		Event Player == Last Of(Global.CurrentPioneer[Event Player.CurrentLevel]);
		"Is on last checkpoint of the level"
		Event Player.CurrentCP + 1 == Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		"Give Doomfist ability to get a jump after using Seismic Slam"
		disabled (Hero Of(Event Player) == Hero(Doomfist) && Is Using Ability 2(Event Player)) == False;
		"Baptiste doesn't die when in Immortality Field "
		(Hero Of(Event Player) == Hero(Baptiste) && (Has Status(Event Player, Knocked Down) || Has Status(Event Player, Unkillable)))
			== False;
		Event Player.IsPioneer == True;
	}

	actions
	{
		Small Message(Event Player, Custom String("Need to pioneer further than {0}m", Global.MinPioneerDistanceConstant));
		Call Subroutine(RespawnPlayer);
	}
}

rule("Non-Pioneer Player Arrive At Point (Set Them As Next Pioneer If Applicable)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Inside a level, not in multilevel portion, make this trigger on checkpoints 1+ to stop conflict with Enter Into Level rule"
		Event Player.CurrentCP > 0;
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		Is On Ground(Event Player) == True;
		"Is at the next checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1])
			< Global.CPRadius;
		"Give Doomfist ability to get a jump after using Seismic Slam"
		disabled (Hero Of(Event Player) == Hero(Doomfist) && Is Using Ability 2(Event Player)) == False;
		"Baptiste doesn't die when in Immortality Field "
		(Hero Of(Event Player) == Hero(Baptiste) && (Has Status(Event Player, Knocked Down) || Has Status(Event Player, Unkillable)))
			== False;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Wait(0.200, Abort When False);
		Small Message(Event Player, Custom String("Arrived!"));
		Event Player.CurrentCP += 1;
		Event Player.LevelMaxUnlockedCPArray[Event Player.CurrentLevel] = Max(
			Event Player.LevelMaxUnlockedCPArray[Event Player.CurrentLevel], Event Player.CurrentCP);
		"If no pioneer for the current level and player is on last checkpoint of the level, set them as pioneer"
		If(Count Of(Global.CurrentPioneer[Event Player.CurrentLevel]) == Event Player.CurrentCP + 0);
			If(Global.SinglePlayerModeEnabled || Event Player != Global.CurrentPioneer[Event Player.CurrentLevel][Event Player.CurrentCP - 1]);
				Modify Global Variable At Index(CurrentPioneer, Event Player.CurrentLevel, Append To Array, Event Player);
				Big Message(Event Player, Custom String("You Are Pioneer! Use your skills to create the next point!"));
			End;
		End;
		Call Subroutine(RespawnPlayer);
		Event Player.TotalTimeSpentOnLastCP = 0;
	}
}

rule("Set IsPioneer, Set Pioneer Invisible")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Inside a level, not in multilevel portion"
		Event Player.CurrentCP > 0;
		"Redundant, but putting this here just to be safe"
		Event Player.CurrentLevel > 0;
		"event player = pioneer for this level / CP"
		Event Player == Last Of(Global.CurrentPioneer[Event Player.CurrentLevel]);
		"Is on last checkpoint of the level"
		Event Player.CurrentCP + 1 == Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		Count Of(Global.CPLocations[Event Player.CurrentLevel]) == Count Of(Global.CurrentPioneer[Event Player.CurrentLevel]);
	}

	actions
	{
		Set Invisible(Event Player, All);
		Event Player.IsPioneer = True;
	}
}

rule("Non-Pioneer Is Visible (not invisible)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Inside a level, not in multilevel portion"
		(Event Player.CurrentCP > 0 && Count Of(Global.CPLocations[Event Player.CurrentLevel]) == Count Of(
			Global.CurrentPioneer[Event Player.CurrentLevel]) && True && Event Player == Last Of(
			Global.CurrentPioneer[Event Player.CurrentLevel]) && Event Player.CurrentCP + 1 == Count Of(
			Global.CPLocations[Event Player.CurrentLevel])) == False;
	}

	actions
	{
		Set Invisible(Event Player, None);
		Event Player.IsPioneer = False;
	}
}

rule("Pioneer Runs Out of Time On Making Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.IsPioneer == True;
		Event Player.TotalTimeSpentOnLastCP > Global.PioneerTimeLimitConstant;
	}

	actions
	{
		"Prevent conflict between this rule and Arrive At Point rule setting next pioneer"
		Wait(1, Abort When False);
		"Give player extra 3 seconds to pioneer if they make point in last 3 seconds of pioneer time"
		If(Event Player.CancelPointTimer > 0);
			Wait(3.100, Ignore Condition);
			Abort If Condition Is False;
		End;
		"get all other players on the same point"
		Event Player.I = Filtered Array(All Players(All Teams),
			Event Player.CurrentCP == Current Array Element.CurrentCP && Event Player.CurrentLevel == Current Array Element.CurrentLevel && Event Player != Current Array Element && True);
		"If there is a player to pass pioneer to"
		If(Count Of(Event Player.I) > 0);
			"Force players to respawn"
			Event Player.I.ForceRespawn = True;
			Wait(0.250, Ignore Condition);
			Big Message(Event Player, Custom String("ran out of time on pioneer"));
			Modify Global Variable At Index(CurrentPioneer, Event Player.CurrentLevel, Remove From Array By Index, Event Player.CurrentCP);
			Modify Global Variable At Index(CurrentPioneer, Event Player.CurrentLevel, Append To Array, Random Value In Array(Event Player.I));
			Big Message(Event Player.I, Custom String("Level {0} Pioneer passed to {1}!", Event Player.CurrentLevel, Last Of(
				Global.CurrentPioneer[Event Player.CurrentLevel])));
		Else;
			disabled Modify Global Variable At Index(CurrentPioneer, Event Player.CurrentLevel, Remove From Array By Index, Event Player.CurrentCP);
			Big Message(Event Player, Custom String("No one else to pass pioneer to"));
		End;
		Event Player.I.TotalTimeSpentOnLastCP = 0;
		Event Player.TotalTimeSpentOnLastCP = 0;
	}
}

rule("Handle ForceRespawn")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.ForceRespawn == True;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
		Event Player.ForceRespawn = False;
		Event Player.TotalTimeSpentOnLastCP = 0;
	}
}

rule("Handle Player Death")
{
	event
	{
		Player Died;
		All;
		All;
	}

	conditions
	{
		Event Player.SpectateMode != True;
	}

	actions
	{
		"To fix bug where pioneer jumps off map and tele's back to spawn"
		Wait(0.050, Abort When False);
		Respawn(Event Player);
		If(Global.GameStarted);
			Wait(0.100, Ignore Condition);
			Call Subroutine(RespawnPlayer);
		End;
		Wait(0.100, Ignore Condition);
		Clear Status(Event Player, Phased Out);
		Set Status(Event Player, Null, Phased Out, 9999);
	}
}

rule("Used Ability 1 (Uppercut)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Up;
	}
}

rule("Used Ability 2 (Seismic Slam)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		"Fix issue where slam counter can incorrectly count when you slam but are not facing valid direction to slam in"
		Wait(0.250, Abort When False);
		Event Player.PunchUpperSlamUsed += Forward;
	}
}

rule("Used Ultimate")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Event Player.CountUltimateTeleportPrimary += Left;
		"Add 4 sec to timer if using meteor strike on LVL 1"
		If(Event Player.CheckpointTimer > 0);
			Event Player.CheckpointTimer += 5;
		End;
	}
}

rule("Used Secondary (Rocket Punch)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Left;
	}
}

rule("Used Primary Fire On Hero Where Primary Is Relevant (Ana, etc.)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
		Index Of Array Value(Global.PrimaryFireUsefulForTheseHeros, Hero Of(Event Player)) >= 0;
	}

	actions
	{
		Event Player.CountUltimateTeleportPrimary += Forward;
	}
}

rule("Pioneer Leaves Match")
{
	event
	{
		Player Left Match;
		All;
		All;
	}

	conditions
	{
		Index Of Array Value(All Players(All Teams), Event Player) == -1;
	}

	actions
	{
		For Global Variable(TempPlayerLeftIterator, 0, Count Of(Global.CPLocations), 1);
			If(Count Of(Global.CurrentPioneer[Global.TempPlayerLeftIterator]) == Count Of(Global.CPLocations[Global.TempPlayerLeftIterator])
				&& Count Of(Global.CPLocations[Global.TempPlayerLeftIterator]) > 1 && Event Player == Last Of(
				Global.CurrentPioneer[Global.TempPlayerLeftIterator]));
				"get all other players on the same point"
				Event Player.I = Filtered Array(All Players(All Teams), Count Of(Global.CPLocations[Global.TempPlayerLeftIterator])
					- 1 == Current Array Element.CurrentCP && Global.TempPlayerLeftIterator == Current Array Element.CurrentCP && True && True);
				"Remove player as pioneer"
				Modify Global Variable At Index(CurrentPioneer, Global.TempPlayerLeftIterator, Remove From Array By Index, Count Of(
					Global.CPLocations[Global.TempPlayerLeftIterator]) - 1);
				"If there is a player to pass pioneer to"
				If(Count Of(Event Player.I) > 0);
					Event Player.I.TotalTimeSpentOnLastCP = 0;
					Event Player.TotalTimeSpentOnLastCP = 0;
					Modify Global Variable At Index(CurrentPioneer, Event Player.CurrentLevel, Append To Array, Random Value In Array(Event Player.I));
					Big Message(Event Player.I, Custom String("Level {0} Pioneer passed to {1}!", Event Player.CurrentLevel, Last Of(
						Global.CurrentPioneer[Event Player.CurrentLevel])));
				End;
			End;
		End;
	}
}

disabled rule("Additional Features (and Key Bindings)")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Quick Reset - Reload")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Reload) == True;
		Is On Ground(Event Player) != True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
		"So player can't R and get teleported outside map before origin point is selected"
		Global.GameStarted == True;
		"Quick Reset Disabled for Ana, so you can reload - modify the array here for additional disable"
		Index Of Array Value(Global.PrimaryFireUsefulForTheseHeros, Hero Of(Event Player)) < 0;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Move Back A Checkpoint Or Hold for 3 Sec to Go To Checkpoint 0 - Jump + Interact")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Jump) == True;
		Is Button Held(Event Player, Interact) == True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.JumpInteractTimer = 2;
		Chase Player Variable At Rate(Event Player, JumpInteractTimer, 0, 1, Destination and Rate);
		"Loop while jump + interact are held, timer < 3 sec, player is not pioneering a point"
		While(Event Player.JumpInteractTimer > 0 && Is Button Held(Event Player, Interact) && Is Button Held(Event Player, Jump)
			&& Event Player.CancelPointTimer == 0);
			Wait(0.016, Ignore Condition);
		End;
		"Move back 1 checkpoint"
		If(Event Player.JumpInteractTimer > 0);
			If(Event Player.CurrentCP > 0);
				Event Player.CurrentCP += -1;
			Else;
				"If on Checkpoint 0, go to greatest unlocked checkpoint on level"
				Event Player.CurrentCP = Event Player.LevelMaxUnlockedCPArray[Event Player.CurrentLevel];
			End;
		Else;
			"Move back to Origin Point"
			Event Player.CurrentCP = 0;
		End;
		Stop Holding Button(Event Player, Jump);
		Stop Holding Button(Event Player, Interact);
		"Reset time spent on checkpoint"
		Event Player.TotalTimeSpentOnLastCP = 0;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Ultimate Status Voiceline: Camera To See Next Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating(Event Player, Ultimate Status) == True;
		"Make sure next point exists"
		Count Of(Global.CPLocations[Event Player.CurrentLevel]) > Event Player.CurrentCP + 1;
	}

	actions
	{
		Event Player.I = Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1];
		Start Camera(Event Player, Ray Cast Hit Position(Event Player.I, Event Player.I + Vector(10, 10, 0), All Players(All Teams),
			Event Player, True), Event Player.I + Facing Direction Of(Event Player) * 10, 30);
		Wait(3, Ignore Condition);
		Stop Camera(Event Player);
	}
}

rule("Need Healing Voiceline: Spectate Other Players")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating(Event Player, Need Healing) == True;
	}

	actions
	{
		Enable Death Spectate All Players(All Players(All Teams));
		If(Is Dead(Event Player));
			Enable Built-In Game Mode Respawning(Event Player);
			Resurrect(Event Player);
			Wait(0.100, Ignore Condition);
			Call Subroutine(RespawnPlayer);
			Event Player.SpectateMode = False;
		Else;
			Big Message(Event Player, Custom String("Use \"Need Healing\" voiceline to exit Spectate Mode!"));
			Event Player.SpectateMode = True;
			Disable Built-In Game Mode Respawning(Event Player);
			Kill(Event Player, Null);
		End;
		Set Status(Event Player, Null, Phased Out, 9999);
	}
}

rule("Melee + Left Click = Teleport")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Primary Fire) == True;
		Is Button Held(Event Player, Melee) == True;
		Event Player.TeleportEnabled == True;
	}

	actions
	{
		Teleport(Event Player, Ray Cast Hit Position(Position Of(Event Player), Position Of(Event Player) + Facing Direction Of(
			Event Player) * 60, All Players(All Teams), Event Player, True));
		Event Player.CountUltimateTeleportPrimary += Up;
	}
}

rule("Skip Level Option Message - Only available if you spent 5 min on a point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.CurrentCP > 0;
		"Make sure next point exists"
		Count Of(Global.CPLocations[Event Player.CurrentLevel]) > Event Player.CurrentCP + 1;
		Event Player.TotalTimeSpentOnLastCP > 300;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Big Message(Event Player, Custom String("Spent more than 5 min on point. Melee + Interact to skip to next checkpoint."));
	}
}

rule("Skip Level Option Implementation - Only available if you spent 5 min on a point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.CurrentCP > 0;
		"Make sure next point exists"
		Count Of(Global.CPLocations[Event Player.CurrentLevel]) > Event Player.CurrentCP + 1;
		Event Player.TotalTimeSpentOnLastCP > 300;
		Is Button Held(Event Player, Melee) == True;
		Is Button Held(Event Player, Interact) == True;
	}

	actions
	{
		Small Message(Event Player, Custom String("Skipped to next level!"));
		Event Player.CurrentCP += 1;
		Event Player.LevelMaxUnlockedCPArray[Event Player.CurrentLevel] = Max(
			Event Player.LevelMaxUnlockedCPArray[Event Player.CurrentLevel], Event Player.CurrentCP);
		"If no pioneer for the current level and player is on last checkpoint of the level, set them as pioneer"
		If(Count Of(Global.CurrentPioneer[Event Player.CurrentLevel]) == Event Player.CurrentCP + 0);
			If(Global.SinglePlayerModeEnabled || Event Player != Global.CurrentPioneer[Event Player.CurrentLevel][Event Player.CurrentCP - 1]);
				Modify Global Variable At Index(CurrentPioneer, Event Player.CurrentLevel, Append To Array, Event Player);
				Big Message(Event Player, Custom String("You Are Pioneer! Use your skills to create the next point!"));
			End;
		End;
		Call Subroutine(RespawnPlayer);
		Event Player.TotalTimeSpentOnLastCP = 0;
	}
}

rule("Single Player Mode Engaged If Only 1 Player in Game")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(All Players(All Teams)) <= 1;
	}

	actions
	{
		Global.SinglePlayerModeEnabled = True;
		Small Message(Host Player, Custom String("Single Player Mode Engaged"));
	}
}

rule("Single Player Mode Disengaged If Multiple Players in Game")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(All Players(All Teams)) > 1;
	}

	actions
	{
		Global.SinglePlayerModeEnabled = False;
		Small Message(Host Player, Custom String("Single Player Mode Disengaged"));
	}
}

disabled rule("Subroutines")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Sub0: RespawnPlayer")
{
	event
	{
		Subroutine;
		RespawnPlayer;
	}

	actions
	{
		Stop Holding Button(Event Player, Secondary Fire);
		Stop Holding Button(Event Player, Ability 1);
		Teleport(Event Player, Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP]);
		Set Facing(Event Player, Direction Towards(Position Of(Event Player),
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1]), To World);
		"Sigma Barrier Reset"
		If(Hero Of(Event Player) == Hero(Sigma));
			If(Event Player.sigma_barrier_ready_to_destroy);
				Press Button(Event Player, Secondary Fire);
			End;
			Event Player.sigma_barrier_ON = False;
			Event Player.sigma_barrier_ready_to_destroy = False;
		End;
		Event Player.CheckpointTimer = 0;
		Stop Chasing Player Variable(Event Player, CheckpointTimer);
		Cancel Primary Action(Event Player);
		Call Subroutine(CancelMomentum);
		"Added this to fix issue where if you pressed R while using slam, the slam cooldown wasn't reset"
		Wait(0.100, Ignore Condition);
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Set Ultimate Charge(Event Player, 100);
		Event Player.CancelPointTimer = 0;
		Event Player.PunchUpperSlamUsed = Vector(0, 0, 0);
		Event Player.CountUltimateTeleportPrimary = Vector(0, 0, 0);
		"If player is on point that has already been created (ie. player is not pioneer, player is not waiting for pioneer, etc.)"
		If(Count Of(Global.CPLocations[Event Player.CurrentLevel]) > Event Player.CurrentCP + 1);
			If(X Component Of(Global.CountPunchUpperSlam[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
				Set Secondary Fire Enabled(Event Player, False);
			Else;
				Set Secondary Fire Enabled(Event Player, True);
			End;
			If(Y Component Of(Global.CountPunchUpperSlam[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
				Set Ability 1 Enabled(Event Player, False);
			Else;
				Set Ability 1 Enabled(Event Player, True);
			End;
			If(Z Component Of(Global.CountPunchUpperSlam[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
				Set Ability 2 Enabled(Event Player, False);
			Else;
				Set Ability 2 Enabled(Event Player, True);
			End;
			If(X Component Of(Global.CountMeteorTeleportPrimary[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
				Set Ultimate Ability Enabled(Event Player, False);
			Else;
				Set Ultimate Ability Enabled(Event Player, True);
			End;
			If(Y Component Of(Global.CountMeteorTeleportPrimary[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
				Event Player.TeleportEnabled = False;
			Else;
				Event Player.TeleportEnabled = True;
				If(Event Player.CurrentCP > 0);
					Big Message(Event Player, Custom String("Teleport enabled for this point! Use Left Click + Melee to teleport!"));
				End;
			End;
			If(Index Of Array Value(Global.PrimaryFireUsefulForTheseHeros, Hero Of(Event Player)) >= 0);
				If(Z Component Of(Global.CountMeteorTeleportPrimary[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
					Set Primary Fire Enabled(Event Player, False);
				Else;
					Set Primary Fire Enabled(Event Player, True);
				End;
			End;
		"Is beginning of match, or player is pioneer, or player is waiting for pioneer"
		Else;
			Set Secondary Fire Enabled(Event Player, True);
			Set Ability 1 Enabled(Event Player, True);
			Set Ability 2 Enabled(Event Player, True);
			Event Player.TeleportEnabled = True;
			Set Ultimate Ability Enabled(Event Player, True);
			Set Primary Fire Enabled(Event Player, True);
		End;
		Event Player.WinstonBouncyBubbleCooldown = 0;
		Destroy Effect(Event Player.WinstonBubbleEffect);
		Event Player.WinstonBubbleLocation = Null;
		disabled Cancel Primary Action(Event Player);
		Start Forcing Player To Be Hero(Event Player, Global.HeroUseArrayofArrays[Event Player.CurrentLevel][Event Player.CurrentCP]);
		"Should Fix Phased Out Status issue"
		Clear Status(Event Player, Phased Out);
		Set Status(Event Player, Null, Phased Out, 9999);
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
	}
}

rule("Sub1: MakeMenuText - Make Text For Level Creation Type Menu")
{
	event
	{
		Subroutine;
		MakeMenuText;
	}

	actions
	{
		For Player Variable(Event Player, Y, 0, Count Of(Global.LevelDescriptions), 1);
			If(Event Player.Y == Global.IndexLevelCreateMenu);
				If(Event Player.Y == 0);
					Global.TextLevelCreateMenu = Custom String("Melee = Next Selection\r\n{0} {1} {2}", Icon String(Arrow: Right),
						Global.LevelDescriptions[0], Icon String(Arrow: Left));
				Else;
					Global.TextLevelCreateMenu = Custom String("{0}\r\n{1}", Global.TextLevelCreateMenu, Custom String("{0} {1} {2}", Icon String(
						Arrow: Right), Global.LevelDescriptions[Event Player.Y], Icon String(Arrow: Left)));
				End;
			Else;
				If(Event Player.Y == 0);
					Global.TextLevelCreateMenu = Custom String("Melee = Next Selection\r\n{1}", Null, Global.LevelDescriptions[0]);
				Else;
					Global.TextLevelCreateMenu = Custom String("{0}\r\n{1}", Global.TextLevelCreateMenu, Custom String("{1}", Null,
						Global.LevelDescriptions[Event Player.Y]));
				End;
			End;
		End;
	}
}

rule("Sub2: CancelMomentum")
{
	event
	{
		Subroutine;
		CancelMomentum;
	}

	actions
	{
		Apply Impulse(Event Player, Up, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Down, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Left, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Right, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Forward, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Backward, 0.001, To World, Cancel Contrary Motion);
	}
}

disabled rule("Level Modifiers")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Level 1 Modifer - Only Have 5 Seconds To Make Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.CurrentLevel == 1;
		Event Player.CurrentCP > 0;
		"Player Has Left Point"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP])
			> Global.CPRadius;
		"For Pioneer Only"
		Event Player.IsPioneer == True;
	}

	actions
	{
		Event Player.CheckpointTimer = 5;
		Chase Player Variable At Rate(Event Player, CheckpointTimer, 0, 1, Destination and Rate);
		While(Event Player.CheckpointTimer > 0);
			Wait(0.100, Ignore Condition);
		End;
		Abort If Condition Is False;
		Abort If(Event Player.CancelPointTimer > 0);
		Small Message(Event Player, Custom String("Level 1 Restriction: Complete Point In 5 Seconds!"));
		Call Subroutine(RespawnPlayer);
	}
}

rule("Level 3 Modifier: Ability Counts")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.CurrentLevel == 3;
		(Is Using Ability 1(Event Player) || Is Using Ability 2(Event Player) || Is Firing Secondary(Event Player)) == True;
		"Inside a level, not in multilevel portion"
		Event Player.CurrentCP > 0;
		"Is NOT on last checkpoint of the level"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
	}

	actions
	{
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
		If(Y Component Of(Event Player.PunchUpperSlamUsed) >= Y Component Of(
			Global.CountPunchUpperSlam[Event Player.CurrentLevel][Event Player.CurrentCP]));
			Set Ability 1 Enabled(Event Player, False);
		End;
		If(Z Component Of(Event Player.PunchUpperSlamUsed) >= Z Component Of(
			Global.CountPunchUpperSlam[Event Player.CurrentLevel][Event Player.CurrentCP]));
			Set Ability 2 Enabled(Event Player, False);
		End;
		If(X Component Of(Event Player.PunchUpperSlamUsed) >= X Component Of(
			Global.CountPunchUpperSlam[Event Player.CurrentLevel][Event Player.CurrentCP]));
			"Have to wait to disable punch because otherwise it would disable immediately after using preventing punch from working properly."
			Wait(0.400, Ignore Condition);
			"This is to fix interaction with the Quick Reset (R) right after using punch, so this doesn't disable punch after you respawn. Can have slight bug where player is punching through the start location, and doesn't set cooldown properly."
			Abort If(True && Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP])
				< Global.CPRadius);
			Set Secondary Fire Enabled(Event Player, False);
		End;
	}
}

rule("Level 4 (Multi-Hero Level): Switch Hero When Player Emotes")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating Any Emote(Event Player) == True;
		(Event Player.CurrentCP + 1 == Count Of(Global.CPLocations[Event Player.CurrentLevel]) && True) == True;
		Event Player.CurrentLevel == 4;
		"So player cannot switch hero while in 3 sec reset after making point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		"To prevent conflict between this and Pioneering New Point Rule if emoting in 3 sec reset window"
		Wait(0.250, Abort When False);
		Start Forcing Player To Be Hero(Event Player, Global.HeroList[(Index Of Array Value(Global.HeroList, Hero Of(Event Player)) + 1)
			% Count Of(Global.HeroList)]);
		Set Ultimate Charge(Event Player, 100);
		Event Player.PunchUpperSlamUsed = Vector(0, 0, 0);
	}
}

rule("Level 4 Reminder to See Hero Modifiers on Left HUD")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.CurrentLevel == 4;
	}

	actions
	{
		Big Message(Event Player, Custom String("{0} See Hero Modifiers on the Left", Icon String(Arrow: Left)));
	}
}

rule("Level 5: Sigma Parkour Modifier")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.CurrentLevel == 5;
		Event Player.CurrentCP > 0;
	}

	actions
	{
		Event Player.sigma_barrier_ON = False;
		Wait(0.016, Ignore Condition);
		Start Forcing Player To Be Hero(Event Player, Hero(Sigma));
	}
}

disabled rule("Doomfist Modifiers")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Meteor Strike Movement Slow")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Set Move Speed(Event Player, 50);
	}
}

rule("Set Movement Speed Normal When Not Using Meteor Strike")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		Set Move Speed(Event Player, 100);
	}
}

disabled rule("ROADHOG STUFF")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Change Hook to Grappling Hook")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		"Initial impulse to let you hook in midair without falling too far while hook is out"
		Apply Impulse(Event Player, Up, 3, To World, Cancel Contrary Motion);
		"Issue here is that we are using ray cast to determine hook impact, which isn't visually accurate, so the hook may impact a wall but not be deteted."
		Event Player.Y = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 120 * Facing Direction Of(
			Event Player), All Players(All Teams), Event Player, True);
		"Abort if hook didn't connect with a wall within 25m. For reference, 20m is hook range for normal roadhog."
		If(Distance Between(Position Of(Event Player), Event Player.Y) > 25);
			Small Message(Event Player, Custom String("Out of hook range!"));
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
			Abort;
		End;
		"Wait for hook to \"hit\" something. Hook moves at 40m/s"
		Wait(Distance Between(Position Of(Event Player), Event Player.Y) / 40, Ignore Condition);
		"Impulse that increases with hook range. Hook impulse = Base Impulse + Hook Range x Range Multiplier."
		Apply Impulse(Event Player, Direction Towards(Position Of(Event Player), Event Player.Y), 20 + Distance Between(Event Player.Y,
			Position Of(Event Player)) * 0.800, To World, Cancel Contrary Motion);
		"Large Linear Impulse. Disabled while testing impulse that increases with range."
		disabled Apply Impulse(Event Player, Direction Towards(Position Of(Event Player), Event Player.Y), 40, To World, Cancel Contrary Motion);
	}
}

rule("Change Take A Breather to Bouncy Ball Hog")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		disabled Is On Ground(Event Player) == True;
		Altitude Of(Event Player) <= 1.500;
	}

	actions
	{
		Apply Impulse(Event Player, Up, Speed Of(Event Player) * 1.200, To World, Cancel Contrary Motion);
	}
}

rule("Add Knockback When Secondary Fire Used")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Apply Impulse(Event Player, Facing Direction Of(Event Player), -12, To World, Cancel Contrary Motion);
	}
}

rule("Roadhog Ultimate")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Small Message(Event Player, Custom String("Hold Melee to Cancel Ultimate"));
		While(Is Using Ultimate(Event Player) && !Is Button Held(Event Player, Melee));
			Wait(0.066, Ignore Condition);
			"Cause knockback on player"
			disabled Apply Impulse(Event Player, Facing Direction Of(Event Player), -10, To World, Cancel Contrary Motion);
			"Player Knockback"
			Apply Impulse(Event Player, Facing Direction Of(Event Player), -1.500, To World, Cancel Contrary Motion);
			"\"Drill\" Through Walls, Skyboxes, etc."
			Teleport(Event Player, Position Of(Event Player) + Facing Direction Of(Event Player) * -1.500);
		End;
		"For melee cancel on ult"
		Cancel Primary Action(Event Player);
	}
}

rule("Limit Roadhog Ultimate Duration")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		"Set Ult Duration to 4 sec, then cancel it"
		Wait(3, Ignore Condition);
		Cancel Primary Action(Event Player);
	}
}

disabled rule("WINSTON STUFF")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Initialize Winston")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	actions
	{
		Event Player.WinstonBubbleLocation = Null;
	}
}

rule("Create Bubble")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		"Place Bubble on ground below player. Easier for new players to figure out what's going on (compared to Ray Cast bubble position)."
		Event Player.WinstonBubbleLocation = Position Of(Event Player) + World Vector Of(Forward, Event Player, Rotation)
			* Horizontal Speed Of(Event Player) * 0.300 + Down * Altitude Of(Event Player);
		"Use Ray Cast to determine bubble position"
		disabled Event Player.WinstonBubbleLocation = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 160, All Players(All Teams), Event Player, False);
		If(Distance Between(Event Player.WinstonBubbleLocation, Position Of(Event Player)) > 100);
			Small Message(Event Player, Custom String("Barrier Cast Out Of Range (100m)"));
			Set Ability Cooldown(Event Player, Button(Ability 2), 0);
			Abort;
		End;
		Create Effect(Event Player, Sphere, Blue, Event Player.WinstonBubbleLocation, 5, Visible To Position and Radius);
		Event Player.WinstonBubbleEffect = Last Created Entity;
		Event Player.WinstonBouncyBubbleCooldown = 9;
		Chase Player Variable At Rate(Event Player, WinstonBouncyBubbleCooldown, 0, 1, Destination and Rate);
		While(Event Player.WinstonBouncyBubbleCooldown > 0 && !Is Dead(Event Player));
			Wait(0.100, Ignore Condition);
		End;
		Destroy Effect(Event Player.WinstonBubbleEffect);
		Event Player.WinstonBubbleLocation = Null;
	}
}

rule("Winston Bubble Physics Rule")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Event Player.WinstonBubbleLocation != Null;
		Distance Between(Position Of(Event Player), Event Player.WinstonBubbleLocation) <= 5;
	}

	actions
	{
		"Direct Impulse - Cancel's Player Motion, so physically inaccurate bounce"
		Apply Impulse(Event Player, Direction Towards(Event Player.WinstonBubbleLocation, Position Of(Event Player)), Speed Of(
			Event Player) * 1.300, To World, Cancel Contrary Motion);
	}
}

rule("Winston Wall Climb")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Button Held(Event Player, Jump) == True;
		"Make this so a player can't use wall climb multiple times in a row."
		Event Player.WinstonWallClimbEnabled == True;
	}

	actions
	{
		Event Player.AnaSleepDartTeleLocation = 4;
		"Set Wall Climb to have a max of 4 sec duration. This prevents you from wall climing against a roof/skybox for indefinite stall."
		Chase Player Variable Over Time(Event Player, AnaSleepDartTeleLocation, 0, 4, Destination and Duration);
		"Wall Climb while Jump is held, have been wall climbing less than 4 sec, are within 0.5m of wall"
		While(Is Button Held(Event Player, Jump) && Event Player.AnaSleepDartTeleLocation > 0 && Distance Between(Ray Cast Hit Position(
			Eye Position(Event Player), Eye Position(Event Player) + Direction From Angles(Horizontal Angle From Direction(
			Facing Direction Of(Event Player)), 0) * 10, All Players(All Teams), Event Player, True), Eye Position(Event Player)) < 3);
			Wait(0.033, Ignore Condition);
			Set Move Speed(Event Player, 0);
			Apply Impulse(Event Player, Up, 7, To World, Cancel Contrary Motion);
			Apply Impulse(Event Player, Forward, 1, To Player, Cancel Contrary Motion);
			Event Player.WinstonWallClimbEnabled = False;
		End;
		Set Move Speed(Event Player, 100);
		Wait(0.033, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Wall Climb Reset When On Ground")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
	}

	actions
	{
		Event Player.WinstonWallClimbEnabled = True;
	}
}

disabled rule("BAPTISTE MODIFIERS")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Baptiste Slide (LSHIFT / Ability 1) Part 1")
{
	event
	{
		Ongoing - Each Player;
		All;
		Baptiste;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Clear Status(Event Player, Phased Out);
		Set Status(Event Player, Null, Knocked Down, 9999);
	}
}

rule("Baptiste Slide (LSHIFT / Ability 1) - Cancel slide if player stops pressing shift")
{
	event
	{
		Ongoing - Each Player;
		All;
		Baptiste;
	}

	conditions
	{
		Is Button Held(Event Player, Ability 1) == False;
	}

	actions
	{
		Clear Status(Event Player, Knocked Down);
		Set Status(Event Player, Null, Phased Out, 9999);
		If(Is On Ground(Event Player));
			Apply Impulse(Event Player, Up, 6, To World, Cancel Contrary Motion);
		End;
	}
}

rule("Baptiste Slide (LSHIFT / Ability 1) - Cancel slide after preset time")
{
	event
	{
		Ongoing - Each Player;
		All;
		Baptiste;
	}

	conditions
	{
		Has Status(Event Player, Knocked Down) == True;
	}

	actions
	{
		Wait(5, Abort When False);
		Clear Status(Event Player, Knocked Down);
		Apply Impulse(Event Player, Up, 6, To World, Cancel Contrary Motion);
		Set Status(Event Player, Null, Phased Out, 9999);
	}
}

rule("Baptiste Slide (LSHIFT / Ability 1) - Apply impulse when knocked down")
{
	event
	{
		Ongoing - Each Player;
		All;
		Baptiste;
	}

	conditions
	{
		Has Status(Event Player, Knocked Down) == True;
	}

	actions
	{
		Apply Impulse(Event Player, Forward, 10, To Player, Cancel Contrary Motion);
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Baptiste Immortality Small Modifier")
{
	event
	{
		Ongoing - Each Player;
		All;
		Baptiste;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Clear Status(Event Player, Phased Out);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
		Set Status(Event Player, Null, Phased Out, 9999);
	}
}

disabled rule("ANA MODIFIERS")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Ana Primary Pulse")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ana;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
		Has Status(Event Player, Rooted) == False;
		disabled Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Set Gravity(Event Player, 0);
		Apply Impulse(Event Player, Facing Direction Of(Event Player), 15, To World, Cancel Contrary Motion);
		Wait(0.060, Ignore Condition);
		Set Gravity(Event Player, 100);
	}
}

rule("Ana Sleep Dart Teleport")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ana;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Stop Camera(Event Player);
		"The duration before Ana fires sleep dart"
		Wait(0.300, Ignore Condition);
		Event Player.AnaSleepDartTeleLocation = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 180, All Players(All Teams), Event Player, True);
		"Shorten ray cast to avoid unintended tele through surfaces"
		Event Player.AnaSleepDartTeleLocation -= Direction Towards(Eye Position(Event Player), Event Player.AnaSleepDartTeleLocation)
			* 0.500;
		If(Y Component Of(Event Player.AnaSleepDartTeleLocation) > 24);
			Small Message(Event Player, Custom String("Teleport location elevation too high"));
			Cancel Primary Action(Event Player);
			Wait(0.100, Ignore Condition);
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
			Abort;
		End;
		"Sleep dart travel time"
		Wait(Distance Between(Eye Position(Event Player), Event Player.AnaSleepDartTeleLocation) / 60, Ignore Condition);
		Teleport(Event Player, Event Player.AnaSleepDartTeleLocation);
		Call Subroutine(CancelMomentum);
		Small Message(Event Player, Custom String("{0} alt {1}", Event Player.AnaSleepDartTeleLocation, Altitude Of(Event Player)));
	}
}

rule("Heal = Impulse {must be damaged when spawning}")
{
	event
	{
		Player Dealt Healing;
		All;
		Ana;
	}

	conditions
	{
		Healee == Healer;
		Has Status(Event Player, Rooted) == False;
	}

	actions
	{
		Apply Impulse(Event Player, Facing Direction Of(Event Player), -15, To World, Cancel Contrary Motion);
		Wait(1, Ignore Condition);
	}
}

rule("Ana Health Managment")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ana;
	}

	conditions
	{
		Normalized Health(Event Player) >= 1;
		Is In Spawn Room(Event Player) != True;
	}

	actions
	{
		Clear Status(Event Player, Phased Out);
		Damage(Event Player, Event Player, 50);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
		Set Status(Event Player, Null, Phased Out, 9999);
	}
}

disabled rule("Sigma Abilities")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Barrier {1}")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.sigma_barrier_ON = True;
		Event Player.sigma_barrier_init_position = Eye Position(Event Player) + Facing Direction Of(Event Player) * 3;
		Event Player.sigma_barrier_direction = Facing Direction Of(Event Player);
		Event Player.sigma_barrier_chase = 0;
		Chase Player Variable At Rate(Event Player, sigma_barrier_chase, Distance Between(Event Player.sigma_barrier_init_position,
			Ray Cast Hit Position(Event Player.sigma_barrier_init_position,
			Event Player.sigma_barrier_init_position + Event Player.sigma_barrier_direction * 200, Null, Event Player, False)), 16.500,
			Destination and Rate);
		"Updates barrier position"
		While(True);
			Event Player.sigma_barrier_position = Event Player.sigma_barrier_init_position + Event Player.sigma_barrier_direction * Event Player.sigma_barrier_chase;
			Wait(0.016, Ignore Condition);
			Abort If Condition Is False;
		End;
	}
}

rule("Barrier {2}")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == False;
		Event Player.sigma_barrier_ON == True;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, sigma_barrier_chase);
		Wait(0.192, Ignore Condition);
		Event Player.sigma_barrier_ready_to_destroy = True;
	}
}

rule("Barrier Launch")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Event Player.sigma_barrier_ON == True;
		Distance Between(Eye Position(Event Player), Event Player.sigma_barrier_position) < 3;
	}

	actions
	{
		"{Turns shield into a bouncepad instead when turned on}"
		disabled Event Player.sigma_barrier_direction = Vector(X Component Of(Event Player.sigma_barrier_direction), Absolute Value(Y Component Of(
			Event Player.sigma_barrier_direction)), Z Component Of(Event Player.sigma_barrier_direction));
		Apply Impulse(Event Player, Event Player.sigma_barrier_direction, 30, To World, Cancel Contrary Motion);
	}
}

rule("Remove Barrier")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Event Player.sigma_barrier_ready_to_destroy == True;
		Is Button Held(Event Player, Secondary Fire) == True;
	}

	actions
	{
		Event Player.sigma_barrier_ON = False;
		Wait(0.016, Ignore Condition);
		Event Player.sigma_barrier_ready_to_destroy = False;
	}
}

rule("Destroy Pulse On Death")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dead(Event Player) == True;
	}

	actions
	{
		Event Player.sigma_barrier_ON = False;
		Event Player.sigma_barrier_ready_to_destroy = False;
	}
}

rule("Vortex Drag {By default, using vortex makes you glide across the ground without resetting during the animation}")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Set Gravity(Event Player, 0);
		Set Move Speed(Event Player, 0);
		Wait(2, Restart When True);
		Set Gravity(Event Player, 100);
		Set Move Speed(Event Player, 100);
	}
}

rule("Vortex Refresh")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dead(Event Player) == True;
	}

	actions
	{
		Set Move Speed(Event Player, 100);
		Set Gravity(Event Player, 100);
	}
}

rule("Rock Booster")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		"Rock can be used during the vortex animation"
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Wait(0.650, Ignore Condition);
		Apply Impulse(Event Player, Facing Direction Of(Event Player), -14, To World, Cancel Contrary Motion);
	}
}