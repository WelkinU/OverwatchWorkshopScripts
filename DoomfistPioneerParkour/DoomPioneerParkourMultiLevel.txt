settings
{
	main
	{
		Description: "Doomfist Pioneering Parkour - MultiLevel Edition! Host creates levels, different levels have different restrictions on the Pioneer."
	}

	modes
	{
		Assault
		{
			enabled maps
			{
				Hanamura
			}
		}

		Control
		{
			enabled maps
			{
			}
		}

		Escort
		{
			enabled maps
			{
			}
		}

		Hybrid
		{
			enabled maps
			{
			}
		}

		General
		{
			Hero Limit: Off
			Kill Feed: Off
		}
	}

	heroes
	{
		General
		{
			Genji
			{
				Ammunition Clip Size Scalar: 25%
				Swift Strike Cooldown Time: 75%
				Ultimate Duration: 33%
			}

			Roadhog
			{
				Ammunition Clip Size Scalar: 25%
				Chain Hook Cooldown Time: 75%
				Take a Breather Cooldown Time: 75%
			}

			enabled heroes
			{
				Doomfist
			}
		}
	}
}

variables
{
	global:
		0: CPLocations
		3: LevelDescriptions
		4: CurrentPioneer
		6: GameStarted
		7: HeroUseArrayofArrays
		8: CountPunchUpperSlam
		9: CountMeteorTeleportNano
		13: HeroList
		17: CPRadius
		18: SinglePlayerModeEnabled
		19: TextLevelCreateMenu
		20: IndexLevelCreateMenu

	player:
		0: CurrentCP
		1: CurrentLevel
		2: LevelMaxUnlockedCPArray
		3: CheckpointTimer
		4: PunchUpperSlamUsed
		5: CountUltimateTeleportNano
		10: ForceRespawn
		17: WinstonWallClimbEnabled
		18: WinstonBubbleLocation
		19: WinstonBouncyBubbleCooldown
		21: WinstonBubbleEffect
		23: CancelPointTimer
}

subroutines
{
	0: RespawnPlayer
	1: MakeMenuText
	2: CancelMomentum
}

disabled rule("Initialization")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Initialize Global Variables")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Set this variable to TRUE if you want to enable a player to be pioneer multiple checkpoints in a row"
		Global.SinglePlayerModeEnabled = False;
		"If you want to add an extra level type to the game mode, just add a description here and that's it!"
		Global.LevelDescriptions = Array(Null, Custom String("Level 1: Easy"), Custom String("Level 2: Medium"), Custom String(
			"Level 3: Expert"), Custom String("Level 4: Multi-Hero"));
		"Global constant for checkpoint circle radius"
		Global.CPRadius = 2;
		"Set to False, if pioneer has not set Multi-Level Origin point"
		Global.GameStarted = False;
		"Initialization to array of NULL not actually necessary, but for future coders to see the global variable structure, this is here"
		For Global Variable(Z, 0, Count Of(Global.LevelDescriptions) + 1, 1);
			Global.CPLocations[Global.Z] = Null;
			Global.CurrentPioneer[Global.Z] = Array(Host Player);
			Global.CountPunchUpperSlam[Global.Z] = Array(Vector(9, 9, 9));
			Global.CountMeteorTeleportNano[Global.Z] = Array(Vector(9, 9, 9));
			Global.HeroUseArrayofArrays[Global.Z] = Array(Hero(Doomfist));
		End;
		"Set the hero rotation for multi-hero level"
		Global.HeroList = Array(Hero(Doomfist), Hero(Winston), Hero(Roadhog), Hero(LÃºcio), Hero(Genji));
	}
}

rule("Initialize Player Variables and HUD")
{
	event
	{
		Player Joined Match;
		All;
		All;
	}

	actions
	{
		Event Player.CurrentCP = 0;
		Event Player.CurrentLevel = 0;
		Set Status(Event Player, Null, Phased Out, 9999);
		"Rings and Pioneer Text HUD"
		Create Effect(Filtered Array(Event Player, Event Player.CurrentCP > 0), Ring, Purple,
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP], Global.CPRadius, Visible To Position and Radius);
		Create Effect(Filtered Array(Event Player, Event Player.CurrentCP > 0 && Event Player.CurrentCP + 1 < Count Of(
			Global.CPLocations[Event Player.CurrentLevel])), Ring, Purple,
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1], Global.CPRadius, Visible To Position and Radius);
		Create In-World Text(Filtered Array(Event Player, Event Player.CurrentCP > 0 && Event Player.CurrentCP + 1 < Count Of(
			Global.CPLocations[Event Player.CurrentLevel])), Custom String("Next Checkpoint\r\nPioneer {0}",
			Global.CurrentPioneer[Event Player.CurrentLevel][Event Player.CurrentCP + 0]),
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1], 2, Do Not Clip, Visible To Position and String,
			Purple, Default Visibility);
		Create HUD Text(Event Player, Custom String("Level {0} CP {1}", Event Player.CurrentLevel, Event Player.CurrentCP), Null, Null,
			Left, 0, White, White, White, Visible To and String, Default Visibility);
		disabled Create HUD Text(Event Player, Custom String("{0} {1} {2}", Custom String("{0} {1}", Ability Icon String(Hero(Doomfist), Button(
			Secondary Fire)), X Component Of(Event Player.PunchUpperSlamUsed)), Custom String("{0} {1}", Ability Icon String(Hero(
			Doomfist), Button(Ability 1)), Y Component Of(Event Player.PunchUpperSlamUsed)), Custom String("{0} {1}", Ability Icon String(
			Hero(Doomfist), Button(Ability 2)), Z Component Of(Event Player.PunchUpperSlamUsed))), Null, Null, Left, 2, White, White,
			White, Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(Event Player, Current Array Element.CheckpointTimer > 0), Custom String("Time Remaining: {0}sec",
			Event Player.CheckpointTimer), Null, Null, Top, 2, White, White, White, Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(Event Player, Count Of(Global.CPLocations[Event Player.CurrentLevel]) > Count Of(
			Global.CurrentPioneer[Event Player.CurrentLevel])), Custom String("{0} - Waiting for next pioneer",
			Global.LevelDescriptions[Event Player.CurrentLevel]), Null, Null, Top, 1, Green, White, White, Visible To and String,
			Default Visibility);
	}
}

rule("Initialize Global HUD")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"If first checkpoint has not been placed, show HUD prompting pioneer (Host Player) to press R to start the map."
		Create HUD Text(Filtered Array(All Players(All Teams), !Global.GameStarted), Custom String(
			"{0} leave the spawn and press R to create the first checkpoint!", Host Player), Null, Null, Top, 1, Green, White, White,
			Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("Workshop Code: KN199P"), Right, -1, White, White, White,
			Visible To and String, Default Visibility);
	}
}

rule("Debug HUD")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		disabled Create HUD Text(Event Player, Custom String("Current Level Pioneer: {0}", Last Of(
			Global.CurrentPioneer[Event Player.CurrentLevel])), Null, Null, Left, 9, White, White, White, Visible To and String,
			Default Visibility);
	}
}

disabled rule("Multi-Level Architecture")
{
	event
	{
		Ongoing - Global;
	}
}

rule("First Pioneer (Host) Create Multilevel Origin Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.GameStarted == False;
		Is Button Held(Host Player, Reload) == True;
		Event Player == Host Player;
		Has Spawned(Event Player) == True;
		Is On Ground(Event Player) == True;
	}

	actions
	{
		Small Message(All Players(All Teams), Custom String("Creating origin point"));
		For Player Variable(Event Player, Z, 0, Count Of(Global.LevelDescriptions), 1);
			Global.CPLocations[Event Player.Z] = Array(Position Of(Event Player));
		End;
		"Create origin ring - visible to all players on Level 0 (level selection part)."
		Create Effect(Filtered Array(All Players(All Teams), Global.GameStarted && Current Array Element.CurrentCP == 0), Ring, Purple,
			Global.CPLocations[0][0], Global.CPRadius, Visible To Position and Radius);
		Global.GameStarted = True;
		"Menu is not zero indexed, using 1 as base index"
		Global.IndexLevelCreateMenu = 1;
		Call Subroutine(MakeMenuText);
		"Create Level Type Creation Menu"
		Create HUD Text(Filtered Array(Host Player, Current Array Element.CurrentCP == 0), Global.TextLevelCreateMenu, Null, Null, Top, 3,
			White, White, White, Visible To and String, Default Visibility);
		"Move all players to the origin point"
		disabled Teleport(All Players(All Teams), Global.CPLocations[0][0]);
		Call Subroutine(RespawnPlayer);
	}
}

rule("Create New Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Distance Between(Global.CPLocations[0][0], Position Of(Event Player)) > 10;
		Event Player == Host Player;
		Event Player.CurrentCP == 0;
		"Make sure level hasn't already been created"
		Count Of(Global.CPLocations[Global.IndexLevelCreateMenu]) < 2;
		Is On Ground(Event Player) == True;
		Is In Spawn Room(Event Player) != True;
	}

	actions
	{
		Wait(0.100, Abort When False);
		Big Message(Event Player, Custom String("Press R within 3 sec to cancel point!"));
		Event Player.CancelPointTimer = 3;
		Chase Player Variable At Rate(Event Player, CancelPointTimer, 0, 1, Destination and Rate);
		While(Event Player.CancelPointTimer > 0);
			Wait(0.033, Ignore Condition);
			Call Subroutine(CancelMomentum);
			If(Is Button Held(Event Player, Reload));
				Call Subroutine(RespawnPlayer);
				Abort;
			End;
		End;
		Abort If Condition Is False;
		Small Message(All Players(All Teams), Custom String("Created {0}", Global.LevelDescriptions[Event Player.CurrentLevel]));
		Event Player.CurrentLevel = Global.IndexLevelCreateMenu;
		Modify Global Variable At Index(CPLocations, Event Player.CurrentLevel, Append To Array, Position Of(Event Player));
		"Create level entry ring - visible to all players on Level 0 (level selection part)."
		Create Effect(Filtered Array(All Players(All Teams), True && Current Array Element.CurrentCP < 2), Ring, Purple,
			Global.CPLocations[Event Player.CurrentLevel][1], Global.CPRadius, Visible To);
		Create In-World Text(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0), Custom String("{0}",
			Global.LevelDescriptions[Global.IndexLevelCreateMenu]), Global.CPLocations[Event Player.CurrentLevel][1], 2, Do Not Clip,
			Visible To, Purple, Default Visibility);
		Create Icon(Filtered Array(All Players(All Teams), Current Array Element.CurrentCP == 0),
			Global.CPLocations[Event Player.CurrentLevel][1], Flag, Visible To, Yellow, True);
		Call Subroutine(RespawnPlayer);
	}
}

rule("Enter Into Level")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.CurrentCP == 0;
		Is On Ground(Event Player) == True;
	}

	actions
	{
		For Player Variable(Event Player, Z, 1, Count Of(Global.CPLocations), 1);
			If(Count Of(Global.CPLocations[Event Player.Z]) > 1);
				If(Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.Z][1]) < Global.CPRadius);
					Event Player.CurrentCP = 1;
					Event Player.CurrentLevel = Event Player.Z;
					disabled Small Message(Event Player, Custom String("Entered {0}", Global.LevelDescriptions[Event Player.CurrentLevel]));
					"If no pioneer for the current level and player is on last checkpoint of the level, set them as pioneer"
					If(Count Of(Global.CurrentPioneer[Event Player.CurrentLevel]) == 1 && True);
						Big Message(Event Player, Custom String("You Are Pioneer! Use your skills to create the next point!"));
						Modify Global Variable At Index(CurrentPioneer, Event Player.CurrentLevel, Append To Array, Event Player);
					End;
					Call Subroutine(RespawnPlayer);
					Abort;
				End;
			End;
		End;
		Wait(0.033, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Handle Player Death")
{
	event
	{
		Player Died;
		All;
		All;
	}

	actions
	{
		"To fix bug where pioneer jumps off map and tele's back to spawn"
		Wait(0.050, Ignore Condition);
		Respawn(Event Player);
		If(Global.GameStarted);
			Wait(0.100, Ignore Condition);
			Small Message(Event Player, Custom String("Don't die!"));
			Call Subroutine(RespawnPlayer);
		End;
		Wait(0.100, Ignore Condition);
		Set Status(Event Player, Null, Phased Out, 9999);
	}
}

disabled rule("Doom Parkour Pioneer Architecture - Individual Level")
{
	event
	{
		Ongoing - Global;
	}
}

rule("LevelTimers [NOT IMPLEMENTED YET]")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Pioneer - Create New Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
		"Inside a level, not in multilevel portion"
		Event Player.CurrentCP > 0;
		Distance Between(Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP], Position Of(Event Player)) > 10;
		"Doesn't always work, as there are locations that are inaccessable for a certain team but not in spawn room"
		Is In Spawn Room(Event Player) != True;
		"event player = pioneer for this level / CP"
		Event Player == Last Of(Global.CurrentPioneer[Event Player.CurrentLevel]);
		"Is on last checkpoint of the level"
		Event Player.CurrentCP + 1 == Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		"Give Doomfist ability to get a jump after using Seismic Slam"
		(Hero Of(Event Player) == Hero(Doomfist) && Is Using Ability 2(Event Player)) == False;
		"Player can't pioneer if they were the last pioneer on that level and Single Player Mode isn't engaged"
		(Global.SinglePlayerModeEnabled || Event Player != Global.CurrentPioneer[Event Player.CurrentLevel][Event Player.CurrentCP - 1])
			== True;
	}

	actions
	{
		Event Player.W = Position Of(Event Player);
		Wait(0.250, Abort When False);
		Event Player.CancelPointTimer = 3;
		Chase Player Variable At Rate(Event Player, CancelPointTimer, 0, 1, Destination and Rate);
		Big Message(Event Player, Custom String("Press R within 3 sec to cancel point!"));
		While(Event Player.CancelPointTimer > 0);
			Wait(0.033, Ignore Condition);
			Call Subroutine(CancelMomentum);
			If(Is Button Held(Event Player, Reload));
				Call Subroutine(RespawnPlayer);
				Abort;
			End;
		End;
		"Abort if player is in spawn room - this can happen if they die within 3 sec after making a point"
		Abort If(Is In Spawn Room(Event Player));
		Small Message(Event Player, Custom String("Created Point! {0}", Event Player.PunchUpperSlamUsed));
		Modify Global Variable At Index(CountPunchUpperSlam, Event Player.CurrentLevel, Append To Array, Event Player.PunchUpperSlamUsed);
		Modify Global Variable At Index(CountMeteorTeleportNano, Event Player.CurrentLevel, Append To Array,
			Event Player.CountUltimateTeleportNano);
		Modify Global Variable At Index(HeroUseArrayofArrays, Event Player.CurrentLevel, Append To Array, Hero Of(Event Player));
		Modify Global Variable At Index(CPLocations, Event Player.CurrentLevel, Append To Array, Event Player.W);
		disabled Call Subroutine(RespawnPlayer);
		disabled Wait(0.200, Ignore Condition);
		"Respawn other players"
		Filtered Array(All Players(All Teams),
			Current Array Element.CurrentLevel == Event Player.CurrentLevel && Current Array Element.CurrentCP == Event Player.CurrentCP)
			.ForceRespawn = True;
	}
}

rule("Pioneered less than 10m")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
		"Inside a level, not in multilevel portion"
		Event Player.CurrentCP > 0;
		Distance Between(Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP], Position Of(Event Player)) < 10;
		Distance Between(Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP], Position Of(Event Player))
			> Global.CPRadius;
		"event player = pioneer for this level / CP"
		Event Player == Last Of(Global.CurrentPioneer[Event Player.CurrentLevel]);
		"Is on last checkpoint of the level"
		Event Player.CurrentCP + 1 == Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		"Give Doomfist ability to get a jump after using Seismic Slam"
		(Hero Of(Event Player) == Hero(Doomfist) && Is Using Ability 2(Event Player)) == False;
		"Player can't pioneer if they were the last pioneer on that level and Single Player Mode isn't engaged"
		(Global.SinglePlayerModeEnabled || Event Player != Global.CurrentPioneer[Event Player.CurrentLevel][Event Player.CurrentCP - 1])
			== True;
	}

	actions
	{
		Small Message(Event Player, Custom String("Need to pioneer further than 10m"));
		Call Subroutine(RespawnPlayer);
	}
}

rule("Non-Pioneer Player Arrive At Point (Set Them As Next Pioneer If Applicable)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"Inside a level, not in multilevel portion, make this trigger on checkpoints 1+ to stop conflict with Enter Into Level rule"
		Event Player.CurrentCP > 0;
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		Is On Ground(Event Player) == True;
		"Is at the next checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1])
			< Global.CPRadius;
		"Give Doomfist ability to get a jump after using Seismic Slam"
		(Hero Of(Event Player) == Hero(Doomfist) && Is Using Ability 2(Event Player)) == False;
	}

	actions
	{
		Wait(0.200, Abort When False);
		Small Message(Event Player, Custom String("Arrived!"));
		Event Player.CurrentCP += 1;
		"Update maximum checkpoint the player has reached for this level"
		Event Player.LevelMaxUnlockedCPArray[Event Player.CurrentLevel] = Event Player.CurrentCP;
		"If no pioneer for the current level and player is on last checkpoint of the level, set them as pioneer"
		If(Count Of(Global.CurrentPioneer[Event Player.CurrentLevel]) == Event Player.CurrentCP + 0);
			If(Global.SinglePlayerModeEnabled || Event Player != Global.CurrentPioneer[Event Player.CurrentLevel][Event Player.CurrentCP - 1]);
				Modify Global Variable At Index(CurrentPioneer, Event Player.CurrentLevel, Append To Array, Event Player);
				Big Message(Event Player, Custom String("You Are Pioneer! Use your skills to create the next point!"));
			End;
		End;
		Call Subroutine(RespawnPlayer);
	}
}

rule("Handle ForceRespawn")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.ForceRespawn == True;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
		Event Player.ForceRespawn = False;
	}
}

rule("Touch Ground = Respawn")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
		"Is not Pioneer"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations[Event Player.CurrentLevel]);
		"Is not at the current checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 0])
			> Global.CPRadius;
		"Is not at the next checkpoint"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1])
			> Global.CPRadius;
		"Origin Point Exists"
		Global.GameStarted == True;
		"Is not making a new level at CP0"
		!(Event Player == Host Player && Event Player.CurrentCP == 0) == True;
		"Give Doomfist ability to get a jump after using Seismic Slam"
		(Hero Of(Event Player) == Hero(Doomfist) && Is Using Ability 2(Event Player)) == False;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Used Secondary (Rocket Punch)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Left;
	}
}

rule("Used Ability 1 (Uppercut)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Up;
	}
}

rule("Used Ability 2 (Seismic Slam)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Event Player.PunchUpperSlamUsed += Forward;
	}
}

rule("Used Ultimate")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Event Player.CountUltimateTeleportNano += Left;
	}
}

disabled rule("Additional Features (and Key Bindings)")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Melee + Left Click = Teleport")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Primary Fire) == True;
		Is Button Held(Event Player, Melee) == True;
	}

	actions
	{
		Teleport(Event Player, Ray Cast Hit Position(Position Of(Event Player), Position Of(Event Player) + Facing Direction Of(
			Event Player) * 60, All Players(All Teams), Event Player, True));
	}
}

rule("Melee = Next Menu Selection")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.CurrentCP == 0;
		Event Player == Host Player;
		Global.GameStarted == True;
		Is Button Held(Host Player, Melee) == True;
	}

	actions
	{
		Global.IndexLevelCreateMenu = Global.IndexLevelCreateMenu % (Count Of(Global.LevelDescriptions) - 1) + 1;
		Call Subroutine(MakeMenuText);
	}
}

rule("Move Back A Checkpoint with Jump + Interact")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Jump) == True;
		Is Button Held(Event Player, Interact) == True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		If(Event Player.CurrentCP > 0);
			Event Player.CurrentCP += -1;
		Else;
			Event Player.CurrentCP = Event Player.LevelMaxUnlockedCPArray[Event Player.CurrentLevel];
		End;
		Call Subroutine(RespawnPlayer);
		Stop Holding Button(Event Player, Jump);
		Stop Holding Button(Event Player, Interact);
	}
}

rule("R is Respawn Player")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Reload) == True;
		Is On Ground(Event Player) != True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
		"So player can't R and get teleported outside map before origin point is selected"
		Global.GameStarted == True;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

disabled rule("Subroutines")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Sub0: RespawnPlayer")
{
	event
	{
		Subroutine;
		RespawnPlayer;
	}

	actions
	{
		Teleport(Event Player, Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP]);
		Set Facing(Event Player, Direction Towards(Position Of(Event Player),
			Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP + 1]), To World);
		Event Player.CheckpointTimer = 0;
		Stop Chasing Player Variable(Event Player, CheckpointTimer);
		Set Status(Event Player, Null, Phased Out, 9999);
		Cancel Primary Action(Event Player);
		Call Subroutine(CancelMomentum);
		"Added this to fix issue where if you pressed R while using slam, the slam cooldown wasn't reset"
		Wait(0.100, Ignore Condition);
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Set Ultimate Charge(Event Player, 100);
		Event Player.CancelPointTimer = 0;
		Event Player.PunchUpperSlamUsed = Vector(0, 0, 0);
		Event Player.CountUltimateTeleportNano = Vector(0, 0, 0);
		If(Count Of(Global.CPLocations[Event Player.CurrentLevel]) > Event Player.CurrentCP + 1);
			If(X Component Of(Global.CountPunchUpperSlam[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
				Set Secondary Fire Enabled(Event Player, False);
			Else;
				Set Secondary Fire Enabled(Event Player, True);
			End;
			If(Y Component Of(Global.CountPunchUpperSlam[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
				Set Ability 1 Enabled(Event Player, False);
			Else;
				Set Ability 1 Enabled(Event Player, True);
			End;
			If(Z Component Of(Global.CountPunchUpperSlam[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
				Set Ability 2 Enabled(Event Player, False);
			Else;
				Set Ability 2 Enabled(Event Player, True);
			End;
			If(X Component Of(Global.CountMeteorTeleportNano[Event Player.CurrentLevel][Event Player.CurrentCP]) == 0);
				Set Ultimate Ability Enabled(Event Player, False);
			Else;
				Set Ultimate Ability Enabled(Event Player, True);
			End;
		Else;
			Set Secondary Fire Enabled(Event Player, True);
			Set Ability 1 Enabled(Event Player, True);
			Set Ability 2 Enabled(Event Player, True);
			Set Ultimate Ability Enabled(Event Player, True);
		End;
		Event Player.WinstonBouncyBubbleCooldown = 0;
		Destroy Effect(Event Player.WinstonBubbleEffect);
		Event Player.WinstonBubbleLocation = Null;
		Cancel Primary Action(Event Player);
		Start Forcing Player To Be Hero(Event Player, Global.HeroUseArrayofArrays[Event Player.CurrentLevel][Event Player.CurrentCP]);
	}
}

rule("Sub1: MakeMenuText - Make Text For Level Creation Type Menu")
{
	event
	{
		Subroutine;
		MakeMenuText;
	}

	actions
	{
		If(Global.IndexLevelCreateMenu == 1);
			Global.TextLevelCreateMenu = Custom String("Melee = Next Selection\r\n{0}\r\n{1}\r\n{2}", Custom String("{0} {1} {2}", Icon String(
				Arrow: Right), Global.LevelDescriptions[1], Icon String(Arrow: Left)), Global.LevelDescriptions[2], Custom String("{0}\r\n{1}",
				Global.LevelDescriptions[3], Global.LevelDescriptions[4]));
		Else If(Global.IndexLevelCreateMenu == 2);
			Global.TextLevelCreateMenu = Custom String("Melee = Next Selection\r\n{0}\r\n{1}\r\n{2}", Custom String("{1}", Icon String(
				Arrow: Right), Global.LevelDescriptions[1], Icon String(Arrow: Left)), Custom String("{0} {1} {2}", Icon String(Arrow: Right),
				Global.LevelDescriptions[2], Icon String(Arrow: Left)), Custom String("{0}\r\n{1}", Global.LevelDescriptions[3],
				Global.LevelDescriptions[4]));
		Else If(Global.IndexLevelCreateMenu == 3);
			Global.TextLevelCreateMenu = Custom String("Melee = Next Selection\r\n{0}\r\n{1}\r\n{2}", Custom String("{1}", Icon String(
				Arrow: Right), Global.LevelDescriptions[1], Icon String(Arrow: Left)), Custom String("{1}", Icon String(Arrow: Right),
				Global.LevelDescriptions[2], Icon String(Arrow: Left)), Custom String("{0}\r\n{1}", Custom String("{0} {1} {2}", Icon String(
				Arrow: Right), Global.LevelDescriptions[3], Icon String(Arrow: Left)), Global.LevelDescriptions[4]));
		Else If(Global.IndexLevelCreateMenu == 4);
			Global.TextLevelCreateMenu = Custom String("Melee = Next Selection\r\n{0}\r\n{1}\r\n{2}", Custom String("{1}", Icon String(
				Arrow: Right), Global.LevelDescriptions[1], Icon String(Arrow: Left)), Custom String("{1}", Icon String(Arrow: Right),
				Global.LevelDescriptions[2], Icon String(Arrow: Left)), Custom String("{0}\r\n{1}", Custom String("{1}", Icon String(
				Arrow: Right), Global.LevelDescriptions[3], Icon String(Arrow: Left)), Custom String("{0} {1} {2}", Icon String(Arrow: Right),
				Global.LevelDescriptions[4], Icon String(Arrow: Left))));
		End;
	}
}

rule("Sub2: CancelMomentum")
{
	event
	{
		Subroutine;
		CancelMomentum;
	}

	actions
	{
		Apply Impulse(Event Player, Up, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Down, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Left, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Right, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Forward, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Backward, 0.001, To World, Cancel Contrary Motion);
	}
}

disabled rule("Level Modifiers")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Level 1 Modifer - Only Have 6 Seconds To Make Point (Part 1)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.CurrentLevel == 1;
		Event Player.CurrentCP > 0;
		"Player Has Left Point"
		Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentLevel][Event Player.CurrentCP])
			> Global.CPRadius;
	}

	actions
	{
		Event Player.CheckpointTimer = 6;
		Chase Player Variable At Rate(Event Player, CheckpointTimer, 0, 1, Destination and Rate);
		While(Event Player.CheckpointTimer > 0);
			Wait(0.100, Ignore Condition);
		End;
		Abort If Condition Is False;
		Abort If(Event Player.CancelPointTimer > 0);
		Small Message(Event Player, Custom String("Level 1 Restriction: Complete Point In 6 Seconds!"));
		Call Subroutine(RespawnPlayer);
	}
}

rule("Multi-Hero Level: Switch Hero When Player Emotes")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating Any Emote(Event Player) == True;
		disabled Event Player.H == True;
		(Event Player.CurrentCP + 1 == Count Of(Global.CPLocations[Event Player.CurrentLevel]) && True) == True;
		Event Player.CurrentLevel == 4;
	}

	actions
	{
		Start Forcing Player To Be Hero(Event Player, Global.HeroList[(Index Of Array Value(Global.HeroList, Hero Of(Event Player)) + 1)
			% Count Of(Global.HeroList)]);
		Set Ultimate Charge(Event Player, 100);
	}
}

disabled rule("Doomfist Modifiers")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Meteor Strike Movement Slow")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Set Move Speed(Event Player, 50);
	}
}

rule("Set Movement Speed Normal When Not Using Meteor Strike")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		Set Move Speed(Event Player, 100);
	}
}

disabled rule("ROADHOG STUFF")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Change Hook to Grappling Hook")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		"Initial impulse to let you hook in midair without falling too far while hook is out"
		Apply Impulse(Event Player, Up, 3, To World, Cancel Contrary Motion);
		"Issue here is that we are using ray cast to determine hook impact, which isn't visually accurate, so the hook may impact a wall but not be deteted."
		Event Player.Y = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 120 * Facing Direction Of(
			Event Player), All Players(All Teams), Event Player, True);
		"Abort if hook didn't connect with a wall within 25m. For reference, 20m is hook range for normal roadhog."
		If(Distance Between(Position Of(Event Player), Event Player.Y) > 25);
			Small Message(Event Player, Custom String("Out of hook range!"));
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
			Abort;
		End;
		"Wait for hook to \"hit\" something. Hook moves at 40m/s"
		Wait(Distance Between(Position Of(Event Player), Event Player.Y) / 40, Ignore Condition);
		"Impulse that increases with hook range. Hook impulse = Base Impulse + Hook Range x Range Multiplier."
		Apply Impulse(Event Player, Direction Towards(Position Of(Event Player), Event Player.Y), 20 + Distance Between(Event Player.Y,
			Position Of(Event Player)) * 0.800, To World, Cancel Contrary Motion);
		"Large Linear Impulse. Disabled while testing impulse that increases with range."
		disabled Apply Impulse(Event Player, Direction Towards(Position Of(Event Player), Event Player.Y), 40, To World, Cancel Contrary Motion);
	}
}

rule("Change Take A Breather to Bouncy Ball Hog")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		disabled Is On Ground(Event Player) == True;
		Altitude Of(Event Player) <= 1.500;
	}

	actions
	{
		Apply Impulse(Event Player, Up, Speed Of(Event Player) * 1.200, To World, Cancel Contrary Motion);
	}
}

rule("Add Knockback When Secondary Fire Used")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Apply Impulse(Event Player, Facing Direction Of(Event Player), -12, To World, Cancel Contrary Motion);
	}
}

rule("Roadhog Ultimate")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Small Message(Event Player, Custom String("Hold Melee to Cancel Ultimate"));
		While(Is Using Ultimate(Event Player) && !Is Button Held(Event Player, Melee));
			Wait(0.066, Ignore Condition);
			"Cause knockback on player"
			disabled Apply Impulse(Event Player, Facing Direction Of(Event Player), -10, To World, Cancel Contrary Motion);
			"Player Knockback"
			Apply Impulse(Event Player, Facing Direction Of(Event Player), -1.500, To World, Cancel Contrary Motion);
			"\"Drill\" Through Walls, Skyboxes, etc."
			Teleport(Event Player, Position Of(Event Player) + Facing Direction Of(Event Player) * -1.500);
		End;
		"For melee cancel on ult"
		Cancel Primary Action(Event Player);
	}
}

rule("Limit Roadhog Ultimate Duration")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		"Set Ult Duration to 4 sec, then cancel it"
		Wait(3, Ignore Condition);
		Cancel Primary Action(Event Player);
	}
}

disabled rule("WINSTON STUFF")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Initialize Winston")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	actions
	{
		Event Player.WinstonBubbleLocation = Null;
	}
}

rule("Create Bubble")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		"Place Bubble on ground below player. Easier for new players to figure out what's going on (compared to Ray Cast bubble position)."
		Event Player.WinstonBubbleLocation = Position Of(Event Player) + World Vector Of(Forward, Event Player, Rotation)
			* Horizontal Speed Of(Event Player) * 0.300 + Down * Altitude Of(Event Player);
		"Use Ray Cast to determine bubble position"
		disabled Event Player.WinstonBubbleLocation = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 160, All Players(All Teams), Event Player, False);
		If(Distance Between(Event Player.WinstonBubbleLocation, Position Of(Event Player)) > 100);
			Small Message(Event Player, Custom String("Barrier Cast Out Of Range (100m)"));
			Set Ability Cooldown(Event Player, Button(Ability 2), 0);
			Abort;
		End;
		Create Effect(Event Player, Sphere, Blue, Event Player.WinstonBubbleLocation, 5, Visible To Position and Radius);
		Event Player.WinstonBubbleEffect = Last Created Entity;
		Event Player.WinstonBouncyBubbleCooldown = 9;
		Chase Player Variable At Rate(Event Player, WinstonBouncyBubbleCooldown, 0, 1, Destination and Rate);
		While(Event Player.WinstonBouncyBubbleCooldown > 0 && !Is Dead(Event Player));
			Wait(0.100, Ignore Condition);
		End;
		Destroy Effect(Event Player.WinstonBubbleEffect);
		Event Player.WinstonBubbleLocation = Null;
	}
}

rule("Winston Bubble Physics Rule")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Event Player.WinstonBubbleLocation != Null;
		Distance Between(Position Of(Event Player), Event Player.WinstonBubbleLocation) <= 5;
	}

	actions
	{
		"Direct Impulse - Cancel's Player Motion, so physically inaccurate bounce"
		Apply Impulse(Event Player, Direction Towards(Event Player.WinstonBubbleLocation, Position Of(Event Player)), Speed Of(
			Event Player) * 1.300, To World, Cancel Contrary Motion);
	}
}

rule("Winston Wall Climb")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Button Held(Event Player, Jump) == True;
		"Make this so a player can't use wall climb multiple times in a row."
		Event Player.WinstonWallClimbEnabled == True;
	}

	actions
	{
		Event Player.Q = 4;
		"Set Wall Climb to have a max of 4 sec duration. This prevents you from wall climing against a roof/skybox for indefinite stall."
		Chase Player Variable Over Time(Event Player, Q, 0, 4, Destination and Duration);
		"Wall Climb while Jump is held, have been wall climbing less than 4 sec, are within 0.5m of wall"
		While(Is Button Held(Event Player, Jump) && Event Player.Q > 0 && Distance Between(Ray Cast Hit Position(Eye Position(
			Event Player), Eye Position(Event Player) + Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(
			Event Player)), 0) * 10, All Players(All Teams), Event Player, True), Eye Position(Event Player)) < 3);
			Wait(0.033, Ignore Condition);
			Set Move Speed(Event Player, 0);
			Apply Impulse(Event Player, Up, 7, To World, Cancel Contrary Motion);
			Apply Impulse(Event Player, Forward, 1, To Player, Cancel Contrary Motion);
			Event Player.WinstonWallClimbEnabled = False;
		End;
		Set Move Speed(Event Player, 100);
		Wait(0.033, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Wall Climb Reset When On Ground")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
	}

	actions
	{
		Event Player.WinstonWallClimbEnabled = True;
	}
}