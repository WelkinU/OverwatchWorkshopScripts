settings
{
	main
	{
		Description: "Doomfist Pioneering Parkour - Special Edition. Includes modifiers for effect locks, player scale, Punch Grace, other heros, move speed, and more. To change gameplay and pioneer parameters, go to Lobby -> Settings -> Workshop Settings. Made by WelkinTern, Source Code: https://github.com/WelkinU/OverwatchWorkshopScripts/blob/master/DoomfistPioneerParkour/DoomPioneerParkourSingleLevel.txt"
	}

	lobby
	{
		Max Team 1 Players: 12
		Max Team 2 Players: 0
	}

	modes
	{
		Capture the Flag
		{
			enabled maps
			{
				Ayutthaya
			}
		}

		Deathmatch
		{
			enabled maps
			{
				Château Guillard
				Petra
			}
		}

		Skirmish
		{
			disabled maps
			{
				Blizzard World
				Hanamura Winter
				Hollywood Halloween
				Horizon Lunar Colony
				King's Row
				Lijiang Tower Lunar New Year
				Temple of Anubis
				Watchpoint: Gibraltar
				Workshop Chamber
				Workshop Expanse
				Workshop Expanse Night
				Workshop Green Screen
				Workshop Island
				Workshop Island Night
			}
		}

		General
		{
			Hero Limit: Off
			Kill Feed: Off
		}
	}

	heroes
	{
		Team 1
		{
			Genji
			{
				Ammunition Clip Size Scalar: 25%
				Swift Strike Cooldown Time: 75%
				Ultimate Duration: 34%
			}
		}

		Team 2
		{
			Genji
			{
				Ammunition Clip Size Scalar: 25%
				Swift Strike Cooldown Time: 75%
				Ultimate Duration: 34%
			}
		}

		Team FFA
		{
			Genji
			{
				Swift Strike Cooldown Time: 75%
				Ultimate Duration: 34%
			}
		}

		General
		{
			Ana
			{
				Ammunition Clip Size Scalar: 25%
				Biotic Grenade Cooldown Time: 60%
				Sleep Dart Cooldown Time: 75%
			}

			Baptiste
			{
				Immortality Field Cooldown Time: 70%
				Regenerative Burst Cooldown Time: 70%
			}

			D.Va
			{
				Spawn With Ultimate Ready: On
			}

			Doomfist
			{
				Seismic Slam Cooldown Time: 50%
			}

			Roadhog
			{
				Ammunition Clip Size Scalar: 25%
				Chain Hook Cooldown Time: 75%
				Take a Breather Cooldown Time: 75%
			}

			Sigma
			{
				Kinetic Grasp Cooldown Time: 20%
			}

			Widowmaker
			{
				Grappling Hook Cooldown Time: 0%
			}

			Winston
			{
				No Ammunition Requirement: On
				Ultimate Duration: 60%
			}

			enabled heroes
			{
				Doomfist
			}
		}
	}

	workshop
	{
		Effect Lock White Sphere Radius: 1.700
		Multi-Hero Mode Enabled: On
	}
}

variables
{
	global:
		0: CPLocations
		1: PioneerList
		2: CPAbilityCounts
		3: CPUltimateTeleportPrimary
		4: CPFacingDirections
		5: CPHeroList
		6: GameStarted
		7: PioneerTimer
		8: CurrentPioneer
		9: MultiHeroEnabled
		10: SkipTimeLimit
		11: InfiniteModeEnabledConstant
		12: AbilityCountsEnabledConstant
		13: PlayerScaleConstant
		14: PioneerTimeLimitConstant
		15: PlayerMoveSpeedConstant
		16: NonInfiniteModeWinTime
		17: PioneerMinDistanceConstant
		18: PunchGraceEnabled
		19: PrimaryFireUsefulForTheseHeros
		20: CPRadius
		21: SlamBuffEnabled
		22: HeroRoster
		23: CPGreenSphereArray
		24: GreenSphereRadiusConstant
		25: CPEffectLockSphereArray
		26: EffectLockSphereRadiusConstant
		27: DevModeEngaged

	player:
		0: CurrentCP
		2: MaxUnlockedCP
		4: CPAbilityCounts
		5: CountUltimateTeleportPrimary
		7: TeleportEnabled
		8: TimeSpentOnCP
		9: SpectateMode
		10: ForceRespawn
		11: BlockArriveNextPoint
		12: BlockPioneerNewPoint
		13: EffectLockObtained
		14: SlamTimer
		15: PunchFixStore
		16: GreenSphereLocation
		17: EffectLockSphereLocation
		18: WinstonBubbleLocation
		19: WinstonBouncyBubbleCooldown
		21: WinstonBubbleEffect
		22: TempVariable
		23: TempVariable2
		24: CancelPointTimer
		26: sigma_barrier_ready_to_destroy
		27: sigma_barrier_ON
		28: Grace
		34: Count360Slam125
		38: HeroSelectMenuOpen
		39: MenuInWorldLocationTempStore
		40: MenuTextIDTempStore
		41: TempIterator
}

subroutines
{
	0: RespawnPlayer
	2: CancelMomentum
	3: HandleSkipTimer
}

rule("Memory")
{
	event
	{
		Ongoing - Global;
	}
}

disabled rule("Initialization")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Initialize Globals")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		disabled Disable Inspector Recording;
		Pause Match Time;
		"These are the allowed heros for multi-hero mode"
		Global.HeroRoster = Array(Hero(Doomfist), Hero(Sigma), Hero(Genji), Hero(Winston), Hero(Wrecking Ball), Hero(Lúcio), Hero(Roadhog),
			Hero(Widowmaker), Hero(Junkrat));
		Global.CPRadius = Workshop Setting Real(Custom String("Game Constants"), Custom String("Checkpoint Radius (m)"), 2, 0, 20, 0);
		Global.MultiHeroEnabled = Workshop Setting Toggle(Custom String("Gameplay"), Custom String("Multi-Hero Mode Enabled"), False, 0);
		Global.NonInfiniteModeWinTime = Workshop Setting Integer(Custom String("Infinite Mode"), Custom String(
			"Time Limit Before Victory in Non-Infinite Mode"), 300, 90, 1200, 0);
		"Set up workshop toggle/int/real variables"
		Global.InfiniteModeEnabledConstant = Workshop Setting Toggle(Custom String("Infinite Mode"), Custom String(
			"Infinite Mode Enabled"), True, 0);
		Global.AbilityCountsEnabledConstant = Workshop Setting Toggle(Custom String("Pioneer Settings"), Custom String(
			"Ability Count Limits Enabled"), True, 0);
		Global.PlayerScaleConstant = Workshop Setting Real(Custom String("Gameplay"), Custom String(
			"Player Size (Tiny Doom = 0.1, Normal = 1, Massive Doom = 6)"), 1, 0.100, 6, 0);
		Global.PioneerTimeLimitConstant = Workshop Setting Integer(Custom String("Pioneer Settings"), Custom String(
			"Pioneer Time Limit in Seconds"), 180, 90, 600, 0);
		Global.PlayerMoveSpeedConstant = Workshop Setting Real(Custom String("Game Constants"), Custom String(
			"Player Move Speed Scale Factor"), 100, 10, 1000, 0);
		Global.PioneerMinDistanceConstant = 8;
		Global.SkipTimeLimit = Workshop Setting Integer(Custom String("Game Constants"), Custom String(
			"Time Before Player Can Skip Level"), 240, 60, 9999, 0);
		Global.PrimaryFireUsefulForTheseHeros = Array(Hero(Ana));
		Global.GameStarted = False;
		Global.PunchGraceEnabled = Workshop Setting Toggle(Custom String("Gameplay"), Custom String("Punch Grace Enabled"), True, 0);
		Global.SlamBuffEnabled = Workshop Setting Toggle(Custom String("Gameplay"), Custom String("Slam Buff Enabled (Slam resets bhop)"),
			False, 0);
		Global.GreenSphereRadiusConstant = Workshop Setting Real(Custom String("Game Constants"), Custom String("Green Sphere Radius"), 3,
			1, 5, 0);
		Global.EffectLockSphereRadiusConstant = Workshop Setting Real(Custom String("Game Constants"), Custom String(
			"Effect Lock (White) Sphere Radius"), 2, 1, 5, 0);
		Global.DevModeEngaged = False;
	}
}

rule("Global HUD")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Create HUD Text(Filtered Array(All Players(All Teams), Global.GameStarted == False), Custom String(
			"{0} Leave The Spawn and Press R to Create Origin Point!", Host Player), Null, Null, Top, 0, Color(Green), Color(White), Color(
			White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Global.GameStarted), Custom String(
			"Pioneer: {0}\r\nTime Remaining: {1}/{2}", Global.CurrentPioneer, Global.PioneerTimer, Global.PioneerTimeLimitConstant), Null,
			Null, Left, 0, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		"Controls HUD"
		Create HUD Text(Filtered Array(All Players(All Teams), Is Button Held(Current Array Element, Button(Interact))), Null, Null,
			Custom String(
			"-------------------------- Controls --------------------------\r\nQuick Reset: Reload\r\nPrev CP: Interact + Crouch\r\n{0}\r\n{1}\r\n{2}",
			Custom String("Teleport: Melee + Left Click\r\nView Next CP Location: Interact + Left Click"), Custom String(
			"Spectate Mode: Interact + Melee \r\nSkip Level (after {0}sec) Interact + Need Healing Voiceline", Global.SkipTimeLimit),
			Custom String("Switch Hero (Multi-Hero Mode Only): Interact + Ultimate Status Voiceline")), Left, 1, Color(White), Color(
			White), Color(White), Visible To and String, Default Visibility);
		"Game Settings HUD"
		disabled Create HUD Text(Filtered Array(All Players(All Teams), Is Button Held(Current Array Element, Button(Interact))), Null, Null,
			Custom String("--------------------------Game Settings--------------------------\r\n{0}\r\n{1}\r\n{2}", Custom String(
			"Infinite Mode Enabled: {0}\r\nMulti-Hero Enabled: {1}\r\nAbility Limits Enabled: {2}", Global.InfiniteModeEnabledConstant,
			Global.MultiHeroEnabled, Global.AbilityCountsEnabledConstant), Custom String(
			"Player Scale Constant: {0}\r\nPunch Grace Enabled: {1}\r\nPlayer Move Speed Constant: {2}", Global.PlayerScaleConstant,
			Global.PunchGraceEnabled, Global.PlayerMoveSpeedConstant), Custom String(
			"Pioneer Time Limit: {0}\r\nPlayer CP Skip Time Limit: {1}\r\n{2}", Global.PioneerTimeLimitConstant, Global.SkipTimeLimit,
			Custom String("CP Radius: {0}", Global.CPRadius))), Left, 2, Color(White), Color(White), Color(White), Visible To and String,
			Default Visibility);
		disabled Create HUD Text(Filtered Array(All Players(All Teams), !Is Button Held(Current Array Element, Button(Interact))), Null, Null,
			Custom String("Hold Interact Key ({0}) For Controls / Game Settings", Input Binding String(Button(Interact))), Left, 1, Color(
			White), Color(White), Color(White), Visible To and String, Default Visibility);
	}
}

rule("Initialize player")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Start Scaling Player(Event Player, Global.PlayerScaleConstant, False);
		"Punch grace from Hax framework"
		Chase Player Variable At Rate(Event Player, Grace, Is Firing Secondary(Event Player) ? 0.500 : False, Is Firing Secondary(
			Event Player) ? 0.260 : True, Destination and Rate);
		Event Player.CurrentCP = 0;
		Event Player.BlockArriveNextPoint = False;
		Set Status(Event Player, Null, Phased Out, 9999);
		Event Player.BlockPioneerNewPoint = False;
		Event Player.CancelPointTimer = 0;
		Event Player.TeleportEnabled = True;
		Enable Death Spectate All Players(Event Player);
		Enable Death Spectate Target HUD(Event Player);
		Disable Game Mode In-World UI(Event Player);
		Disable Game Mode HUD(Event Player);
		Event Player.TimeSpentOnCP = 0;
		If(Global.PlayerScaleConstant < 0.700);
			Start Modifying Hero Voice Lines(Event Player, 4, False);
		Else If(Global.PlayerScaleConstant > 1.500);
			Start Modifying Hero Voice Lines(Event Player, 0.650, False);
		End;
		"Create Ring, Text and Icon Effects"
		Create Effect(Event Player, Ring, Color(White), Global.CPLocations[Event Player.CurrentCP], Global.CPRadius,
			Visible To Position and Radius);
		Create Effect(Filtered Array(Event Player, Count Of(Global.CPLocations) > Current Array Element.CurrentCP + 1), Ring, Color(
			Purple), Global.CPLocations[Event Player.CurrentCP + 1], Global.CPRadius, Visible To Position and Radius);
		Create In-World Text(Filtered Array(Event Player, Count Of(Global.CPLocations) > Current Array Element.CurrentCP + 1),
			Custom String("Come Here\r\nPioneer: {0}", Global.PioneerList[Event Player.CurrentCP + 1]),
			Global.CPLocations[Event Player.CurrentCP + 1], 1.300, Do Not Clip, Visible To Position and String, Color(Yellow),
			Default Visibility);
		Create Icon(Filtered Array(Event Player, Count Of(Global.CPLocations) > Event Player.CurrentCP + 1),
			Global.CPLocations[Event Player.CurrentCP + 1], Flag, Visible To and Position, Color(Yellow), True);
	}
}

rule("Player HUD")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Create HUD Text(Filtered Array(Event Player, Global.GameStarted), Null, Null, Custom String(
			"Checkpoint {0}/{1} - Time Spent On CP {2}", Event Player.CurrentCP, Count Of(Global.CPLocations) - 1,
			Event Player.TimeSpentOnCP), Top, 0, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} - {1}", Event Player, Event Player.CurrentCP), Right,
			100 - Event Player.CurrentCP, Color(White), Color(White), Color(Green), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(Event Player, Global.AbilityCountsEnabledConstant && Event Player.CurrentCP + 1 < Count Of(
			Global.CPLocations)), Custom String("Checkpoint Abilty Limits\r\n{0} {1} {2}", Custom String("{0} {1}", Ability Icon String(
			Hero Of(Event Player), Button(Secondary Fire)), X Component Of(Global.CPAbilityCounts[Event Player.CurrentCP])
			- X Component Of(Event Player.CPAbilityCounts)), Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(
			Ability 1)), Y Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]) - Y Component Of(Event Player.CPAbilityCounts)),
			Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Ability 2)), Z Component Of(
			Global.CPAbilityCounts[Event Player.CurrentCP]) - Z Component Of(Event Player.CPAbilityCounts))), Null, Null, Top, -1.400,
			Color(Blue), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(Event Player, Event Player.TimeSpentOnCP > Global.SkipTimeLimit), Custom String(
			"Have spent more than {0} sec on this CP.\r\nUse Interact + Need Healing Voiceline to skip CP.", Global.SkipTimeLimit), Null,
			Null, Right, 0, Color(Red), Color(White), Color(White), Visible To and String, Default Visibility);
		"Game Settings HUD"
		Create HUD Text(Filtered Array(Event Player, Is Button Held(Current Array Element, Button(Interact))), Null, Null, Custom String(
			"--------------------------Game Settings--------------------------\r\n{0}\r\n{1}\r\n{2}", Custom String(
			"Infinite Mode Enabled: {0}\r\nMulti-Hero Enabled: {1}\r\nAbility Limits Enabled: {2}", Global.InfiniteModeEnabledConstant,
			Global.MultiHeroEnabled, Global.AbilityCountsEnabledConstant), Custom String(
			"Player Scale Constant: {0}\r\nPunch Grace Enabled: {1}\r\nPlayer Move Speed Constant: {2}", Global.PlayerScaleConstant,
			Global.PunchGraceEnabled, Global.PlayerMoveSpeedConstant), Custom String(
			"Pioneer Time Limit: {0}\r\nPlayer CP Skip Time Limit: {1}\r\n{2}", Global.PioneerTimeLimitConstant, Global.SkipTimeLimit,
			Custom String("CP Radius: {0}", Global.CPRadius))), Left, 2, Color(White), Color(White), Color(White), Visible To and String,
			Default Visibility);
		Create HUD Text(Filtered Array(Event Player, !Is Button Held(Current Array Element, Button(Interact))), Null, Null, Custom String(
			"Hold Interact Key ({0}) For Controls / Game Settings", Input Binding String(Button(Interact))), Left, 1, Color(White), Color(
			White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(Event Player, Count Of(Global.CPLocations)
			== Event Player.CurrentCP + 1 && Global.MultiHeroEnabled), Custom String("Change Hero With Interact + Ultimate Status"), Null,
			Null, Right, 0, Color(Red), Color(White), Color(White), Visible To and String, Default Visibility);
		"Green Sphere Create"
		Create Effect(Filtered Array(Event Player, Global.CPGreenSphereArray[Current Array Element.CurrentCP] != Null), Sphere, Color(
			Green), Global.CPGreenSphereArray[Event Player.CurrentCP], Global.GreenSphereRadiusConstant, Visible To Position and Radius);
		"Green Sphere Create Pioneer Only"
		Create Effect(Filtered Array(Event Player, Current Array Element.GreenSphereLocation != Null), Sphere, Color(Green),
			Event Player.GreenSphereLocation, Global.GreenSphereRadiusConstant, Visible To Position and Radius);
		"Effect Lock Sphere Create Non-Pioneer"
		Create Effect(Filtered Array(Event Player,
			Global.CPEffectLockSphereArray[Current Array Element.CurrentCP] != Null && !Current Array Element.EffectLockObtained), Sphere,
			Color(White), Global.CPEffectLockSphereArray[Event Player.CurrentCP], Global.EffectLockSphereRadiusConstant,
			Visible To Position and Radius);
		"Effect Lock Sphere Create Pioneer Only"
		Create Effect(Filtered Array(Event Player, Current Array Element.EffectLockSphereLocation != Null), Sphere, Color(White),
			Event Player.EffectLockSphereLocation, Global.EffectLockSphereRadiusConstant, Visible To Position and Radius);
		Create HUD Text(Filtered Array(Event Player, (
			Global.CPEffectLockSphereArray[Current Array Element.CurrentCP] != Null && Current Array Element.EffectLockObtained != True && True)
			== True), Custom String("Effect Lock Required!"), Null, Null, Top, 0, Color(Red), Color(White), Color(White), Visible To,
			Default Visibility);
		"Effect Lock Flag Icon Create Non-Pioneer"
		Create Icon(Filtered Array(Event Player,
			Global.CPEffectLockSphereArray[Current Array Element.CurrentCP] != Null && !Current Array Element.EffectLockObtained),
			Global.CPEffectLockSphereArray[Event Player.CurrentCP], Flag, Visible To and Position, Color(Yellow), True);
		Create In-World Text(Filtered Array(Event Player,
			Global.CPEffectLockSphereArray[Current Array Element.CurrentCP] != Null && !Current Array Element.EffectLockObtained),
			Custom String("Effect Lock"), Global.CPEffectLockSphereArray[Event Player.CurrentCP], 1.300, Do Not Clip,
			Visible To and Position, Color(Yellow), Default Visibility);
	}
}

disabled rule("Game Framework")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Create Origin Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player == Host Player;
		Global.GameStarted == False;
		Is On Ground(Event Player) == True;
		Has Spawned(Event Player) == True;
		Is Button Held(Event Player, Button(Reload)) == True;
	}

	actions
	{
		Small Message(All Players(All Teams), Custom String("Creating origin point"));
		Global.CPLocations = Array(Position Of(Event Player));
		Global.CPAbilityCounts = Empty Array;
		Global.CPUltimateTeleportPrimary = Empty Array;
		Global.CPFacingDirections = Empty Array;
		Global.PioneerList = Array(Custom String("{0}", Event Player));
		Global.CurrentPioneer = Event Player;
		Global.GameStarted = True;
		Global.CPHeroList = Array();
		Global.CPGreenSphereArray = Empty Array;
		Global.CPEffectLockSphereArray = Empty Array;
	}
}

rule("Game Started (origin point just created by host) - Create World Effects")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.GameStarted == True;
	}

	actions
	{
		"Restart player at origin point after it's created and start timer"
		Call Subroutine(RespawnPlayer);
		Call Subroutine(HandleSkipTimer);
	}
}

rule("Pioneer Create Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Is On Ground(Event Player) == True;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius;
		Distance Between(Global.CPLocations[Event Player.CurrentCP + 1], Position Of(Event Player)) <= Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
		Event Player.BlockPioneerNewPoint == False;
		"Can't pioneer in spectate mode"
		Event Player.SpectateMode == False;
		"Punch grace from Hax framework"
		(!Global.PunchGraceEnabled || Is Firing Secondary(Event Player) || Event Player.Grace < 0.120) == True;
		"Slam Buff"
		!(Global.SlamBuffEnabled && Is Using Ability 2(Event Player) && True) == True;
	}

	actions
	{
		"Make sure they pioneered far enough"
		If(Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentCP]) < Global.PioneerMinDistanceConstant);
			Small Message(Event Player, Custom String("Pioneer more than {0}m!", Global.PioneerMinDistanceConstant));
			Call Subroutine(RespawnPlayer);
			Abort;
		End;
		Event Player.TempVariable2 = Position Of(Event Player);
		Set Move Speed(Event Player, 0);
		Call Subroutine(CancelMomentum);
		"Allow player 3 sec to cancel the CP"
		Event Player.CancelPointTimer = 3;
		Chase Player Variable At Rate(Event Player, CancelPointTimer, 0, 1, Destination and Rate);
		Big Message(Event Player, Custom String("Press R within 3 sec to cancel checkpoint"));
		While(Event Player.CancelPointTimer > 0 && True);
			Wait(0.016, Ignore Condition);
			If(Is Button Held(Event Player, Button(Reload)));
				Call Subroutine(RespawnPlayer);
				Abort;
			End;
		End;
		"Force all players waiting for pioneer to respawn - otherwise they could be standing on top of the next CP"
		disabled Filtered Array(All Players(All Teams), Current Array Element == Event Player && Count Of(Global.CPLocations)
			== Event Player.CurrentCP + 1).ForceRespawn = True;
		"Hopefully tempvariable doesn't conflict with \"Pioneer runs out of time\" rule"
		For Player Variable(Event Player, TempVariable, 0, Count Of(All Living Players(All Teams)), 1);
			If(All Living Players(All Teams)[Event Player.TempVariable].CurrentCP == Count Of(Global.CPLocations) - 1);
				All Living Players(All Teams)[Event Player.TempVariable].ForceRespawn = True;
			End;
		End;
		"Create the next point"
		Event Player.BlockArriveNextPoint = True;
		Modify Global Variable(CPLocations, Append To Array, Event Player.TempVariable2);
		Modify Global Variable(PioneerList, Append To Array, Custom String("{0}", Event Player));
		Modify Global Variable(CPAbilityCounts, Append To Array, Event Player.CPAbilityCounts);
		Small Message(All Players(All Teams), Custom String("created point {0}", Event Player.CPAbilityCounts));
		Modify Global Variable(CPUltimateTeleportPrimary, Append To Array, Event Player.CountUltimateTeleportPrimary);
		Modify Global Variable(CPHeroList, Append To Array, Hero Of(Event Player));
		Modify Global Variable(CPGreenSphereArray, Append To Array, Event Player.GreenSphereLocation);
		Modify Global Variable(CPEffectLockSphereArray, Append To Array, Event Player.EffectLockSphereLocation);
		Call Subroutine(RespawnPlayer);
		Event Player.BlockArriveNextPoint = False;
		Event Player.TimeSpentOnCP = 0;
		Chase Player Variable At Rate(Event Player, TimeSpentOnCP, 9999, 1, Destination and Rate);
		Global.CurrentPioneer = Null;
	}
}

rule("Non-Pioneer Respawn If Touch Ground Outside of current or next CP")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Is On Ground(Event Player) == True;
		Event Player.BlockArriveNextPoint == False;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius;
		Distance Between(Global.CPLocations[Event Player.CurrentCP + 1], Position Of(Event Player)) > Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
		"Punch grace from Hax framework"
		(!Global.PunchGraceEnabled || Is Firing Secondary(Event Player) || Event Player.Grace < 0.120) == True;
		"Slam Buff"
		!(Global.SlamBuffEnabled && Is Using Ability 2(Event Player) && True) == True;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Non-Pioneer Arrive At CP")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Is On Ground(Event Player) == True;
		Event Player.BlockArriveNextPoint == False;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius;
		Distance Between(Global.CPLocations[Event Player.CurrentCP + 1], Position Of(Event Player)) <= Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
		Count Of(Global.CPLocations) > Event Player.CurrentCP + 1;
	}

	actions
	{
		"Check if player got effect lock obtained, if they haven't respawn them"
		If(Global.CPEffectLockSphereArray[Event Player.CurrentCP] != Null && Event Player.EffectLockObtained != True);
			Small Message(Event Player, Custom String("Checkpoint requires you to get the effect lock!"));
			Call Subroutine(RespawnPlayer);
			Abort;
		End;
		Play Effect(Event Player, Buff Impact Sound, Color(White), Event Player, 60);
		Event Player.CurrentCP += 1;
		Event Player.MaxUnlockedCP = Max(Event Player.MaxUnlockedCP, Event Player.CurrentCP);
		If(Count Of(Global.CPLocations) == Event Player.CurrentCP + 1);
			If(Global.CurrentPioneer == Null);
				"So you can't pioneer your own point unless you are the only player alive (aka not spectating)"
				If(Count Of(All Living Players(All Teams)) == 1 || Last Of(Global.PioneerList) != Custom String("{0}", Event Player));
					Big Message(Event Player, Custom String("You are pioneer! Use your skills to make the next checkpoint!"));
					Global.CurrentPioneer = Event Player;
				End;
			End;
		End;
		Call Subroutine(HandleSkipTimer);
		Call Subroutine(RespawnPlayer);
	}
}

rule("If player joins after origin point created, start them at origin point")
{
	event
	{
		Player Joined Match;
		All;
		All;
	}

	conditions
	{
		Global.GameStarted == True;
	}

	actions
	{
		Wait(0.100, Ignore Condition);
		Loop If(!Has Spawned(Event Player));
		Wait(0.100, Ignore Condition);
		Call Subroutine(HandleSkipTimer);
		Call Subroutine(RespawnPlayer);
	}
}

rule("Handle ForceRespawn")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.ForceRespawn == True;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
		Event Player.ForceRespawn = False;
	}
}

rule("Start Pioneer Timer and set Invisible when player becomes pioneer")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Global.PioneerTimer = Global.PioneerTimeLimitConstant;
		Chase Global Variable At Rate(PioneerTimer, 0, 1, Destination and Rate);
		Set Invisible(Event Player, All);
		Disallow Button(Event Player, Button(Melee));
	}
}

rule("Set Non-Pioneer Visible")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Set Invisible(Event Player, None);
		Allow Button(Event Player, Button(Melee));
	}
}

rule("Pioneer runs out of time")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.PioneerTimer == 0;
		Has Spawned(Event Player) == True;
		Global.CurrentPioneer == Event Player;
	}

	actions
	{
		"To prevent this rule from conflicting with the \"start pioneer timer\" rule"
		Wait(4, Abort When False);
		"Is there a player on final checkpoint waiting for pioneer"
		If(Count Of(Filtered Array(All Players(All Teams), Global.CurrentPioneer != Current Array Element && Count Of(Global.CPLocations)
			== Current Array Element.CurrentCP + 1)) > 0);
			Event Player.TempVariable = Random Value In Array(Filtered Array(All Players(All Teams),
				Global.CurrentPioneer != Current Array Element && Count Of(Global.CPLocations) == Current Array Element.CurrentCP + 1));
			Global.PioneerTimer = Global.PioneerTimeLimitConstant;
			Event Player.TempVariable.ForceRespawn = True;
			Global.CurrentPioneer = Event Player.TempVariable;
			Wait(0.100, Ignore Condition);
			Big Message(All Players(All Teams), Custom String("Pioneer ran out of time. Pioneer passed to {0}", Global.CurrentPioneer));
		Else;
			Global.PioneerTimer = Global.PioneerTimeLimitConstant;
			Big Message(All Players(All Teams), Custom String("No one to pass pioneer to"));
		End;
	}
}

rule("Set Pioneer Timer to Zero if there isn't a pioneer")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.CurrentPioneer == Null;
	}

	actions
	{
		Global.PioneerTimer = 0;
	}
}

disabled rule("Other Features / Key Bindings")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Reload - Quick Reset")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Reload)) == True;
		Is On Ground(Event Player) != True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
		"So player can't R and get teleported outside map before origin point is selected"
		Global.GameStarted == True;
		"Quick Reset Disabled for Ana, so you can reload - modify the array here for additional disable"
		Index Of Array Value(Global.PrimaryFireUsefulForTheseHeros, Hero Of(Event Player)) < 0;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Crouch + Interact - Move Back A Checkpoint")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		If(Global.CurrentPioneer == Event Player);
			Small Message(Event Player, Custom String("Can't move back a level while pioneer! Make a checkpoint!"));
			Abort;
		End;
		If(Event Player.CurrentCP > 0);
			Event Player.CurrentCP += -1;
		Else;
			"If on Checkpoint 0, go to greatest unlocked checkpoint on level"
			Event Player.CurrentCP = Event Player.MaxUnlockedCP;
		End;
		Call Subroutine(HandleSkipTimer);
		Event Player.BlockArriveNextPoint = True;
		Call Subroutine(RespawnPlayer);
		Event Player.BlockArriveNextPoint = False;
	}
}

rule("Interact + Left Click: Camera To See Next Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		"Make sure next point exists"
		Count Of(Global.CPLocations) > Event Player.CurrentCP + 1;
	}

	actions
	{
		Set Primary Fire Enabled(Event Player, False);
		Set Facing(Event Player, Vector(-10, -10, 0), To World);
		Start Camera(Event Player, Ray Cast Hit Position(Global.CPLocations[Event Player.CurrentCP + 1],
			Global.CPLocations[Event Player.CurrentCP + 1] + Facing Direction Of(Event Player) * -15, All Players(All Teams), Event Player,
			True), Global.CPLocations[Event Player.CurrentCP + 1], 30);
		While(Is Button Held(Event Player, Button(Primary Fire)) && Is Button Held(Event Player, Button(Interact)));
			Wait(0.033, Ignore Condition);
		End;
		Stop Camera(Event Player);
		Set Primary Fire Enabled(Event Player, True);
	}
}

rule("Interact + Jump -> Go Forward a Checkpoint")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		If(Global.CurrentPioneer == Event Player);
			Small Message(Event Player, Custom String("Can't change level while pioneer! Make a checkpoint!"));
			Abort;
		End;
		"If player is not on last CP"
		If(Event Player.CurrentCP < Event Player.MaxUnlockedCP);
			Event Player.CurrentCP += 1;
		Else;
			"If haven't unlocked next CP yet, go back to CP 0"
			Event Player.CurrentCP = 0;
		End;
		Call Subroutine(HandleSkipTimer);
		disabled Event Player.BlockArriveNextPoint = True;
		Call Subroutine(RespawnPlayer);
		disabled Event Player.BlockArriveNextPoint = False;
	}
}

rule("Interact + Melee : Spectate Other Players")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Melee)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
	}

	actions
	{
		Enable Death Spectate All Players(All Players(All Teams));
		If(Is Dead(Event Player));
			Enable Built-In Game Mode Respawning(Event Player);
			Resurrect(Event Player);
			Wait(0.100, Ignore Condition);
			Call Subroutine(RespawnPlayer);
			Event Player.SpectateMode = False;
		Else;
			Big Message(Event Player, Custom String("Use \"Interact + Melee\" to exit Spectate Mode!"));
			Event Player.SpectateMode = True;
			Disable Built-In Game Mode Respawning(Event Player);
			Kill(Event Player, Null);
		End;
		Set Status(Event Player, Null, Phased Out, 9999);
	}
}

rule("Melee + Left Click = Teleport")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Is Button Held(Event Player, Button(Melee)) == True;
		(Event Player.TeleportEnabled || Global.DevModeEngaged) == True;
	}

	actions
	{
		Teleport(Event Player, Ray Cast Hit Position(Position Of(Event Player), Position Of(Event Player) + Facing Direction Of(
			Event Player) * 60, All Players(All Teams), Event Player, True));
		Event Player.CountUltimateTeleportPrimary += Up;
	}
}

rule("Interact + Need Healing Voiceline = Skip CP if you have spent enough time")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Communicating(Event Player, Need Healing) == True;
		Event Player.TimeSpentOnCP > Global.SkipTimeLimit;
	}

	actions
	{
		Event Player.BlockArriveNextPoint = True;
		Event Player.CurrentCP += 1;
		Event Player.MaxUnlockedCP = Event Player.CurrentCP;
		Call Subroutine(RespawnPlayer);
		"Allow player to pioneer using CP skip"
		If(Count Of(Global.CPLocations) == Event Player.CurrentCP + 1);
			If(Global.CurrentPioneer == Null);
				Big Message(Event Player, Custom String("You are pioneer! Use your skills to make the next checkpoint!"));
				Global.CurrentPioneer = Event Player;
			End;
		End;
		Call Subroutine(HandleSkipTimer);
		Event Player.BlockArriveNextPoint = False;
	}
}

rule("Interact + Group Up Voiceline = Dev Mode Engaged")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player == Host Player;
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Communicating(Event Player, Group Up) == True;
	}

	actions
	{
		If(Global.DevModeEngaged);
			Small Message(All Players(All Teams), Custom String("Dev Mode Disengaged"));
			Global.DevModeEngaged = False;
		Else;
			Small Message(All Players(All Teams), Custom String("Dev Mode Engaged"));
			Global.DevModeEngaged = True;
		End;
	}
}

rule("Interact + Ultimate Status Voiceline = Pioneer can switch hero")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		disabled Is Button Held(Event Player, Button(Jump)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
		"Is pioneer or is waiting for pioneer"
		(Global.CurrentPioneer == Event Player || Count Of(Global.CPLocations) == Event Player.CurrentCP + 1) == True;
		Global.MultiHeroEnabled == True;
		Is Communicating(Event Player, Ultimate Status) == True;
	}

	actions
	{
		"If a menu is already open, delete the in world text and recreate the menu in the proper location"
		If(Event Player.HeroSelectMenuOpen);
			For Player Variable(Event Player, TempIterator, 0, Count Of(Event Player.MenuTextIDTempStore), 1);
				Destroy In-World Text(Event Player.MenuTextIDTempStore[Event Player.TempIterator]);
				Abort;
			End;
		End;
		Event Player.MenuInWorldLocationTempStore = Empty Array;
		Event Player.MenuTextIDTempStore = Empty Array;
		For Player Variable(Event Player, TempIterator, 0, Count Of(Global.HeroRoster), 1);
			Modify Player Variable(Event Player, MenuInWorldLocationTempStore, Append To Array, Eye Position(Event Player)
				+ Facing Direction Of(Event Player) * 1 + 0.400 * World Vector Of(Vector(Sine From Degrees(360 * (
				Event Player.TempIterator / Count Of(Global.HeroRoster))), Cosine From Degrees(360 * (Event Player.TempIterator / Count Of(
				Global.HeroRoster))), 0), Event Player, Rotation));
			Create In-World Text(Event Player, Custom String("{0}", Hero Icon String(Global.HeroRoster[Event Player.TempIterator])),
				Event Player.MenuInWorldLocationTempStore[Event Player.TempIterator] + Vector(0, -0.100, 0), 3, Do Not Clip, None, Color(
				White), Default Visibility);
			Modify Player Variable(Event Player, MenuTextIDTempStore, Append To Array, Last Text ID);
			Wait(0.016, Ignore Condition);
		End;
		Event Player.HeroSelectMenuOpen = True;
		Big Message(Event Player, Custom String("Release Interact Over The Hero You Want To Select"));
	}
}

rule("Close Hero Select Menu")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == False;
		Has Spawned(Event Player) == True;
		Event Player.HeroSelectMenuOpen == True;
	}

	actions
	{
		Start Forcing Player To Be Hero(Event Player, Global.HeroRoster[Index Of Array Value(Event Player.MenuInWorldLocationTempStore,
			First Of(Sorted Array(Event Player.MenuInWorldLocationTempStore, Angle Between Vectors(Facing Direction Of(Event Player),
			Direction Towards(Eye Position(Event Player), Current Array Element)))))]);
		For Player Variable(Event Player, TempIterator, 0, Count Of(Event Player.MenuTextIDTempStore), 1);
			Destroy In-World Text(Event Player.MenuTextIDTempStore[Event Player.TempIterator]);
		End;
		Event Player.HeroSelectMenuOpen = False;
	}
}

disabled rule("Handle Ability Counts")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Handle Ability Count Limits (if enabled)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Is Using Ability 1(Event Player) || Is Using Ability 2(Event Player) || Is Firing Secondary(Event Player)) == True;
		"Inside a level, not in multilevel portionIs NOT on last checkpoint of the level"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations);
		Global.AbilityCountsEnabledConstant == True;
	}

	actions
	{
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
		If(Y Component Of(Event Player.CPAbilityCounts) >= Y Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]));
			Set Ability 1 Enabled(Event Player, False);
		End;
		If(Z Component Of(Event Player.CPAbilityCounts) >= Z Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]));
			Set Ability 2 Enabled(Event Player, False);
		End;
		If(X Component Of(Event Player.CPAbilityCounts) >= X Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]));
			"Have to wait to disable punch because otherwise it would disable immediately after using preventing punch from working properly."
			Wait(0.400, Ignore Condition);
			"This is to fix interaction with the Quick Reset (R) right after using punch, so this doesn't disable punch after you respawn. Can have slight bug where player is punching through the start location, and doesn't set cooldown properly."
			Abort If(True && Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentCP]) < Global.CPRadius);
			Set Secondary Fire Enabled(Event Player, False);
		End;
	}
}

rule("Used Ultimate")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		"Don't trigger if player has complete point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.CountUltimateTeleportPrimary += Left;
	}
}

rule("Used Secondary (Rocket Punch)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
		"Don't trigger if player has complete point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.CPAbilityCounts += Left;
	}
}

rule("Used Ability 1 (Uppercut)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
		"Don't trigger if player has complete point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.CPAbilityCounts += Up;
	}
}

rule("Used Ability 2 - NON DOOMFIST")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		Event Player.CancelPointTimer == 0;
		Hero Of(Event Player) != Hero(Doomfist);
	}

	actions
	{
		Event Player.CPAbilityCounts += Forward;
	}
}

rule("Used Ability 2 - Start Slam Timer")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		"Don't trigger if player has complete point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.SlamTimer = 0;
		Chase Player Variable At Rate(Event Player, SlamTimer, 99, 1, Destination and Rate);
	}
}

rule("Used Ability 2 + 125 Slam Detector")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == False;
		Has Spawned(Event Player) == True;
		"To stop this rule from double triggering"
		Event Player.SlamTimer > 0;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, SlamTimer);
		"Prevent invalid slam (where press slam button but you are not allowed to slam) from counting as a slam. Matters for ability count limits."
		disabled If(Is On Ground(Event Player) || Event Player.SlamTimer >= 0.250);
		disabled Event Player.CPAbilityCounts += Forward;
		disabled End;
		"Detect 125 slam. Formula is Slam Damage = 100 * (Slam Time) - 28, so 125 slam requires at least 1.53 sec of slam time."
		disabled If(Event Player.SlamTimer >= 1.520);
		disabled Event Player.Count360Slam125 += Up;
		disabled Small Message(Event Player, Custom String("125 Slam"));
		disabled Play Effect(Event Player, Buff Impact Sound, Color(White), Event Player, 60);
		disabled End;
		Event Player.SlamTimer = 0;
	}
}

rule("Increment Slam Counter")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		"Prevents invalid slam (where player presses slam button but can't slam) from being counted"
		((Is On Ground(Event Player) && Event Player.SlamTimer > 0.040 && Event Player.SlamTimer < 0.250) || (
			Event Player.SlamTimer > 0.250)) == True;
		Has Spawned(Event Player) == True;
		Is Using Ability 2(Event Player) == True;
		disabled Event Player.SlamTimer > 0.250;
		"Don't trigger if player has complete point"
		disabled Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.CPAbilityCounts += Forward;
		If(Is On Ground(Event Player));
			Stop Chasing Player Variable(Event Player, SlamTimer);
			Event Player.SlamTimer = 0;
		End;
	}
}

rule("125 Slam Detection")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		"Actual time is 1.53 for 125 slam + cancel, but removing cancel ~.3 sec"
		Event Player.SlamTimer >= 1.220;
		Is Using Ability 2(Event Player) == True;
		"To prevent player from just holding down slam at invalid slam angle to get a 125 slam"
		Is Button Held(Event Player, Button(Ability 2)) == False;
	}

	actions
	{
		Event Player.Count360Slam125 += Up;
		Small Message(Event Player, Custom String("125 Slam"));
		Play Effect(Event Player, Buff Impact Sound, Color(White), Event Player, 60);
	}
}

disabled rule("Handle Edge Cases")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Reset Cooldowns If In Starting CP Ring")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) < Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		"if u charge punch, then jump and land in circle, it takes your punch away "
		disabled Event Player.CPAbilityCounts = Vector(0, 0, 0);
		Event Player.CountUltimateTeleportPrimary = Vector(0, 0, 0);
	}
}

rule("Declare Winner If Not Infinite Mode")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.InfiniteModeEnabledConstant == False;
		Count Of(Global.CPLocations) > 30;
	}

	actions
	{
		Wait(1, Ignore Condition);
		Declare Player Victory(Global.CurrentPioneer);
	}
}

rule("Handle Player Death")
{
	event
	{
		Player Died;
		All;
		All;
	}

	conditions
	{
		Event Player.SpectateMode != True;
	}

	actions
	{
		Event Player.BlockPioneerNewPoint = True;
		"In case you die during 3 seconds after pioneering"
		If(Event Player.CancelPointTimer > 0);
			Wait(3, Ignore Condition);
		End;
		Respawn(Event Player);
		Wait(0.100, Ignore Condition);
		If(Global.GameStarted);
			Call Subroutine(RespawnPlayer);
			Wait(0.100, Ignore Condition);
		End;
		Clear Status(Event Player, Phased Out);
		Set Status(Event Player, Null, Phased Out, 9999);
		Event Player.BlockPioneerNewPoint = False;
	}
}

rule("Pioneer Save CP Facing Direction when leaving the CP")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Global.CPFacingDirections[Event Player.CurrentCP] = Facing Direction Of(Event Player);
	}
}

rule("Pioneer Left Match")
{
	event
	{
		Player Left Match;
		All;
		All;
	}

	actions
	{
		If(Global.CurrentPioneer != Null);
			"Pioneer is not in game"
			If(Count Of(Filtered Array(All Players(All Teams), Current Array Element == Global.CurrentPioneer)) == 0);
				"Is there a player on final checkpoint waiting for pioneer"
				If(Count Of(Filtered Array(All Players(All Teams), True && Count Of(Global.CPLocations) == Current Array Element.CurrentCP + 1))
					> 0);
					Event Player.TempVariable = Random Value In Array(Filtered Array(All Players(All Teams), Count Of(Global.CPLocations)
						== Current Array Element.CurrentCP + 1));
					Big Message(All Players(All Teams), Custom String("Pioneer left match. Pioneer passed", Event Player.TempVariable));
					Global.PioneerTimer = Global.PioneerTimeLimitConstant;
					Event Player.TempVariable.ForceRespawn = True;
					Global.CurrentPioneer = Event Player.TempVariable;
				End;
			End;
		Else;
			If(Count Of(All Living Players(All Teams)) == 1);
				"Is there a player on final checkpoint waiting for pioneer"
				If(Count Of(Filtered Array(All Players(All Teams), True && Count Of(Global.CPLocations) == Current Array Element.CurrentCP + 1))
					> 0);
					Event Player.TempVariable = Random Value In Array(Filtered Array(All Players(All Teams), Count Of(Global.CPLocations)
						== Current Array Element.CurrentCP + 1));
					Big Message(All Players(All Teams), Custom String("Pioneer left match. Pioneer passed to {0}", Event Player.TempVariable));
					Global.PioneerTimer = Global.PioneerTimeLimitConstant;
					Event Player.TempVariable.ForceRespawn = True;
					Global.CurrentPioneer = Event Player.TempVariable;
				End;
			End;
		End;
	}
}

disabled rule("Subroutines")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Sub0: RespawnPlayer")
{
	event
	{
		Subroutine;
		RespawnPlayer;
	}

	actions
	{
		Stop Holding Button(Event Player, Button(Secondary Fire));
		Teleport(Event Player, Global.CPLocations[Event Player.CurrentCP]);
		Set Facing(Event Player, Global.CPFacingDirections[Event Player.CurrentCP], To World);
		disabled If(Is Firing Secondary(Event Player));
		disabled Event Player.CPAbilityCounts = Vector(1, 0, 0);
		disabled End;
		"If player is not pioneer and is not waiting for pioneer"
		If(Count Of(Global.CPLocations) > Event Player.CurrentCP + 1);
			Start Forcing Player To Be Hero(Event Player, Global.CPHeroList[Event Player.CurrentCP]);
		End;
		"Sigma Barrier Reset"
		If(Hero Of(Event Player) == Hero(Sigma));
			If(Event Player.sigma_barrier_ready_to_destroy);
				Press Button(Event Player, Button(Secondary Fire));
			End;
			Event Player.sigma_barrier_ON = False;
			Event Player.sigma_barrier_ready_to_destroy = False;
		End;
		Event Player.PunchFixStore = Hero Of(Event Player) == Hero(Doomfist) && Is Button Held(Event Player, Button(Secondary Fire));
		Cancel Primary Action(Event Player);
		Call Subroutine(CancelMomentum);
		Event Player.CPAbilityCounts = Vector(0, 0, 0);
		Event Player.CountUltimateTeleportPrimary = Vector(0, 0, 0);
		"Added this to fix issue where if you pressed R while using slam, the slam cooldown wasn't reset"
		Wait(0.100, Ignore Condition);
		Stop Chasing Player Variable(Event Player, SlamTimer);
		Event Player.SlamTimer = 0;
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Set Ultimate Charge(Event Player, 100);
		Event Player.CancelPointTimer = 0;
		"If player is not pioneer, player is not waiting for pioneer"
		If(Count Of(Global.CPLocations) > Event Player.CurrentCP + 1);
			If(X Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]) == 0);
				Set Secondary Fire Enabled(Event Player, False);
			Else;
				Set Secondary Fire Enabled(Event Player, True);
			End;
			If(Y Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]) == 0);
				Set Ability 1 Enabled(Event Player, False);
			Else;
				Set Ability 1 Enabled(Event Player, True);
			End;
			If(Z Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]) == 0);
				Set Ability 2 Enabled(Event Player, False);
			Else;
				Set Ability 2 Enabled(Event Player, True);
			End;
			If(X Component Of(Global.CPUltimateTeleportPrimary[Event Player.CurrentCP]) == 0);
				Set Ultimate Ability Enabled(Event Player, False);
			Else;
				Set Ultimate Ability Enabled(Event Player, True);
			End;
			If(Y Component Of(Global.CPUltimateTeleportPrimary[Event Player.CurrentCP]) == 0);
				Event Player.TeleportEnabled = False;
			Else;
				Event Player.TeleportEnabled = True;
				If(Event Player.CurrentCP > 0);
					Big Message(Event Player, Custom String("Teleport enabled for this point! Use Left Click + Melee to teleport!"));
				End;
			End;
			If(Index Of Array Value(Global.PrimaryFireUsefulForTheseHeros, Hero Of(Event Player)) >= 0);
				If(Z Component Of(Global.CPUltimateTeleportPrimary[Event Player.CurrentCP]) == 0);
					Set Primary Fire Enabled(Event Player, False);
				Else;
					Set Primary Fire Enabled(Event Player, True);
				End;
			End;
		"Is beginning of match, or player is pioneer, or player is waiting for pioneer"
		Else;
			Set Secondary Fire Enabled(Event Player, True);
			Set Ability 1 Enabled(Event Player, True);
			Set Ability 2 Enabled(Event Player, True);
			Event Player.TeleportEnabled = True;
			Set Ultimate Ability Enabled(Event Player, True);
			Set Primary Fire Enabled(Event Player, True);
		End;
		Event Player.WinstonBouncyBubbleCooldown = 0;
		Destroy Effect(Event Player.WinstonBubbleEffect);
		Event Player.WinstonBubbleLocation = Null;
		"Should Fix Phased Out Status issue"
		Clear Status(Event Player, Phased Out);
		Set Status(Event Player, Null, Phased Out, 9999);
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		"Set to (0,0,0) without creating new object"
		Event Player.Count360Slam125 -= Event Player.Count360Slam125;
		disabled Event Player.Count360Slam125 = Vector(0, 0, 0);
		Set Move Speed(Event Player, Global.PlayerMoveSpeedConstant);
		If(Event Player.PunchFixStore);
			Start Holding Button(Event Player, Button(Secondary Fire));
		End;
		Enable Movement Collision With Environment(Event Player);
		Event Player.GreenSphereLocation = Null;
		Event Player.EffectLockSphereLocation = Null;
		Event Player.EffectLockObtained = False;
		"Sigma Barrier Reset"
		If(Hero Of(Event Player) == Hero(Junkrat));
			Set Ability Charge(Event Player, Button(Ability 1), 2);
		End;
	}
}

rule("Sub2: CancelMomentum")
{
	event
	{
		Subroutine;
		CancelMomentum;
	}

	actions
	{
		Apply Impulse(Event Player, Up, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Down, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Left, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Right, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Forward, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Backward, 0.001, To World, Cancel Contrary Motion);
	}
}

rule("Sub3: HandleSkipTimer")
{
	event
	{
		Subroutine;
		HandleSkipTimer;
	}

	actions
	{
		"If Player is pioneer or waiting for pioneer"
		If(Count Of(Global.CPLocations) == Event Player.CurrentCP + 1 || False);
			Stop Chasing Player Variable(Event Player, TimeSpentOnCP);
			Event Player.TimeSpentOnCP = 0;
		Else;
			Event Player.TimeSpentOnCP = 0;
			Chase Player Variable At Rate(Event Player, TimeSpentOnCP, 9999, 1, Destination and Rate);
		End;
	}
}

rule("Punch Grace")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.Grace = 0.119;
	}
}

disabled rule("Pioneer Effect Lock And Environment Collision Spheres")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Pioneer Create Green Sphere with Melee")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		disabled Is Communicating(Event Player, Need Healing) == True;
		disabled Is In Air(Event Player) == True;
		Is Button Held(Event Player, Button(Crouch)) == True;
	}

	actions
	{
		disabled Event Player.GreenSphereLocation = Eye Position(Event Player);
		Event Player.GreenSphereLocation = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 12, Null, Event Player, True);
	}
}

rule("Green Sphere Rule (Pioneer Only) - In Sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Event Player.GreenSphereLocation != Null;
		Distance Between(Eye Position(Event Player), Event Player.GreenSphereLocation) < Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Disable Movement Collision With Environment(Event Player, False);
	}
}

rule("Green Sphere Rule (Pioneer Only) - Outside Sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Event Player.GreenSphereLocation != Null;
		Distance Between(Eye Position(Event Player), Event Player.GreenSphereLocation) > Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Wait(0.250, Ignore Condition);
		Enable Movement Collision With Environment(Event Player);
	}
}

rule("Green Sphere Rule (Non-Pioneer) - In Sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Global.CPGreenSphereArray[Event Player.CurrentCP] != Null;
		Distance Between(Eye Position(Event Player), Global.CPGreenSphereArray[Event Player.CurrentCP]) < Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Disable Movement Collision With Environment(Event Player, False);
	}
}

rule("Green Sphere Rule (Non-Pioneer) - Outside Sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Global.CPGreenSphereArray[Event Player.CurrentCP] != Null;
		Distance Between(Eye Position(Event Player), Global.CPGreenSphereArray[Event Player.CurrentCP]) > Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Wait(0.250, Ignore Condition);
		Enable Movement Collision With Environment(Event Player);
	}
}

rule("Pioneer Create Effect Lock Sphere with Group Up Voiceline")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		disabled Is Communicating(Event Player, Group Up) == True;
		Is Button Held(Event Player, Button(Melee)) == True;
	}

	actions
	{
		Event Player.EffectLockSphereLocation = Eye Position(Event Player);
		Small Message(Event Player, Custom String("Effect Lock Sphere Created!"));
		Play Effect(Event Player, Ring Explosion Sound, Color(White), Event Player, 60);
	}
}

rule("Obtain Effect Lock Sphere (Non-Pioneer)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Global.CPEffectLockSphereArray[Event Player.CurrentCP] != Null;
		Distance Between(Eye Position(Event Player), Global.CPEffectLockSphereArray[Event Player.CurrentCP])
			< Global.EffectLockSphereRadiusConstant;
		Event Player.EffectLockObtained != True;
	}

	actions
	{
		Event Player.EffectLockObtained = True;
		Play Effect(Event Player, Ring Explosion Sound, Color(White), Event Player, 60);
		Small Message(Event Player, Custom String("Effect Lock Obtained!"));
	}
}