settings
{
	main
	{
		Description: "Doomfist Pioneering Parkour - Special Edition. Incudes tons of modifiers, to change gameplay and pioneer parameters, host can go to Lobby -> Settings -> Workshop Settings. Made by WelkinTern, Last Updated: Dec 28, 2020. Code Commit History: https://github.com/WelkinU/OverwatchWorkshopScripts/blob/master/DoomfistPioneerParkour/DoomPioneerParkourSingleLevel.txt"
	}

	lobby
	{
		Max Team 1 Players: 12
		Max Team 2 Players: 0
	}

	modes
	{
		Skirmish
		{
			enabled maps
			{
				Blizzard World Winter
				Dorado
				Eichenwalde
				Eichenwalde Halloween
				Hanamura Winter
				Hollywood
				Ilios
				Junkertown
				King's Row Winter
				Lijiang Tower
				Nepal
				Rialto
			}
		}

		General
		{
			Hero Limit: Off
			Kill Feed: Off
		}
	}

	heroes
	{
		General
		{
			Ultimate Generation - Passive: 0%

			Ana
			{
				Ammunition Clip Size Scalar: 25%
				Biotic Grenade Cooldown Time: 60%
				Sleep Dart Cooldown Time: 75%
			}

			Baptiste
			{
				Immortality Field Cooldown Time: 70%
				Regenerative Burst Cooldown Time: 70%
			}

			D.Va
			{
				Spawn With Ultimate Ready: On
			}

			Doomfist
			{
				Seismic Slam Cooldown Time: 50%
			}

			Genji
			{
				Ammunition Clip Size Scalar: 25%
				Swift Strike Cooldown Time: 75%
				Ultimate Duration: 34%
			}

			Roadhog
			{
				Ammunition Clip Size Scalar: 40%
				Chain Hook Cooldown Time: 75%
				Take a Breather Cooldown Time: 75%
			}

			Sigma
			{
				Accretion Cooldown Time: 60%
				Kinetic Grasp Cooldown Time: 20%
			}

			Widowmaker
			{
				Grappling Hook Cooldown Time: 0%
			}

			Winston
			{
				No Ammunition Requirement: On
				Ultimate Duration: 60%
			}

			enabled heroes
			{
				Doomfist
			}
		}
	}

	workshop
	{
		Multi-Hero Mode Enabled: On
	}
}

variables
{
	global:
		0: CPLocations
		1: PioneerList
		2: CPAbilityCounts
		3: CPUltimateTeleportPrimary
		4: CPFacingDirections
		5: CPHeroList
		6: GameStarted
		7: PioneerTimer
		8: CurrentPioneer
		9: MultiHeroEnabled
		10: SkipTimeLimit
		11: InfiniteModeEnabledConstant
		12: AbilityCountsEnabledConstant
		13: PlayerScaleConstant
		14: PioneerTimeLimitConstant
		15: PlayerMoveSpeedConstant
		16: NonInfiniteModeWinTime
		17: PioneerMinDistanceConstant
		18: PunchGraceEnabled
		19: PrimaryFireUsefulForTheseHeros
		20: CPRadius
		21: SlamBuffEnabled
		22: HeroRoster
		23: CPGreenSphereArray
		24: GreenSphereRadiusConstant
		25: CPEffectLockSphereArray
		26: EffectLockSphereRadiusConstant
		27: DevModeEngaged
		28: CPKillSphereArray
		29: UltimateAbilitiesEnabledConstant
		30: ReplaysEnabledConstant
		31: ReplayPioneerPositionArray
		32: ReplayPioneerFacingArray

	player:
		0: CurrentCP
		2: MaxUnlockedCP
		3: Invisible
		4: CPAbilityCounts
		5: CountUltimateTeleportPrimary
		6: FacingDirectionLeavingCP
		7: TeleportEnabled
		8: TimeSpentOnCP
		9: SpectateMode
		10: ForceRespawn
		11: BlockArriveNextPoint
		12: BlockPioneerNewPoint
		13: EffectLockObtained
		14: SlamTimer
		15: PunchFixStore
		16: GreenSphereLocation
		17: EffectLockSphereLocation
		18: KillSphereLocation
		19: ReplayPosition
		20: ReplayFacing
		22: TempVariable
		23: TempVariable2
		24: CancelPointTimer
		26: sigma_barrier_ready_to_destroy
		27: sigma_barrier_ON
		28: sigma_barrier_direction
		29: sigma_barrier_init_position
		30: sigma_barrier_chase
		31: sigma_barrier_position
		32: Grace
		33: WinstonLeapGrace
		34: Count360Slam125
		36: WinstonWallClimbEnabled
		37: WinstonWallClimbTimer
		38: WinstonBubbleLocation
		39: WinstonBouncyBubbleCooldown
		40: WinstonBubbleEffect
		41: HeroSelectMenuOpen
		42: MenuInWorldLocationTempStore
		43: MenuTextIDTempStore
		44: TempIterator
		45: AnaSleepDartTeleLocation
		46: RoadhogHookPosition
}

subroutines
{
	0: RespawnPlayer
	2: CancelMomentum
	3: HandleSkipTimer
	4: MemoryRecall
}

rule("--------MEMORY: PASTE VARIABLES HERE -------------------")
{
	event
	{
		Subroutine;
		MemoryRecall;
	}
}

disabled rule("Initialization")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Initialize Globals")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Disable Inspector Recording;
		Pause Match Time;
		"These are the allowed heros for multi-hero mode"
		Global.HeroRoster = Array(Hero(Doomfist), Hero(Sigma), Hero(Genji), Hero(Winston), Hero(Wrecking Ball), Hero(LÃºcio), Hero(Roadhog),
			Hero(Junkrat), Hero(Ana));
		Global.CPRadius = Workshop Setting Real(Custom String("Game Constants"), Custom String("Checkpoint Radius (m)"), 2, 0, 20, 0);
		Global.MultiHeroEnabled = Workshop Setting Toggle(Custom String("Gameplay"), Custom String("Multi-Hero Mode Enabled"), False, 0);
		Global.NonInfiniteModeWinTime = Workshop Setting Integer(Custom String("Infinite Mode"), Custom String(
			"Time Limit Before Victory in Non-Infinite Mode"), 300, 90, 1200, 0);
		"Set up workshop toggle/int/real variables"
		Global.InfiniteModeEnabledConstant = Workshop Setting Toggle(Custom String("Infinite Mode"), Custom String(
			"Infinite Mode Enabled"), True, 0);
		Global.AbilityCountsEnabledConstant = Workshop Setting Toggle(Custom String("Pioneer Settings"), Custom String(
			"Ability Count Limits Enabled"), True, 0);
		Global.PlayerScaleConstant = Workshop Setting Real(Custom String("Gameplay"), Custom String(
			"Player Size (Tiny Doom = 0.1, Normal = 1, Massive Doom = 6)"), 1, 0.100, 6, 0);
		Global.PioneerTimeLimitConstant = Workshop Setting Integer(Custom String("Pioneer Settings"), Custom String(
			"Pioneer Time Limit in Seconds"), 180, 90, 600, 0);
		Global.PlayerMoveSpeedConstant = Workshop Setting Real(Custom String("Game Constants"), Custom String(
			"Player Move Speed Scale Factor"), 100, 10, 1000, 0);
		Global.PioneerMinDistanceConstant = 6;
		Global.SkipTimeLimit = Workshop Setting Integer(Custom String("Game Constants"), Custom String(
			"Time Before Player Can Skip Level"), 240, 60, 9999, 0);
		Global.PrimaryFireUsefulForTheseHeros = Array(Hero(Ana));
		Global.GameStarted = False;
		Global.PunchGraceEnabled = Workshop Setting Toggle(Custom String("Gameplay"), Custom String("Punch Grace Enabled"), True, 0);
		Global.SlamBuffEnabled = Workshop Setting Toggle(Custom String("Gameplay"), Custom String("Slam Buff Enabled (Slam resets bhop)"),
			False, 0);
		Global.GreenSphereRadiusConstant = Workshop Setting Real(Custom String("Game Constants"), Custom String(
			"Environmental Collision Sphere Radius"), 3.500, 1, 5, 0);
		Global.EffectLockSphereRadiusConstant = Workshop Setting Real(Custom String("Game Constants"), Custom String(
			"Effect Lock (White) Sphere Radius"), 2, 1, 5, 0);
		Global.DevModeEngaged = False;
		Global.UltimateAbilitiesEnabledConstant = Workshop Setting Toggle(Custom String("Pioneer Settings"), Custom String(
			"Ultimate Abilites Enabled"), True, 0);
		Global.ReplaysEnabledConstant = Workshop Setting Toggle(Custom String("Experimental"), Custom String(
			"Enable Pioneer Replays (Can cause large server load if >50 CP's)"), True, 0);
	}
}

rule("Global HUD")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Create HUD Text(Filtered Array(All Players(All Teams), Global.GameStarted == False), Custom String(
			"{0} Press R to Create Origin Point!", Host Player), Null, Null, Top, 0, Color(Green), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Global.GameStarted), Custom String(
			"Pioneer: {0}\r\nTime Remaining: {1}/{2}", Global.CurrentPioneer, Global.PioneerTimer, Global.PioneerTimeLimitConstant), Null,
			Null, Left, 0, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		"Controls HUD"
		disabled Create HUD Text(Filtered Array(All Players(All Teams), Is Button Held(Current Array Element, Button(Interact))), Null, Null,
			Custom String(
			"-------------------------- Controls --------------------------\r\nQuick Reset: Reload\r\nPrev CP: Interact + Crouch\r\n{0}\r\n{1}\r\n{2}",
			Custom String("Teleport: Melee + Left Click\r\nView Next CP Location: Interact + Left Click"), Custom String(
			"Spectate Mode: Interact + Melee \r\nSkip Level (after {0}sec) Interact + Need Healing Voiceline", Global.SkipTimeLimit),
			Custom String(
			"Switch Hero: Interact + Ultimate Status\r\nToggle Invisible: Crouch + Jump\r\nView CP Replay: Interact + Thanks Voiceline")),
			Left, 1, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Host Player, Null, Null, Custom String("Server Load | Average | Peak\r\n{0} | {1} | {2}", Server Load,
			Server Load Average, Server Load Peak), Right, -1, Color(White), Color(White), Color(White), Visible To and String,
			Default Visibility);
		Create HUD Text(Host Player, Null, Null, Custom String(
			"Update Map Settings: Settings -> Workshop Settings\r\nDev Mode: Interact + Hello\r\nSave Map:\r\n{0}\r\n{1}", Custom String(
			"1. Open Workshop Inspector, Select \"variable target\" to be Global\r\n2. Press button [X] on bottom middle to copy all variables"),
			Custom String("3. Open Workshop Editor, open first rule & paste. Map now saved")), Left, 10, Color(White), Color(White), Color(
			White), Visible To, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("Workshop Code: YMVCR"), Right, -2, Color(White), Color(White),
			Color(White), Visible To, Default Visibility);
	}
}

rule("Initialize player")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Start Scaling Player(Event Player, Global.PlayerScaleConstant, False);
		"Punch grace from Hax framework"
		Chase Player Variable At Rate(Event Player, Grace, Is Firing Secondary(Event Player) ? 0.500 : False, Is Firing Secondary(
			Event Player) ? 0.260 : True, Destination and Rate);
		Event Player.CurrentCP = 0;
		Event Player.BlockArriveNextPoint = False;
		Set Status(Event Player, Null, Phased Out, 9999);
		Event Player.BlockPioneerNewPoint = False;
		Event Player.CancelPointTimer = 0;
		Event Player.TeleportEnabled = True;
		Enable Death Spectate All Players(Event Player);
		Enable Death Spectate Target HUD(Event Player);
		Disable Game Mode In-World UI(Event Player);
		Disable Game Mode HUD(Event Player);
		Event Player.TimeSpentOnCP = 0;
		If(Global.PlayerScaleConstant < 0.700);
			Start Modifying Hero Voice Lines(Event Player, 4, False);
		Else If(Global.PlayerScaleConstant > 1.500);
			Start Modifying Hero Voice Lines(Event Player, 0.650, False);
		End;
		"Create Ring, Text and Icon Effects"
		Create Effect(Event Player, Ring, Color(White), Global.CPLocations[Event Player.CurrentCP], Global.CPRadius,
			Visible To Position and Radius);
		Create Effect(Filtered Array(Event Player, Count Of(Global.CPLocations) > Current Array Element.CurrentCP + 1), Ring, Color(
			Purple), Global.CPLocations[Event Player.CurrentCP + 1], Global.CPRadius, Visible To Position and Radius);
		Create In-World Text(Filtered Array(Event Player, Count Of(Global.CPLocations) > Current Array Element.CurrentCP + 1),
			Custom String("Come Here\r\nPioneer: {0}", Global.PioneerList[Event Player.CurrentCP + 1]),
			Global.CPLocations[Event Player.CurrentCP + 1], 1.300, Do Not Clip, Visible To Position and String, Color(Yellow),
			Default Visibility);
		Create Icon(Filtered Array(Event Player, Count Of(Global.CPLocations) > Event Player.CurrentCP + 1),
			Global.CPLocations[Event Player.CurrentCP + 1], Flag, Visible To and Position, Color(Yellow), True);
		Event Player.Invisible = True;
		Set Invisible(Event Player, All);
	}
}

rule("Player HUD & Sphere initialize")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Create HUD Text(Filtered Array(Event Player, Global.GameStarted), Null, Null, Custom String(
			"Checkpoint {0}/{1} - Time Spent On CP {2}", Event Player.CurrentCP, Count Of(Global.CPLocations) - 1,
			Event Player.TimeSpentOnCP), Top, 0, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} - {1}", Event Player, Event Player.CurrentCP), Right,
			100 - Event Player.CurrentCP, Color(White), Color(White), Color(Green), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(Event Player, Global.AbilityCountsEnabledConstant && Current Array Element.CurrentCP + 1 < Count Of(
			Global.CPLocations)), Custom String("Checkpoint Abilty Limits\r\n{0} {1} {2}", Custom String("{0} {1}", Ability Icon String(
			Hero Of(Event Player), Button(Secondary Fire)), X Component Of(Global.CPAbilityCounts[Event Player.CurrentCP])
			- X Component Of(Event Player.CPAbilityCounts)), Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(
			Ability 1)), Y Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]) - Y Component Of(Event Player.CPAbilityCounts)),
			Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Ability 2)), Z Component Of(
			Global.CPAbilityCounts[Event Player.CurrentCP]) - Z Component Of(Event Player.CPAbilityCounts))), Null, Null, Top, -1.400,
			Color(Blue), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(Event Player, Global.CurrentPioneer == Current Array Element), Custom String(
			"Abilty Counts\r\n{0} {1} {2}", Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Secondary Fire)),
			X Component Of(Event Player.CPAbilityCounts)), Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(
			Ability 1)), Y Component Of(Event Player.CPAbilityCounts)), Custom String("{0} {1}", Ability Icon String(Hero Of(Event Player),
			Button(Ability 2)), Z Component Of(Event Player.CPAbilityCounts))), Null, Null, Top, -1.400, Color(Blue), Color(White), Color(
			White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(Event Player, Event Player.TimeSpentOnCP > Global.SkipTimeLimit), Custom String(
			"Have spent more than {0}sec on CP\r\nUse Interact + Jump to skip CP", Global.SkipTimeLimit), Null, Null, Right, 0, Color(Red),
			Color(White), Color(White), Visible To and String, Default Visibility);
		"Game Settings HUD"
		Create HUD Text(Filtered Array(Event Player, Is Button Held(Current Array Element, Button(Interact))), Null, Null, Custom String(
			"--------------------------Game Settings--------------------------\r\n{0}\r\n{1}\r\n{2}", Custom String(
			"Infinite Mode Enabled: {0}\r\nMulti-Hero Enabled: {1}\r\nAbility Limits Enabled: {2}", Global.InfiniteModeEnabledConstant,
			Global.MultiHeroEnabled, Global.AbilityCountsEnabledConstant), Custom String(
			"Player Scale Constant: {0}\r\nPunch Grace Enabled: {1}\r\nPlayer Move Speed Constant: {2}", Global.PlayerScaleConstant,
			Global.PunchGraceEnabled, Global.PlayerMoveSpeedConstant), Custom String(
			"Pioneer Time Limit: {0}\r\nPlayer CP Skip Time Limit: {1}\r\n{2}", Global.PioneerTimeLimitConstant, Global.SkipTimeLimit,
			Custom String("CP Radius: {0}", Global.CPRadius))), Right, 9, Color(White), Color(White), Color(White), Visible To and String,
			Default Visibility);
		Create HUD Text(Filtered Array(Event Player, !Is Button Held(Current Array Element, Button(Interact))), Null, Null, Custom String(
			"Hold Interact Key ({0}) For Controls / Game Settings", Input Binding String(Button(Interact))), Left, 1, Color(White), Color(
			White), Color(Red), Visible To and String, Default Visibility);
		"Pioneer special controls HUD"
		Create HUD Text(Filtered Array(Event Player, Global.CurrentPioneer == Current Array Element), Custom String(
			"Create Effect Lock: Melee\r\nCreate Env Sphere: Crouch\r\nCreate Kill Sphere: Group Up\r\nChange Hero: Interact + Ultimate Status"),
			Null, Null, Right, 0, Color(Red), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(Event Player, Count Of(Global.CPLocations)
			== Event Player.CurrentCP + 1 && Global.MultiHeroEnabled && Global.CurrentPioneer != Event Player), Custom String(
			"Change Hero: Interact + Ultimate Status"), Null, Null, Right, 0, Color(Red), Color(White), Color(White),
			Visible To and String, Default Visibility);
		"Green Sphere Create"
		Create Effect(Filtered Array(Event Player, Global.CPGreenSphereArray[Current Array Element.CurrentCP] != Null), Sphere, Color(
			Green), Global.CPGreenSphereArray[Event Player.CurrentCP], Global.GreenSphereRadiusConstant, Visible To Position and Radius);
		"Green Sphere Create Pioneer Only"
		Create Effect(Filtered Array(Event Player, Current Array Element.GreenSphereLocation != Null), Sphere, Color(Green),
			Event Player.GreenSphereLocation, Global.GreenSphereRadiusConstant, Visible To Position and Radius);
		"Effect Lock Sphere Create Non-Pioneer"
		Create Effect(Filtered Array(Event Player,
			Global.CPEffectLockSphereArray[Current Array Element.CurrentCP] != Null && !Current Array Element.EffectLockObtained), Sphere,
			Color(White), Global.CPEffectLockSphereArray[Event Player.CurrentCP], Global.EffectLockSphereRadiusConstant + -0.900,
			Visible To Position and Radius);
		"Effect Lock Sphere Create Pioneer Only"
		Create Effect(Filtered Array(Event Player, Current Array Element.EffectLockSphereLocation != Null), Sphere, Color(White),
			Event Player.EffectLockSphereLocation, Global.EffectLockSphereRadiusConstant, Visible To Position and Radius);
		Create HUD Text(Filtered Array(Event Player, (
			Global.CPEffectLockSphereArray[Current Array Element.CurrentCP] != Null && Current Array Element.EffectLockObtained != True && True)
			== True), Custom String("Effect Lock Required!"), Null, Null, Top, 0, Color(Red), Color(White), Color(White), Visible To,
			Default Visibility);
		"Effect Lock Flag Icon Create Non-Pioneer"
		Create Icon(Filtered Array(Event Player,
			Global.CPEffectLockSphereArray[Current Array Element.CurrentCP] != Null && !Current Array Element.EffectLockObtained),
			Global.CPEffectLockSphereArray[Event Player.CurrentCP], Flag, Visible To and Position, Color(Yellow), True);
		Create In-World Text(Filtered Array(Event Player,
			Global.CPEffectLockSphereArray[Current Array Element.CurrentCP] != Null && !Current Array Element.EffectLockObtained),
			Custom String("Effect Lock"), Global.CPEffectLockSphereArray[Event Player.CurrentCP], 1.300, Do Not Clip,
			Visible To and Position, Color(Yellow), Default Visibility);
		"Kill Sphere Create"
		Create Effect(Filtered Array(Event Player, Global.CPKillSphereArray[Current Array Element.CurrentCP] != Null), Sphere, Color(Red),
			Global.CPKillSphereArray[Event Player.CurrentCP], Global.GreenSphereRadiusConstant, Visible To Position and Radius);
		"Green Sphere Create Pioneer Only"
		Create Effect(Filtered Array(Event Player, Current Array Element.KillSphereLocation != Null), Sphere, Color(Red),
			Event Player.KillSphereLocation, Global.GreenSphereRadiusConstant, Visible To Position and Radius);
	}
}

rule("Controls HUD")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Create HUD Text(Filtered Array(All Players(All Teams), Is Button Held(Current Array Element, Button(Interact))), Custom String(
			"{0}", Ability Icon String(Hero(Hanzo), Button(Ability 1))), Custom String("View Next Checkpoint"), Custom String(
			"Interact + Left Click"), Left, 1, Color(White), Color(Orange), Color(White), Visible To, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Is Button Held(Current Array Element, Button(Interact))), Custom String(
			"{0}", Ability Icon String(Hero(Soldier: 76), Button(Ultimate))), Custom String("Spectate"), Custom String("Interact + Melee"),
			Left, 1.100, Color(White), Color(Orange), Color(White), Visible To, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Is Button Held(Current Array Element, Button(Interact))), Custom String(
			"{0}", Ability Icon String(Hero(Tracer), Button(Ability 1))), Custom String("Skip Level (After {0}sec)", Global.SkipTimeLimit),
			Custom String("Interact + Jump"), Left, 1.200, Color(White), Color(Orange), Color(White), Visible To, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Is Button Held(Current Array Element, Button(Interact))), Custom String(
			"{0}", Ability Icon String(Hero(Sombra), Button(Ability 1))), Custom String("Toggle Invisibility", Global.SkipTimeLimit),
			Custom String("Crouch + Jump"), Left, 1.300, Color(White), Color(Orange), Color(White), Visible To, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Is Button Held(Current Array Element, Button(Interact))), Custom String(
			"{0}", Ability Icon String(Hero(Echo), Button(Ultimate))), Custom String("Switch Hero", Global.SkipTimeLimit), Custom String(
			"Interact + Ultimate Status"), Left, 1.400, Color(White), Color(Orange), Color(White), Visible To, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Is Button Held(Current Array Element, Button(Interact))), Custom String(
			"{0}", Ability Icon String(Hero(Tracer), Button(Ability 2))), Custom String("Replay Pioneer Route", Global.SkipTimeLimit),
			Custom String("Interact + Thanks Voiceline"), Left, 1.500, Color(White), Color(Orange), Color(White), Visible To,
			Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Is Button Held(Current Array Element, Button(Interact))), Custom String(
			"{0}", Ability Icon String(Hero(Sombra), Button(Ability 2))), Custom String("Teleport"), Custom String("Left Click + Melee"),
			Left, 1.900, Color(White), Color(Orange), Color(White), Visible To, Default Visibility);
	}
}

disabled rule("Game Framework")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Create Origin Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player == Host Player;
		Global.GameStarted == False;
		Is On Ground(Event Player) == True;
		Has Spawned(Event Player) == True;
		Is Button Held(Event Player, Button(Reload)) == True;
	}

	actions
	{
		Small Message(All Players(All Teams), Custom String("Creating origin point"));
		Global.CPLocations = Array(Position Of(Event Player));
		Global.CPAbilityCounts = Empty Array;
		Global.CPUltimateTeleportPrimary = Empty Array;
		Global.CPFacingDirections = Empty Array;
		Global.PioneerList = Array(Custom String("{0}", Event Player));
		Global.CurrentPioneer = Event Player;
		Global.GameStarted = True;
		Global.CPHeroList = Array();
		Global.CPGreenSphereArray = Empty Array;
		Global.CPEffectLockSphereArray = Empty Array;
		Global.CPKillSphereArray = Empty Array;
		Global.ReplayPioneerPositionArray = Empty Array;
		Global.ReplayPioneerFacingArray = Empty Array;
	}
}

rule("Game Started (origin point just created by host) - Create World Effects")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.GameStarted == True;
	}

	actions
	{
		"Restart player at origin point after it's created and start timer"
		Call Subroutine(RespawnPlayer);
		Call Subroutine(HandleSkipTimer);
	}
}

rule("Pioneer Create Point")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Is On Ground(Event Player) == True;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius;
		Distance Between(Global.CPLocations[Event Player.CurrentCP + 1], Position Of(Event Player)) <= Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
		Event Player.BlockPioneerNewPoint == False;
		"Can't pioneer in spectate mode"
		Event Player.SpectateMode == False;
		"Punch grace from Hax framework"
		(!Global.PunchGraceEnabled || Is Firing Secondary(Event Player) || Event Player.Grace < 0.120) == True;
		"Slam Buff"
		!(Global.SlamBuffEnabled && Is Using Ability 2(Event Player) && True) == True;
		"Winston Leap Bhop Fix"
		(Hero Of(Event Player) != Hero(Winston) || Event Player.WinstonLeapGrace <= 0) == True;
	}

	actions
	{
		"Make sure they pioneered far enough"
		If(Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentCP]) < Global.PioneerMinDistanceConstant);
			Small Message(Event Player, Custom String("Pioneer more than {0}m!", Global.PioneerMinDistanceConstant));
			Call Subroutine(RespawnPlayer);
			Abort;
		End;
		Play Effect(Event Player, Ring Explosion Sound, Color(White), Event Player, 60);
		Event Player.TempVariable2 = Position Of(Event Player);
		Start Forcing Player Position(Event Player, Event Player.TempVariable2, True);
		Call Subroutine(CancelMomentum);
		"Allow player 3 sec to cancel the CP"
		Event Player.CancelPointTimer = 3;
		Chase Player Variable At Rate(Event Player, CancelPointTimer, 0, 1, Destination and Rate);
		Big Message(Event Player, Custom String("Press R within 3 sec to cancel checkpoint"));
		While(Event Player.CancelPointTimer > 0 && True);
			Wait(0.016, Ignore Condition);
			If(Is Button Held(Event Player, Button(Reload)));
				Stop Forcing Player Position(Event Player);
				Call Subroutine(RespawnPlayer);
				Abort;
			End;
		End;
		Stop Forcing Player Position(Event Player);
		"Hopefully tempvariable doesn't conflict with \"Pioneer runs out of time\" rule"
		For Player Variable(Event Player, TempVariable, 0, Count Of(All Living Players(All Teams)), 1);
			If(All Living Players(All Teams)[Event Player.TempVariable].CurrentCP == Count Of(Global.CPLocations) - 1);
				All Living Players(All Teams)[Event Player.TempVariable].ForceRespawn = True;
			End;
		End;
		"Create the next point"
		Event Player.BlockArriveNextPoint = True;
		Modify Global Variable(CPLocations, Append To Array, Event Player.TempVariable2);
		Modify Global Variable(PioneerList, Append To Array, Custom String("{0}", Event Player));
		Modify Global Variable(CPAbilityCounts, Append To Array, Event Player.CPAbilityCounts);
		Modify Global Variable(CPUltimateTeleportPrimary, Append To Array, Event Player.CountUltimateTeleportPrimary);
		Modify Global Variable(CPHeroList, Append To Array, Hero Of(Event Player));
		Modify Global Variable(CPGreenSphereArray, Append To Array, Event Player.GreenSphereLocation);
		Modify Global Variable(CPKillSphereArray, Append To Array, Event Player.KillSphereLocation);
		"Don't allow effect locks on teleport points"
		If(Y Component Of(Event Player.CountUltimateTeleportPrimary) > 0);
			Event Player.EffectLockSphereLocation = Null;
		End;
		Modify Global Variable(CPEffectLockSphereArray, Append To Array, Event Player.EffectLockSphereLocation);
		Global.ReplayPioneerPositionArray[Event Player.CurrentCP] = Event Player.ReplayPosition;
		Global.ReplayPioneerFacingArray[Event Player.CurrentCP] = Event Player.ReplayFacing;
		Event Player.FacingDirectionLeavingCP = Global.CPFacingDirections[Event Player.CurrentCP];
		Call Subroutine(RespawnPlayer);
		Event Player.BlockArriveNextPoint = False;
		Event Player.TimeSpentOnCP = 0;
		Chase Player Variable At Rate(Event Player, TimeSpentOnCP, 9999, 1, Destination and Rate);
		Global.CurrentPioneer = Null;
		Enable Inspector Recording;
		Log To Inspector(Custom String("Created Checkpoint {0}", Count Of(Global.CPLocations)));
		Disable Inspector Recording;
	}
}

rule("Non-Pioneer Respawn If Touch Ground Outside of current or next CP")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Is On Ground(Event Player) == True;
		Event Player.BlockArriveNextPoint == False;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius;
		Distance Between(Global.CPLocations[Event Player.CurrentCP + 1], Position Of(Event Player)) > Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
		"Punch grace from Hax framework"
		(!Global.PunchGraceEnabled || Is Firing Secondary(Event Player) || Event Player.Grace < 0.120) == True;
		"Slam Buff"
		!(Global.SlamBuffEnabled && Is Using Ability 2(Event Player) && True) == True;
		"Winston Leap Bhop Fix"
		(Hero Of(Event Player) != Hero(Winston) || Event Player.WinstonLeapGrace <= 0) == True;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Non-Pioneer Arrive At CP")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Is On Ground(Event Player) == True;
		Event Player.BlockArriveNextPoint == False;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius;
		Distance Between(Global.CPLocations[Event Player.CurrentCP + 1], Position Of(Event Player)) <= Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
		Count Of(Global.CPLocations) > Event Player.CurrentCP + 1;
	}

	actions
	{
		"Check if player got effect lock obtained, if they haven't respawn them"
		If(Global.CPEffectLockSphereArray[Event Player.CurrentCP] != Null && Event Player.EffectLockObtained != True);
			Small Message(Event Player, Custom String("Checkpoint requires you to get the effect lock!"));
			Call Subroutine(RespawnPlayer);
			Abort;
		End;
		Play Effect(Event Player, Buff Impact Sound, Color(White), Event Player, 60);
		Event Player.CurrentCP += 1;
		Event Player.MaxUnlockedCP = Max(Event Player.MaxUnlockedCP, Event Player.CurrentCP);
		If(Count Of(Global.CPLocations) == Event Player.CurrentCP + 1);
			If(Global.CurrentPioneer == Null);
				"So you can't pioneer your own point unless you are the only player alive (aka not spectating)"
				If(Count Of(All Living Players(All Teams)) == 1 || Last Of(Global.PioneerList) != Custom String("{0}", Event Player));
					Big Message(Event Player, Custom String("You are pioneer! Use your skills to make the next checkpoint!"));
					Global.CurrentPioneer = Event Player;
				End;
			End;
		End;
		Call Subroutine(HandleSkipTimer);
		Event Player.FacingDirectionLeavingCP = Global.CPFacingDirections[Event Player.CurrentCP];
		Call Subroutine(RespawnPlayer);
	}
}

rule("If player joins after origin point created, start them at origin point")
{
	event
	{
		Player Joined Match;
		All;
		All;
	}

	conditions
	{
		Global.GameStarted == True;
	}

	actions
	{
		Wait(0.100, Ignore Condition);
		Loop If(!Has Spawned(Event Player));
		Wait(0.100, Ignore Condition);
		Call Subroutine(HandleSkipTimer);
		Event Player.FacingDirectionLeavingCP = Global.CPFacingDirections[Event Player.CurrentCP];
		Call Subroutine(RespawnPlayer);
	}
}

rule("Handle ForceRespawn")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.ForceRespawn == True;
	}

	actions
	{
		Event Player.BlockPioneerNewPoint = True;
		Call Subroutine(RespawnPlayer);
		Event Player.BlockPioneerNewPoint = False;
		Event Player.ForceRespawn = False;
		Event Player.FacingDirectionLeavingCP = Global.CPFacingDirections[Event Player.CurrentCP];
		"Hopefully to avoid the pioneer rule from still being executed while player \"HandleSkipTimer\" subroutine is running"
		Wait(0.100, Ignore Condition);
		Call Subroutine(HandleSkipTimer);
	}
}

rule("Start Pioneer Timer and set Invisible when player becomes pioneer")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Global.PioneerTimer = Global.PioneerTimeLimitConstant;
		Chase Global Variable At Rate(PioneerTimer, 0, 1, Destination and Rate);
		Disallow Button(Event Player, Button(Melee));
		If(Hero Of(Event Player) != Hero(Wrecking Ball));
			Set Invisible(Event Player, All);
		End;
	}
}

rule("Set Non-Pioneer Visible")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Allow Button(Event Player, Button(Melee));
		If(Event Player.Invisible);
			Set Invisible(Event Player, All);
		Else;
			Set Invisible(Event Player, None);
		End;
	}
}

rule("Pioneer runs out of time")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.PioneerTimer == 0;
		Has Spawned(Event Player) == True;
		Global.CurrentPioneer == Event Player;
	}

	actions
	{
		"To prevent this rule from conflicting with the \"start pioneer timer\" rule"
		Wait(4, Abort When False);
		"Is there a player on final checkpoint waiting for pioneer"
		If(Count Of(Filtered Array(All Players(All Teams), Global.CurrentPioneer != Current Array Element && Count Of(Global.CPLocations)
			== Current Array Element.CurrentCP + 1)) > 0);
			Event Player.TempVariable = Random Value In Array(Filtered Array(All Players(All Teams),
				Global.CurrentPioneer != Current Array Element && Count Of(Global.CPLocations) == Current Array Element.CurrentCP + 1));
			Global.PioneerTimer = Global.PioneerTimeLimitConstant;
			Event Player.TempVariable.ForceRespawn = True;
			Global.CurrentPioneer = Event Player.TempVariable;
			Wait(0.100, Ignore Condition);
			Big Message(All Players(All Teams), Custom String("Pioneer ran out of time. Pioneer passed to {0}", Global.CurrentPioneer));
		Else;
			Global.PioneerTimer = Global.PioneerTimeLimitConstant;
			Big Message(All Players(All Teams), Custom String("No one to pass pioneer to"));
		End;
	}
}

rule("Set Pioneer Timer to Zero if there isn't a pioneer")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.CurrentPioneer == Null;
	}

	actions
	{
		Global.PioneerTimer = 0;
	}
}

disabled rule("Other Features / Key Bindings")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Reload - Quick Reset")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Reload)) == True;
		disabled Is On Ground(Event Player) != True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
		"So player can't R and get teleported outside map before origin point is selected"
		Global.GameStarted == True;
		"Quick Reset Disabled for Ana, so you can reload - modify the array here for additional disable"
		disabled Index Of Array Value(Global.PrimaryFireUsefulForTheseHeros, Hero Of(Event Player)) < 0;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
	}
}

rule("Crouch + Interact - Move Back A Checkpoint")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		If(Global.CurrentPioneer == Event Player);
			Small Message(Event Player, Custom String("Can't move back a level while pioneer! Make a checkpoint!"));
			Abort;
		End;
		If(Event Player.CurrentCP > 0);
			Event Player.CurrentCP += -1;
		Else;
			"If on Checkpoint 0, go to greatest unlocked checkpoint on level"
			Event Player.CurrentCP = Event Player.MaxUnlockedCP;
		End;
		Call Subroutine(HandleSkipTimer);
		Event Player.BlockArriveNextPoint = True;
		Call Subroutine(RespawnPlayer);
		Event Player.BlockArriveNextPoint = False;
	}
}

rule("Interact + Left Click: Camera To See Next Point (or the effect lock sphere)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		"Make sure next point exists"
		Count Of(Global.CPLocations) > Event Player.CurrentCP + 1;
	}

	actions
	{
		Set Primary Fire Enabled(Event Player, False);
		Set Facing(Event Player, Vector(-10, -10, 0), To World);
		"Look at effect lock sphere if it exists and is within 10 degrees of where the player is looking when pressing left click + interact. Otherwise look at next CP"
		If(Global.CPEffectLockSphereArray[Event Player.CurrentCP] != Null && Angle Between Vectors(Facing Direction Of(Event Player),
			Direction Towards(Eye Position(Event Player), Global.CPEffectLockSphereArray[Event Player.CurrentCP]))
			< 10 && Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player),
			Global.CPLocations[Event Player.CurrentCP + 1])) > 10);
			Start Camera(Event Player, Ray Cast Hit Position(Global.CPEffectLockSphereArray[Event Player.CurrentCP + 0],
				Global.CPEffectLockSphereArray[Event Player.CurrentCP + 0] + Facing Direction Of(Event Player) * -15, All Players(All Teams),
				Event Player, True), Global.CPEffectLockSphereArray[Event Player.CurrentCP + 0], 30);
		Else;
			Start Camera(Event Player, Ray Cast Hit Position(Global.CPLocations[Event Player.CurrentCP + 1],
				Global.CPLocations[Event Player.CurrentCP + 1] + Facing Direction Of(Event Player) * -15, All Players(All Teams), Event Player,
				True), Global.CPLocations[Event Player.CurrentCP + 1], 30);
		End;
		Wait Until(!(Is Button Held(Event Player, Button(Primary Fire)) && Is Button Held(Event Player, Button(Interact))), 20);
		disabled While(Is Button Held(Event Player, Button(Primary Fire)) && Is Button Held(Event Player, Button(Interact)));
		disabled Wait(0.033, Ignore Condition);
		disabled End;
		Stop Camera(Event Player);
		Set Primary Fire Enabled(Event Player, True);
		Set Facing(Event Player, Global.CPFacingDirections[Event Player.CurrentCP], To World);
	}
}

rule("Interact + Jump -> Skip Checkpoint")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		If(Global.CurrentPioneer == Event Player);
			Small Message(Event Player, Custom String("Can't change level while pioneer! Make a checkpoint!"));
			Abort;
		End;
		"If player is not on last unlocked CP"
		If(Event Player.CurrentCP < Event Player.MaxUnlockedCP);
			Event Player.CurrentCP += 1;
		Else;
			If(Global.DevModeEngaged || Event Player.TimeSpentOnCP > Global.SkipTimeLimit);
				Event Player.CurrentCP += 1;
				Event Player.MaxUnlockedCP = Event Player.CurrentCP;
				Event Player.BlockArriveNextPoint = True;
				Call Subroutine(RespawnPlayer);
				"Allow player to pioneer using CP skip"
				If(Count Of(Global.CPLocations) == Event Player.CurrentCP + 1);
					If(Global.CurrentPioneer == Null);
						Big Message(Event Player, Custom String("You are pioneer! Use your skills to make the next checkpoint!"));
						Global.CurrentPioneer = Event Player;
					End;
				End;
				Event Player.BlockArriveNextPoint = False;
				Call Subroutine(HandleSkipTimer);
				Abort;
			Else;
				"If haven't unlocked next CP yet, go back to CP 0"
				Event Player.CurrentCP = 0;
			End;
		End;
		Call Subroutine(HandleSkipTimer);
		Call Subroutine(RespawnPlayer);
	}
}

rule("Interact + Need Healing Voiceline = Skip CP if you have spent enough time")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Communicating(Event Player, Need Healing) == True;
		Event Player.TimeSpentOnCP > Global.SkipTimeLimit;
	}

	actions
	{
		Event Player.BlockArriveNextPoint = True;
		Event Player.CurrentCP += 1;
		Event Player.MaxUnlockedCP = Event Player.CurrentCP;
		Call Subroutine(RespawnPlayer);
		"Allow player to pioneer using CP skip"
		If(Count Of(Global.CPLocations) == Event Player.CurrentCP + 1);
			If(Global.CurrentPioneer == Null);
				Big Message(Event Player, Custom String("You are pioneer! Use your skills to make the next checkpoint!"));
				Global.CurrentPioneer = Event Player;
			End;
		End;
		Call Subroutine(HandleSkipTimer);
		Event Player.BlockArriveNextPoint = False;
	}
}

rule("Interact + Melee : Spectate Other Players")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Melee)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
	}

	actions
	{
		Enable Death Spectate All Players(All Players(All Teams));
		If(Is Dead(Event Player));
			Enable Built-In Game Mode Respawning(Event Player);
			Resurrect(Event Player);
			Wait(0.100, Ignore Condition);
			Call Subroutine(RespawnPlayer);
			Event Player.SpectateMode = False;
		Else;
			Big Message(Event Player, Custom String("Use \"Interact + Melee\" to exit Spectate Mode!"));
			Event Player.SpectateMode = True;
			Disable Built-In Game Mode Respawning(Event Player);
			Kill(Event Player, Null);
		End;
		Set Status(Event Player, Null, Phased Out, 9999);
	}
}

rule("Melee + Left Click = Teleport")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Is Button Held(Event Player, Button(Melee)) == True;
		(Event Player.TeleportEnabled || Global.DevModeEngaged) == True;
	}

	actions
	{
		Teleport(Event Player, Ray Cast Hit Position(Position Of(Event Player), Position Of(Event Player) + Facing Direction Of(
			Event Player) * 60, All Players(All Teams), Event Player, True));
		Event Player.CountUltimateTeleportPrimary += Up;
	}
}

rule("Interact + Hello Voiceline = Dev Mode Engaged")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player == Host Player;
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Communicating(Event Player, Hello) == True;
	}

	actions
	{
		"Right now Dev Mode lets all players teleport and skip any points with zero time using jump + interact"
		disabled Wait(0.250, Ignore Condition);
		If(Global.DevModeEngaged);
			Small Message(All Players(All Teams), Custom String("Dev Mode Disengaged"));
			Global.DevModeEngaged = False;
		Else;
			Small Message(All Players(All Teams), Custom String("Dev Mode Engaged"));
			Global.DevModeEngaged = True;
		End;
	}
}

rule("Interact + Ultimate Status Voiceline = Pioneer can switch hero")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		disabled Is Button Held(Event Player, Button(Jump)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		"This condition is so this rule doesn't get executed at same time as a player is using the level cancel"
		Event Player.CancelPointTimer == 0;
		"Is pioneer or is waiting for pioneer"
		(Global.CurrentPioneer == Event Player || Count Of(Global.CPLocations) == Event Player.CurrentCP + 1) == True;
		Global.MultiHeroEnabled == True;
		Is Communicating(Event Player, Ultimate Status) == True;
	}

	actions
	{
		"If a menu is already open, delete the in world text and recreate the menu in the proper location"
		If(Event Player.HeroSelectMenuOpen);
			For Player Variable(Event Player, TempIterator, 0, Count Of(Event Player.MenuTextIDTempStore), 1);
				Destroy In-World Text(Event Player.MenuTextIDTempStore[Event Player.TempIterator]);
				Abort;
			End;
		End;
		Event Player.MenuInWorldLocationTempStore = Empty Array;
		Event Player.MenuTextIDTempStore = Empty Array;
		For Player Variable(Event Player, TempIterator, 0, Count Of(Global.HeroRoster), 1);
			Modify Player Variable(Event Player, MenuInWorldLocationTempStore, Append To Array, Eye Position(Event Player)
				+ Facing Direction Of(Event Player) * 1 + 0.400 * World Vector Of(Vector(Sine From Degrees(360 * (
				Event Player.TempIterator / Count Of(Global.HeroRoster))), Cosine From Degrees(360 * (Event Player.TempIterator / Count Of(
				Global.HeroRoster))), 0), Event Player, Rotation));
			Create In-World Text(Event Player, Custom String("{0}", Hero Icon String(Global.HeroRoster[Event Player.TempIterator])),
				Event Player.MenuInWorldLocationTempStore[Event Player.TempIterator] + Vector(0, -0.100, 0), 3, Do Not Clip, None, Color(
				White), Default Visibility);
			Modify Player Variable(Event Player, MenuTextIDTempStore, Append To Array, Last Text ID);
			Wait(0.016, Ignore Condition);
		End;
		Event Player.HeroSelectMenuOpen = True;
		Big Message(Event Player, Custom String("Release Interact Over The Hero You Want To Select"));
	}
}

rule("Crouch + Jump: Toggle Invisiblity")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) == True;
		Is Button Held(Event Player, Button(Crouch)) == True;
		Global.CurrentPioneer != Event Player;
	}

	actions
	{
		If(Event Player.Invisible);
			Set Invisible(Event Player, None);
			Small Message(Event Player, Custom String("Visible"));
		Else;
			Small Message(Event Player, Custom String("Invisible"));
			Set Invisible(Event Player, All);
		End;
		Event Player.Invisible = !Event Player.Invisible;
	}
}

rule("Close Hero Select Menu")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == False;
		Has Spawned(Event Player) == True;
		Event Player.HeroSelectMenuOpen == True;
	}

	actions
	{
		Start Forcing Player To Be Hero(Event Player, Global.HeroRoster[Index Of Array Value(Event Player.MenuInWorldLocationTempStore,
			First Of(Sorted Array(Event Player.MenuInWorldLocationTempStore, Angle Between Vectors(Facing Direction Of(Event Player),
			Direction Towards(Eye Position(Event Player), Current Array Element)))))]);
		For Player Variable(Event Player, TempIterator, 0, Count Of(Event Player.MenuTextIDTempStore), 1);
			Destroy In-World Text(Event Player.MenuTextIDTempStore[Event Player.TempIterator]);
		End;
		If(Hero Of(Event Player) == Hero(Wrecking Ball));
			Set Invisible(Event Player, None);
		End;
		Event Player.HeroSelectMenuOpen = False;
	}
}

disabled rule("Replay Saving / Watching Code")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Pioneer Save Replay")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		"Has left starting CP or is using an ability"
		(Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius || Is Firing Secondary(
			Event Player) || Is Using Ability 1(Event Player) || Is Using Ability 2(Event Player) || Is Using Ultimate(Event Player))
			== True;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
		Event Player.CancelPointTimer == 0;
		Global.ReplaysEnabledConstant == True;
	}

	actions
	{
		Modify Player Variable(Event Player, ReplayPosition, Append To Array, Eye Position(Event Player));
		Modify Player Variable(Event Player, ReplayFacing, Append To Array, Facing Direction Of(Event Player));
		Wait(0.100, Ignore Condition);
		Loop If Condition Is True;
		Modify Player Variable(Event Player, ReplayPosition, Append To Array, Eye Position(Event Player));
		Modify Player Variable(Event Player, ReplayFacing, Append To Array, Facing Direction Of(Event Player));
	}
}

rule("Interact + Thanks: View Replay")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Communicating(Event Player, Thanks) == True;
	}

	actions
	{
		If(!Global.ReplaysEnabledConstant);
			Small Message(Event Player, Custom String("Replays Disabled (Host Can Turn It On In Workshop Settings)"));
			Abort;
		End;
		Start Camera(Event Player, Global.ReplayPioneerPositionArray[Event Player.CurrentCP][Event Player.TempIterator],
			Global.ReplayPioneerPositionArray[Event Player.CurrentCP][Event Player.TempIterator] + Global.ReplayPioneerFacingArray[Event Player.CurrentCP][Event Player.TempIterator],
			30);
		For Player Variable(Event Player, TempIterator, 0, Count Of(Global.ReplayPioneerPositionArray[Event Player.CurrentCP]) - 1, 1);
			Wait(0.070, Ignore Condition);
		End;
		Wait(0.500, Ignore Condition);
		Stop Camera(Event Player);
	}
}

disabled rule("Handle Ability Counts")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Handle Ability Count Limits (if enabled)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Is Using Ability 1(Event Player) || Is Using Ability 2(Event Player) || Is Firing Secondary(Event Player)) == True;
		"Inside a level, not in multilevel portionIs NOT on last checkpoint of the level"
		Event Player.CurrentCP + 1 < Count Of(Global.CPLocations);
		Global.AbilityCountsEnabledConstant == True;
	}

	actions
	{
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
		If(Y Component Of(Event Player.CPAbilityCounts) >= Y Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]));
			Set Ability 1 Enabled(Event Player, False);
		End;
		If(Z Component Of(Event Player.CPAbilityCounts) >= Z Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]));
			Set Ability 2 Enabled(Event Player, False);
		End;
		If(X Component Of(Event Player.CPAbilityCounts) >= X Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]));
			"Have to wait to disable punch because otherwise it would disable immediately after using preventing punch from working properly."
			Wait(0.400, Ignore Condition);
			"This is to fix interaction with the Quick Reset (R) right after using punch, so this doesn't disable punch after you respawn. Can have slight bug where player is punching through the start location, and doesn't set cooldown properly."
			Abort If(True && Distance Between(Position Of(Event Player), Global.CPLocations[Event Player.CurrentCP]) < Global.CPRadius);
			Set Secondary Fire Enabled(Event Player, False);
		End;
	}
}

rule("Used Ultimate")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		"Don't trigger if player has complete point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.CountUltimateTeleportPrimary += Left;
	}
}

rule("Used Secondary (Rocket Punch)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
		"Don't trigger if player has complete point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.CPAbilityCounts += Left;
	}
}

rule("Used Ability 1 (Uppercut)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
		"Don't trigger if player has complete point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.CPAbilityCounts += Up;
	}
}

rule("Used Ability 2 - NON DOOMFIST")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		Event Player.CancelPointTimer == 0;
		Hero Of(Event Player) != Hero(Doomfist);
	}

	actions
	{
		Event Player.CPAbilityCounts += Forward;
	}
}

rule("Used Ability 2 - Start Slam Timer")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		"Don't trigger if player has complete point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.SlamTimer = 0;
		Chase Player Variable At Rate(Event Player, SlamTimer, 99, 1, Destination and Rate);
	}
}

rule("Used Ability 2 + 125 Slam Detector")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == False;
		Has Spawned(Event Player) == True;
		"To stop this rule from double triggering"
		Event Player.SlamTimer > 0;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, SlamTimer);
		"Prevent invalid slam (where press slam button but you are not allowed to slam) from counting as a slam. Matters for ability count limits."
		disabled If(Is On Ground(Event Player) || Event Player.SlamTimer >= 0.250);
		disabled Event Player.CPAbilityCounts += Forward;
		disabled End;
		"Detect 125 slam. Formula is Slam Damage = 100 * (Slam Time) - 28, so 125 slam requires at least 1.53 sec of slam time."
		disabled If(Event Player.SlamTimer >= 1.520);
		disabled Event Player.Count360Slam125 += Up;
		disabled Small Message(Event Player, Custom String("125 Slam"));
		disabled Play Effect(Event Player, Buff Impact Sound, Color(White), Event Player, 60);
		disabled End;
		Event Player.SlamTimer = 0;
	}
}

rule("Used Primary Fire (If Ana)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ana;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
		"Don't trigger if player has complete point"
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.CountUltimateTeleportPrimary += Forward;
	}
}

rule("Increment Slam Counter")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		"Prevents invalid slam (where player presses slam button but can't slam) from being counted"
		((Is On Ground(Event Player) && Event Player.SlamTimer > 0.040 && Event Player.SlamTimer < 0.250) || (
			Event Player.SlamTimer > 0.250)) == True;
		Has Spawned(Event Player) == True;
		Is Using Ability 2(Event Player) == True;
		disabled Event Player.SlamTimer > 0.250;
		"Don't trigger if player has complete point"
		disabled Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.CPAbilityCounts += Forward;
		If(Is On Ground(Event Player));
			Stop Chasing Player Variable(Event Player, SlamTimer);
			Event Player.SlamTimer = 0;
		End;
	}
}

rule("125 Slam Detection")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		"Actual time is 1.53 for 125 slam + cancel, but removing cancel ~.3 sec"
		Event Player.SlamTimer >= 1.220;
		Is Using Ability 2(Event Player) == True;
		"To prevent player from just holding down slam at invalid slam angle to get a 125 slam"
		Is Button Held(Event Player, Button(Ability 2)) == False;
	}

	actions
	{
		Event Player.Count360Slam125 += Up;
		Small Message(Event Player, Custom String("125 Slam"));
		Play Effect(Event Player, Buff Impact Sound, Color(White), Event Player, 60);
	}
}

disabled rule("Handle Edge Cases")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Reset Cooldowns If In Starting CP Ring")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) < Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
		(Ability Cooldown(Event Player, Button(Secondary Fire)) > 0 || Ability Cooldown(Event Player, Button(Ability 1))
			> 0 || Ability Cooldown(Event Player, Button(Ability 2)) > 0) == True;
		(Is Using Ability 1(Event Player) || Is Using Ability 2(Event Player) || Is Firing Secondary(Event Player)) == False;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		"if u charge punch, then jump and land in circle, it takes your punch away "
		disabled Event Player.CPAbilityCounts = Vector(0, 0, 0);
		Event Player.CountUltimateTeleportPrimary = Vector(0, 0, 0);
	}
}

rule("Declare Winner If Not Infinite Mode")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.InfiniteModeEnabledConstant == False;
		Count Of(Global.CPLocations) > 30;
	}

	actions
	{
		Wait(1, Ignore Condition);
		Declare Player Victory(Global.CurrentPioneer);
	}
}

rule("Handle Player Death")
{
	event
	{
		Player Died;
		All;
		All;
	}

	conditions
	{
		Event Player.SpectateMode != True;
	}

	actions
	{
		Event Player.BlockPioneerNewPoint = True;
		"In case you die during 3 seconds after pioneering"
		If(Event Player.CancelPointTimer > 0);
			Wait(3, Ignore Condition);
		End;
		Respawn(Event Player);
		Wait(0.100, Ignore Condition);
		If(Global.GameStarted);
			Call Subroutine(RespawnPlayer);
			Wait(0.100, Ignore Condition);
		End;
		Clear Status(Event Player, Phased Out);
		Set Status(Event Player, Null, Phased Out, 9999);
		Event Player.BlockPioneerNewPoint = False;
	}
}

rule("Save CP Facing Direction when leaving the CP (for both pioneer and non-pioneer)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		disabled Global.CurrentPioneer == Event Player;
		Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius;
		Global.GameStarted == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		If(Global.CurrentPioneer == Event Player);
			Global.CPFacingDirections[Event Player.CurrentCP] = Facing Direction Of(Event Player);
		End;
		Event Player.FacingDirectionLeavingCP = Facing Direction Of(Event Player);
	}
}

rule("Pioneer Left Match")
{
	event
	{
		Player Left Match;
		All;
		All;
	}

	actions
	{
		If(Global.CurrentPioneer != Null);
			"Pioneer is not in game"
			If(Count Of(Filtered Array(All Players(All Teams), Current Array Element == Global.CurrentPioneer)) == 0);
				"Is there a player on final checkpoint waiting for pioneer"
				If(Count Of(Filtered Array(All Players(All Teams), True && Count Of(Global.CPLocations) == Current Array Element.CurrentCP + 1))
					> 0);
					Event Player.TempVariable = Random Value In Array(Filtered Array(All Players(All Teams), Count Of(Global.CPLocations)
						== Current Array Element.CurrentCP + 1));
					Big Message(All Players(All Teams), Custom String("Pioneer left match. Pioneer passed", Event Player.TempVariable));
					Global.PioneerTimer = Global.PioneerTimeLimitConstant;
					Event Player.TempVariable.ForceRespawn = True;
					Global.CurrentPioneer = Event Player.TempVariable;
				End;
			End;
		Else;
			If(Count Of(All Living Players(All Teams)) == 1);
				"Is there a player on final checkpoint waiting for pioneer"
				If(Count Of(Filtered Array(All Players(All Teams), True && Count Of(Global.CPLocations) == Current Array Element.CurrentCP + 1))
					> 0);
					Event Player.TempVariable = Random Value In Array(Filtered Array(All Players(All Teams), Count Of(Global.CPLocations)
						== Current Array Element.CurrentCP + 1));
					Big Message(All Players(All Teams), Custom String("Pioneer left match. Pioneer passed to {0}", Event Player.TempVariable));
					Global.PioneerTimer = Global.PioneerTimeLimitConstant;
					Event Player.TempVariable.ForceRespawn = True;
					Global.CurrentPioneer = Event Player.TempVariable;
				End;
			End;
		End;
	}
}

rule("Handle Memory Recall")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Wait(0.500, Ignore Condition);
		Call Subroutine(MemoryRecall);
		"something in memory"
		If(Count Of(Global.CPLocations) > 0);
			Global.GameStarted = True;
		End;
	}
}

disabled rule("Subroutines")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Sub0: RespawnPlayer")
{
	event
	{
		Subroutine;
		RespawnPlayer;
	}

	actions
	{
		Stop Holding Button(Event Player, Button(Secondary Fire));
		Teleport(Event Player, Global.CPLocations[Event Player.CurrentCP]);
		If(Is Button Held(Event Player, Button(Interact)));
			Event Player.FacingDirectionLeavingCP = Global.CPFacingDirections[Event Player.CurrentCP];
		End;
		Set Facing(Event Player, Event Player.FacingDirectionLeavingCP, To World);
		"If player is not pioneer and is not waiting for pioneer"
		If(Count Of(Global.CPLocations) > Event Player.CurrentCP + 1);
			Start Forcing Player To Be Hero(Event Player, Global.CPHeroList[Event Player.CurrentCP]);
		End;
		"Sigma Barrier Reset"
		If(Hero Of(Event Player) == Hero(Sigma));
			If(Event Player.sigma_barrier_ready_to_destroy);
				Press Button(Event Player, Button(Secondary Fire));
			End;
			Event Player.sigma_barrier_ON = False;
			Event Player.sigma_barrier_ready_to_destroy = False;
		End;
		Event Player.PunchFixStore = Hero Of(Event Player) == Hero(Doomfist) && Is Button Held(Event Player, Button(Secondary Fire));
		Cancel Primary Action(Event Player);
		Call Subroutine(CancelMomentum);
		Event Player.CPAbilityCounts = Vector(0, 0, 0);
		Event Player.CountUltimateTeleportPrimary = Vector(0, 0, 0);
		"Added this to fix issue where if you pressed R while using slam, the slam cooldown wasn't reset"
		Wait(0.100, Ignore Condition);
		Stop Chasing Player Variable(Event Player, SlamTimer);
		Event Player.SlamTimer = 0;
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Set Ultimate Charge(Event Player, 100);
		Event Player.CancelPointTimer = 0;
		"If player is not pioneer, player is not waiting for pioneer"
		If(Count Of(Global.CPLocations) > Event Player.CurrentCP + 1);
			If(X Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]) == 0);
				Set Secondary Fire Enabled(Event Player, False);
			Else;
				Set Secondary Fire Enabled(Event Player, True);
			End;
			If(Hero Of(Event Player) == Hero(Ana));
				Set Secondary Fire Enabled(Event Player, True);
			End;
			If(Y Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]) == 0);
				Set Ability 1 Enabled(Event Player, False);
			Else;
				Set Ability 1 Enabled(Event Player, True);
			End;
			If(Z Component Of(Global.CPAbilityCounts[Event Player.CurrentCP]) == 0);
				Set Ability 2 Enabled(Event Player, False);
			Else;
				Set Ability 2 Enabled(Event Player, True);
			End;
			If(X Component Of(Global.CPUltimateTeleportPrimary[Event Player.CurrentCP]) == 0);
				Set Ultimate Ability Enabled(Event Player, False);
			Else;
				Set Ultimate Ability Enabled(Event Player, True);
			End;
			If(Y Component Of(Global.CPUltimateTeleportPrimary[Event Player.CurrentCP]) == 0);
				Event Player.TeleportEnabled = False;
			Else;
				Event Player.TeleportEnabled = True;
				If(Event Player.CurrentCP > 0);
					Big Message(Event Player, Custom String("Teleport enabled for this point! Use Left Click + Melee to teleport!"));
				End;
			End;
			If(Index Of Array Value(Global.PrimaryFireUsefulForTheseHeros, Hero Of(Event Player)) >= 0);
				If(Z Component Of(Global.CPUltimateTeleportPrimary[Event Player.CurrentCP]) == 0);
					Set Primary Fire Enabled(Event Player, False);
				Else;
					Set Primary Fire Enabled(Event Player, True);
				End;
			End;
		"Is beginning of match, or player is pioneer, or player is waiting for pioneer"
		Else;
			Set Secondary Fire Enabled(Event Player, True);
			Set Ability 1 Enabled(Event Player, True);
			Set Ability 2 Enabled(Event Player, True);
			Event Player.TeleportEnabled = True;
			Set Primary Fire Enabled(Event Player, True);
			If(Global.UltimateAbilitiesEnabledConstant);
				Set Ultimate Ability Enabled(Event Player, True);
			End;
		End;
		Event Player.WinstonBouncyBubbleCooldown = 0;
		Destroy Effect(Event Player.WinstonBubbleEffect);
		Event Player.WinstonBubbleLocation = Null;
		"Should Fix Phased Out Status issue"
		Clear Status(Event Player, Phased Out);
		Set Status(Event Player, Null, Phased Out, 9999);
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Set Ability Cooldown(Event Player, Button(Crouch), 0);
		disabled Event Player.Count360Slam125 = Vector(0, 0, 0);
		Set Move Speed(Event Player, Global.PlayerMoveSpeedConstant);
		If(Event Player.PunchFixStore && Hero Of(Event Player) == Hero(Doomfist) && Is Button Held(Event Player, Button(Secondary Fire)));
			Start Holding Button(Event Player, Button(Secondary Fire));
		End;
		If(Hero Of(Event Player) == Hero(Junkrat));
			Set Ability Charge(Event Player, Button(Ability 1), 2);
		End;
		Enable Movement Collision With Environment(Event Player);
		Event Player.EffectLockSphereLocation = Null;
		Event Player.EffectLockObtained = False;
		"Don't reset env collision / kill sphere locations if you're the pioneer"
		If(Global.CurrentPioneer != Event Player || (Is Button Held(Event Player, Button(Interact)) && Is Button Held(Event Player, Button(
			Reload))));
			Event Player.GreenSphereLocation = Null;
			Event Player.KillSphereLocation = Null;
		End;
		Event Player.WinstonWallClimbEnabled = True;
		Event Player.ReplayPosition = Empty Array;
		Event Player.ReplayFacing = Empty Array;
		Set Gravity(Event Player, 100);
	}
}

rule("Sub2: CancelMomentum")
{
	event
	{
		Subroutine;
		CancelMomentum;
	}

	actions
	{
		Apply Impulse(Event Player, Up, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Down, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Left, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Right, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Forward, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Backward, 0.001, To World, Cancel Contrary Motion);
	}
}

rule("Sub3: HandleSkipTimer")
{
	event
	{
		Subroutine;
		HandleSkipTimer;
	}

	actions
	{
		"If Player is pioneer or waiting for pioneer"
		If(Count Of(Global.CPLocations) == Event Player.CurrentCP + 1 || False);
			Stop Chasing Player Variable(Event Player, TimeSpentOnCP);
			Event Player.TimeSpentOnCP = 0;
		Else;
			Event Player.TimeSpentOnCP = 0;
			Chase Player Variable At Rate(Event Player, TimeSpentOnCP, 9999, 1, Destination and Rate);
		End;
	}
}

rule("Punch Grace")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.Grace = 0.119;
	}
}

disabled rule("Pioneer Effect Lock And Environment Collision Spheres")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Pioneer Create Green Sphere with Melee")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Is Button Held(Event Player, Button(Crouch)) == True;
		Hero Of(Event Player) != Hero(Wrecking Ball);
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		disabled Event Player.GreenSphereLocation = Eye Position(Event Player);
		Event Player.GreenSphereLocation = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 12, Null, Event Player, True);
	}
}

rule("Green Sphere Rule (Pioneer Only) - In Sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Event Player.GreenSphereLocation != Null;
		Distance Between(Eye Position(Event Player), Event Player.GreenSphereLocation) < Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Disable Movement Collision With Environment(Event Player, False);
	}
}

rule("Green Sphere Rule (Pioneer Only) - Outside Sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Event Player.GreenSphereLocation != Null;
		Distance Between(Eye Position(Event Player), Event Player.GreenSphereLocation) > Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Wait(0.250, Ignore Condition);
		Enable Movement Collision With Environment(Event Player);
	}
}

rule("Green Sphere Rule (Non-Pioneer) - In Sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Global.CPGreenSphereArray[Event Player.CurrentCP] != Null;
		Distance Between(Eye Position(Event Player), Global.CPGreenSphereArray[Event Player.CurrentCP]) < Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Disable Movement Collision With Environment(Event Player, False);
	}
}

rule("Green Sphere Rule (Non-Pioneer) - Outside Sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Global.CPGreenSphereArray[Event Player.CurrentCP] != Null;
		Distance Between(Eye Position(Event Player), Global.CPGreenSphereArray[Event Player.CurrentCP]) > Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Wait(0.250, Ignore Condition);
		Enable Movement Collision With Environment(Event Player);
	}
}

rule("Pioneer Create Effect Lock Sphere with Group Up Voiceline")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Is Button Held(Event Player, Button(Melee)) == True;
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.EffectLockSphereLocation = Eye Position(Event Player);
		Small Message(Event Player, Custom String("Effect Lock Sphere Created!"));
		Play Effect(Event Player, Ring Explosion Sound, Color(White), Event Player, 60);
	}
}

rule("Obtain Effect Lock Sphere (Non-Pioneer)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Global.CPEffectLockSphereArray[Event Player.CurrentCP] != Null;
		Distance Between(Eye Position(Event Player), Global.CPEffectLockSphereArray[Event Player.CurrentCP])
			< Global.EffectLockSphereRadiusConstant;
		Event Player.EffectLockObtained != True;
	}

	actions
	{
		Event Player.EffectLockObtained = True;
		Play Effect(Event Player, Ring Explosion Sound, Color(White), Event Player, 60);
		Small Message(Event Player, Custom String("Effect Lock Obtained!"));
	}
}

rule("Pioneer Create Kill Sphere With Group Up")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Is Communicating(Event Player, Group Up) == True;
		Event Player.CancelPointTimer == 0;
	}

	actions
	{
		Event Player.KillSphereLocation = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 20, Null, Event Player, True);
		Small Message(Event Player, Custom String("Kill Sphere Created!"));
		Play Effect(Event Player, Buff Explosion Sound, Color(White), Event Player, 60);
	}
}

rule("Pioneer Respawns if in kill sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer == Event Player;
		Event Player.KillSphereLocation != Null;
		Distance Between(Eye Position(Event Player), Event Player.KillSphereLocation) < Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
		Small Message(Event Player, Custom String("Avoid the red spheres!"));
	}
}

rule("Non-Pioneer Respawns if in Kill Sphere")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.CurrentPioneer != Event Player;
		Global.CPKillSphereArray[Event Player.CurrentCP] != Null;
		Distance Between(Eye Position(Event Player), Global.CPKillSphereArray[Event Player.CurrentCP]) < Global.GreenSphereRadiusConstant;
	}

	actions
	{
		Call Subroutine(RespawnPlayer);
		Small Message(Event Player, Custom String("Avoid the red spheres!"));
	}
}

disabled rule("Sigma Abilities")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Barrier {1}")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.sigma_barrier_ON = True;
		Event Player.sigma_barrier_init_position = Eye Position(Event Player) + Facing Direction Of(Event Player) * 3;
		Event Player.sigma_barrier_direction = Facing Direction Of(Event Player);
		Event Player.sigma_barrier_chase = 0;
		Chase Player Variable At Rate(Event Player, sigma_barrier_chase, Distance Between(Event Player.sigma_barrier_init_position,
			Ray Cast Hit Position(Event Player.sigma_barrier_init_position,
			Event Player.sigma_barrier_init_position + Event Player.sigma_barrier_direction * 200, Null, Event Player, False)), 16.500,
			Destination and Rate);
		"Updates barrier position"
		While(True);
			Event Player.sigma_barrier_position = Event Player.sigma_barrier_init_position + Event Player.sigma_barrier_direction * Event Player.sigma_barrier_chase;
			Wait(0.016, Ignore Condition);
			Abort If Condition Is False;
		End;
	}
}

rule("Barrier {2}")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == False;
		Event Player.sigma_barrier_ON == True;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, sigma_barrier_chase);
		Wait(0.192, Ignore Condition);
		Event Player.sigma_barrier_ready_to_destroy = True;
	}
}

rule("Barrier Launch")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Event Player.sigma_barrier_ON == True;
		Distance Between(Eye Position(Event Player), Event Player.sigma_barrier_position) < 3;
	}

	actions
	{
		"{Turns shield into a bouncepad instead when turned on}"
		disabled Event Player.sigma_barrier_direction = Vector(X Component Of(Event Player.sigma_barrier_direction), Absolute Value(Y Component Of(
			Event Player.sigma_barrier_direction)), Z Component Of(Event Player.sigma_barrier_direction));
		Apply Impulse(Event Player, Event Player.sigma_barrier_direction, 30, To World, Cancel Contrary Motion);
	}
}

rule("Remove Barrier")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Event Player.sigma_barrier_ready_to_destroy == True;
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
	}

	actions
	{
		Event Player.sigma_barrier_ON = False;
		Wait(0.016, Ignore Condition);
		Event Player.sigma_barrier_ready_to_destroy = False;
	}
}

rule("Destroy Pulse On Death")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Dead(Event Player) == True;
	}

	actions
	{
		Event Player.sigma_barrier_ON = False;
		Event Player.sigma_barrier_ready_to_destroy = False;
	}
}

rule("Vortex Drag {By default, using vortex makes you glide across the ground without resetting during the animation}")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Set Gravity(Event Player, 0);
		disabled Set Move Speed(Event Player, 0);
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Wait Until(Is Button Held(Event Player, Button(Reload)), 2);
		disabled Wait(2, Restart When True);
		Set Gravity(Event Player, 100);
		disabled Set Move Speed(Event Player, 100);
		Stop Forcing Throttle(Event Player);
	}
}

rule("Vortex Refresh")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Dead(Event Player) == True;
	}

	actions
	{
		Set Move Speed(Event Player, 100);
		Set Gravity(Event Player, 100);
	}
}

rule("Rock Booster")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		"Rock can be used during the vortex animation"
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Wait(0.650, Ignore Condition);
		Apply Impulse(Event Player, Facing Direction Of(Event Player), -14, To World, Cancel Contrary Motion);
	}
}

disabled rule("WINSTON STUFF")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Initialize Winston")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	actions
	{
		Event Player.WinstonBubbleLocation = Null;
	}
}

rule("Winston Leap Grace - Toggle On When Using Leap")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
		disabled Distance Between(Global.CPLocations[Event Player.CurrentCP], Position Of(Event Player)) > Global.CPRadius;
		disabled Distance Between(Global.CPLocations[Event Player.CurrentCP + 1], Position Of(Event Player)) > Global.CPRadius;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, WinstonLeapGrace);
		Event Player.WinstonLeapGrace = 0.250;
		disabled Chase Player Variable At Rate(Event Player, WinstonLeapGrace, 0, 1, Destination and Rate);
	}
}

rule("Winston Leap Grace - Set Grace Variable Chase When Touching Ground")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == False;
		Is On Ground(Event Player) == True;
	}

	actions
	{
		Chase Player Variable At Rate(Event Player, WinstonLeapGrace, 0, 1, Destination and Rate);
	}
}

rule("Create Bubble")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		"Place Bubble on ground below player. Easier for new players to figure out what's going on (compared to Ray Cast bubble position)."
		Event Player.WinstonBubbleLocation = Position Of(Event Player) + World Vector Of(Forward, Event Player, Rotation)
			* Horizontal Speed Of(Event Player) * 0.300 + Down * Altitude Of(Event Player);
		"Use Ray Cast to determine bubble position"
		disabled Event Player.WinstonBubbleLocation = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 160, All Players(All Teams), Event Player, False);
		If(Distance Between(Event Player.WinstonBubbleLocation, Position Of(Event Player)) > 100);
			Small Message(Event Player, Custom String("Barrier Cast Out Of Range (100m)"));
			Set Ability Cooldown(Event Player, Button(Ability 2), 0);
			Abort;
		End;
		Create Effect(Event Player, Sphere, Color(Blue), Event Player.WinstonBubbleLocation, 5, Visible To Position and Radius);
		Event Player.WinstonBubbleEffect = Last Created Entity;
		Event Player.WinstonBouncyBubbleCooldown = 9;
		Chase Player Variable At Rate(Event Player, WinstonBouncyBubbleCooldown, 0, 1, Destination and Rate);
		While(Event Player.WinstonBouncyBubbleCooldown > 0 && !Is Dead(Event Player));
			Wait(0.100, Ignore Condition);
		End;
		Destroy Effect(Event Player.WinstonBubbleEffect);
		Event Player.WinstonBubbleLocation = Null;
	}
}

rule("Winston Bubble Physics Rule")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Event Player.WinstonBubbleLocation != Null;
		Distance Between(Position Of(Event Player), Event Player.WinstonBubbleLocation) <= 5;
	}

	actions
	{
		"Direct Impulse - Cancel's Player Motion, so physically inaccurate bounce"
		Apply Impulse(Event Player, Direction Towards(Event Player.WinstonBubbleLocation, Position Of(Event Player)), Speed Of(
			Event Player) * 1.300, To World, Cancel Contrary Motion);
	}
}

rule("Winston Wall Climb")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) == True;
		"Make this so a player can't use wall climb multiple times in a row."
		Event Player.WinstonWallClimbEnabled == True;
	}

	actions
	{
		Event Player.WinstonWallClimbTimer = 4;
		"Set Wall Climb to have a max of 4 sec duration. This prevents you from wall climing against a roof/skybox for indefinite stall."
		Chase Player Variable Over Time(Event Player, WinstonWallClimbTimer, 0, 4, Destination and Duration);
		"Wall Climb while Jump is held, have been wall climbing less than 4 sec, are within 0.5m of wall"
		While(Is Button Held(Event Player, Button(Jump)) && Event Player.WinstonWallClimbTimer > 0 && Distance Between(
			Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + Direction From Angles(
			Horizontal Angle From Direction(Facing Direction Of(Event Player)), 0) * 10, All Players(All Teams), Event Player, True),
			Eye Position(Event Player)) < 3);
			Wait(0.033, Ignore Condition);
			Set Move Speed(Event Player, 0);
			Apply Impulse(Event Player, Up, 7, To World, Cancel Contrary Motion);
			Apply Impulse(Event Player, Forward, 1, To Player, Cancel Contrary Motion);
			Event Player.WinstonWallClimbEnabled = False;
		End;
		Set Move Speed(Event Player, 100);
		Wait(0.033, Ignore Condition);
		Loop If Condition Is True;
	}
}

disabled rule("ANA MODIFIERS")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Ana Primary Impulse")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ana;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
		Has Status(Event Player, Rooted) == False;
		disabled Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Set Gravity(Event Player, 0);
		Apply Impulse(Event Player, Facing Direction Of(Event Player), 15, To World, Cancel Contrary Motion);
		Wait(0.060, Ignore Condition);
		Set Gravity(Event Player, 100);
	}
}

rule("Ana Sleep Dart Teleport")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ana;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Stop Camera(Event Player);
		"The duration before Ana fires sleep dart"
		Wait(0.300, Ignore Condition);
		Event Player.AnaSleepDartTeleLocation = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 180, All Players(All Teams), Event Player, True);
		"Shorten ray cast to avoid unintended tele through surfaces"
		Event Player.AnaSleepDartTeleLocation -= Direction Towards(Eye Position(Event Player), Event Player.AnaSleepDartTeleLocation)
			* 0.500;
		If(Y Component Of(Event Player.AnaSleepDartTeleLocation) > 24);
			Small Message(Event Player, Custom String("Teleport location elevation too high"));
			Cancel Primary Action(Event Player);
			Wait(0.100, Ignore Condition);
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
			Abort;
		End;
		"Sleep dart travel time"
		Wait(Distance Between(Eye Position(Event Player), Event Player.AnaSleepDartTeleLocation) / 60, Ignore Condition);
		Teleport(Event Player, Event Player.AnaSleepDartTeleLocation);
		Call Subroutine(CancelMomentum);
		disabled Small Message(Event Player, Custom String("{0} alt {1}", Event Player.AnaSleepDartTeleLocation, Altitude Of(Event Player)));
	}
}

rule("Heal = Impulse {must be damaged when spawning}")
{
	event
	{
		Player Dealt Healing;
		All;
		Ana;
	}

	conditions
	{
		Healee == Healer;
		Has Status(Event Player, Rooted) == False;
	}

	actions
	{
		Apply Impulse(Event Player, Facing Direction Of(Event Player), -15, To World, Cancel Contrary Motion);
		Wait(1, Ignore Condition);
	}
}

rule("Ana Health Managment")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ana;
	}

	conditions
	{
		Normalized Health(Event Player) >= 1;
		Is In Spawn Room(Event Player) != True;
	}

	actions
	{
		Clear Status(Event Player, Phased Out);
		Damage(Event Player, Event Player, 50);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
		Set Status(Event Player, Null, Phased Out, 9999);
	}
}

disabled rule("ROADHOG STUFF")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Change Hook to Grappling Hook")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		"Initial impulse to let you hook in midair without falling too far while hook is out"
		Apply Impulse(Event Player, Up, 3, To World, Cancel Contrary Motion);
		"Issue here is that we are using ray cast to determine hook impact, which isn't visually accurate, so the hook may impact a wall but not be deteted."
		Event Player.RoadhogHookPosition = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ 120 * Facing Direction Of(Event Player), All Players(All Teams), Event Player, True);
		"Abort if hook didn't connect with a wall within 25m. For reference, 20m is hook range for normal roadhog."
		If(Distance Between(Position Of(Event Player), Event Player.RoadhogHookPosition) > 25);
			Small Message(Event Player, Custom String("Out of hook range!"));
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
			Abort;
		End;
		"Wait for hook to \"hit\" something. Hook moves at 40m/s"
		Wait(Distance Between(Position Of(Event Player), Event Player.RoadhogHookPosition) / 40, Ignore Condition);
		"Impulse that increases with hook range. Hook impulse = Base Impulse + Hook Range x Range Multiplier."
		Apply Impulse(Event Player, Direction Towards(Position Of(Event Player), Event Player.RoadhogHookPosition), 20 + Distance Between(
			Event Player.RoadhogHookPosition, Position Of(Event Player)) * 0.800, To World, Cancel Contrary Motion);
		"Large Linear Impulse. Disabled while testing impulse that increases with range."
		disabled Apply Impulse(Event Player, Direction Towards(Position Of(Event Player), Event Player.RoadhogHookPosition), 40, To World,
			Cancel Contrary Motion);
	}
}

rule("Change Take A Breather to Bouncy Ball Hog")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		disabled Is On Ground(Event Player) == True;
		Altitude Of(Event Player) <= 1.500;
	}

	actions
	{
		Apply Impulse(Event Player, Up, Speed Of(Event Player) * 1.200, To World, Cancel Contrary Motion);
	}
}

rule("Add Knockback When Secondary Fire Used")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Apply Impulse(Event Player, Facing Direction Of(Event Player), -12, To World, Cancel Contrary Motion);
	}
}

rule("Roadhog Ultimate")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Disable Movement Collision With Environment(Event Player, False);
		Small Message(Event Player, Custom String("Hold {0} to Cancel Ultimate", Input Binding String(Button(Primary Fire))));
		While(Is Using Ultimate(Event Player) && !Is Button Held(Event Player, Button(Primary Fire)));
			Wait(0.033, Ignore Condition);
			"Cause knockback on player"
			disabled Apply Impulse(Event Player, Facing Direction Of(Event Player), -10, To World, Cancel Contrary Motion);
			"Player Knockback"
			Apply Impulse(Event Player, Facing Direction Of(Event Player), -8, To World, Cancel Contrary Motion);
			"\"Drill\" Through Walls, Skyboxes, etc."
			disabled Teleport(Event Player, Position Of(Event Player) + Facing Direction Of(Event Player) * -1.500);
		End;
		"For melee cancel on ult"
		Cancel Primary Action(Event Player);
		Enable Movement Collision With Environment(Event Player);
	}
}

rule("Limit Roadhog Ultimate Duration")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		"Set Ult Duration to 3 sec, then cancel it"
		Wait(3, Ignore Condition);
		Cancel Primary Action(Event Player);
	}
}